<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>h2o_q.autoreload API documentation</title>
<meta name="description" content="Automatically restart the server when a source file is modified." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&display=swap" rel="stylesheet">
<link href="https://rsms.me/inter/inter-ui.css" rel="stylesheet">
<style>
body {
font-family: 'Inter', sans-serif;
font-size: 1rem;
color: #000;
-webkit-font-smoothing: antialiased;
line-height: 1.666666;
}
img {
max-width: 100%;
}
h1, h2, h3, h4, h5, h6, b, strong {
font-weight: 600;
}
h1, h2, h3, h4, h5, h6 {
font-size: 1rem;
line-height: 1.5;
}
h1 {
margin: 3rem 0 2rem 0;
border-top: 1px solid #000;
}
a {
text-decoration: none;
color: inherit;
border-color: #000;
border-bottom-style: solid;
border-bottom-width: 1px;
}
code {
font-family: 'Inconsolata', monospace;
}
pre {
border: none;
}
dd {
margin-left: 1em;
}
.http-server-breadcrumbs {
font-size: 100%;
}
#sidebar h1, #index h3, #index a, .toc a {
border: none;
}
.desc h2 {
font-size: 1rem;
font-weight: 600;
}
.name {
font-size:1em;
}
.hljs-comment {
font-style: normal;
}
.logo {
border: 10px solid #ffdf00;
height: 110px;
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>h2o_q.autoreload</code></h1>
</header>
<section id="section-intro">
<p>Automatically restart the server when a source file is modified.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This is a standalone, minimal version of the Tornado autoreload module ported from IOLoop to asyncio.
# There is no dependency on Tornado.
#
# Original implementation: https://github.com/tornadoweb/tornado/blob/master/tornado/autoreload.py

#
# Copyright 2009 Facebook
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

&#34;&#34;&#34;Automatically restart the server when a source file is modified.
&#34;&#34;&#34;

import os
import sys
import asyncio

# sys.path handling
# -----------------
#
# If a module is run with &#34;python -m&#34;, the current directory (i.e. &#34;&#34;)
# is automatically prepended to sys.path, but not if it is run as
# &#34;path/to/file.py&#34;.  The processing for &#34;-m&#34; rewrites the former to
# the latter, so subsequent executions won&#39;t have the same path as the
# original.
#
# Conversely, when run as path/to/file.py, the directory containing
# file.py gets added to the path, which can cause confusion as imports
# may become relative in spite of the future import.
#
# We address the former problem by reconstructing the original command
# line (Python &gt;= 3.4) or by setting the $PYTHONPATH environment
# variable (Python &lt; 3.4) before re-execution so the new process will
# see the correct path.  We attempt to address the latter problem when
# h2o_q.autoreload is run as __main__.

if __name__ == &#34;__main__&#34;:
    # This sys.path manipulation must come before our imports (as much
    # as possible - if we introduced a h2o_q.sys or h2o_q.os
    # module we&#39;d be in trouble), or else our imports would become
    # relative again despite the future import.
    #
    # There is a separate __main__ block at the end of the file to call main().
    if sys.path[0] == os.path.dirname(__file__):
        del sys.path[0]

import math
import functools
import logging
import os
import pkgutil  # type: ignore
import sys
import traceback
import types
import subprocess
import weakref
from typing import Callable, Dict, List, Optional, Any, Mapping

logger = logging.getLogger(&#39;h2o_q.autoreload&#39;)

try:
    import signal
except ImportError:
    signal = None  # type: ignore

# os.execv is broken on Windows and can&#39;t properly parse command line
# arguments and executable name if they contain whitespaces. subprocess
# fixes that behavior.
_has_execv = sys.platform != &#34;win32&#34;

_watched_files = set()
_reload_hooks = []
_reload_attempted = False
_io_loops = weakref.WeakKeyDictionary()  # type: ignore
_autoreload_is_main = False
_original_argv = None  # type: Optional[List[str]]
_original_spec = None


def rerun(code: Any, glob: Dict[str, Any], loc: Optional[Optional[Mapping[str, Any]]] = None) -&gt; None:
    if isinstance(code, str):
        # exec(string) inherits the caller&#39;s future imports; compile
        # the string first to prevent that.
        code = compile(code, &#34;&lt;string&gt;&#34;, &#34;exec&#34;, dont_inherit=True)
    exec(code, glob, loc)


class _Poll:
    &#34;&#34;&#34;Schedules the given callback to be called periodically.

    The callback is called every ``interval_ms`` milliseconds.
    Note that the timeout is given in milliseconds, while most other
    time-related functions in Tornado use seconds.

    If the callback runs for longer than ``interval_ms`` milliseconds,
    subsequent invocations will be skipped to get back on schedule.

    `start` must be called after the `_Poll` is created.
    &#34;&#34;&#34;

    def __init__(self, callback: Callable[[], None], interval_ms: float) -&gt; None:
        self.callback = callback
        if interval_ms &lt;= 0:
            raise ValueError(&#34;interval_ms must be positive&#34;)
        self.interval_ms = interval_ms
        self._running = False
        self._timeout: Optional[asyncio.TimerHandle] = None
        self.io_loop: Optional[asyncio.AbstractEventLoop] = None
        self._next_timeout = 0.0

    def start(self) -&gt; None:
        &#34;&#34;&#34;Starts the timer.&#34;&#34;&#34;
        # Looking up the event loop here allows to first instantiate the
        # _Poll in another thread, then start it using call_at().
        self.io_loop = asyncio.get_event_loop()  # TODO switch to get_running_loop() in 3.7
        self._running = True
        self._next_timeout = self.io_loop.time()
        self._schedule_next()

    def stop(self) -&gt; None:
        &#34;&#34;&#34;Stops the timer.&#34;&#34;&#34;
        self._running = False
        if self._timeout is not None:
            self._timeout.cancel()
            self._timeout = None

    def is_running(self) -&gt; bool:
        &#34;&#34;&#34;Returns ``True`` if this `._Poll` has been started.
        &#34;&#34;&#34;
        return self._running

    def _run(self) -&gt; None:
        if not self._running:
            return
        try:
            return self.callback()
        except Exception:
            logger.error(&#34;Exception in callback %r&#34;, self.callback, exc_info=True)
        finally:
            self._schedule_next()

    def _schedule_next(self) -&gt; None:
        if self._running:
            self._update_next(self.io_loop.time())
            self._timeout = self.io_loop.call_at(self._next_timeout, self._run)

    def _update_next(self, current_time: float) -&gt; None:
        interval_s = self.interval_ms / 1000.0
        if self._next_timeout &lt;= current_time:
            # The period should be measured from the start of one call
            # to the start of the next. If one call takes too long,
            # skip cycles to get back to a multiple of the original
            # schedule.
            self._next_timeout += (math.floor((current_time - self._next_timeout) / interval_s) + 1) * interval_s
        else:
            # If the clock moved backwards, ensure we advance the next
            # timeout instead of recomputing the same value again.
            # This may result in long gaps between callbacks if the
            # clock jumps backwards by a lot, but the far more common
            # scenario is a small NTP adjustment that should just be
            # ignored.
            #
            # Note that on some systems if time.time() runs slower
            # than time.monotonic() (most common on windows), we
            # effectively experience a small backwards time jump on
            # every iteration because _Poll uses
            # time.time() while asyncio schedules callbacks using
            # time.monotonic().
            self._next_timeout += interval_s


def start(check_time: int = 500) -&gt; None:
    &#34;&#34;&#34;Begins watching source files for changes.
    &#34;&#34;&#34;
    io_loop = asyncio.get_event_loop()
    if io_loop in _io_loops:
        return
    _io_loops[io_loop] = True
    if len(_io_loops) &gt; 1:
        logger.warning(&#34;h2o_q.autoreload started more than once in the same process&#34;)
    modify_times = {}  # type: Dict[str, float]
    callback = functools.partial(_reload_on_update, modify_times)
    scheduler = _Poll(callback, check_time)
    scheduler.start()


def wait() -&gt; None:
    &#34;&#34;&#34;Wait for a watched file to change, then restart the process.

    Intended to be used at the end of scripts like unit test runners,
    to run the tests again after any source file changes (but see also
    the command-line interface in `main`)
    &#34;&#34;&#34;
    io_loop = asyncio.get_event_loop()
    io_loop.call_soon(start)
    io_loop.run_forever()
    io_loop.close()


def watch(filename: str) -&gt; None:
    &#34;&#34;&#34;Add a file to the watch list.

    All imported modules are watched by default.
    &#34;&#34;&#34;
    _watched_files.add(filename)


def add_reload_hook(fn: Callable[[], None]) -&gt; None:
    &#34;&#34;&#34;Add a function to be called before reloading the process.

    Note that for open file and socket handles it is generally
    preferable to set the ``FD_CLOEXEC`` flag (using `fcntl` or
    `os.set_inheritable`) instead of using a reload hook to close them.
    &#34;&#34;&#34;
    _reload_hooks.append(fn)


def _reload_on_update(modify_times: Dict[str, float]) -&gt; None:
    if _reload_attempted:
        # We already tried to reload and it didn&#39;t work, so don&#39;t try again.
        return
    # if process.task_id() is not None:
    #     # We&#39;re in a child process created by fork_processes.  If child
    #     # processes restarted themselves, they&#39;d all restart and then
    #     # all call fork_processes again.
    #     return
    for module in list(sys.modules.values()):
        # Some modules play games with sys.modules (e.g. email/__init__.py
        # in the standard library), and occasionally this can cause strange
        # failures in getattr.  Just ignore anything that&#39;s not an ordinary
        # module.
        if not isinstance(module, types.ModuleType):
            continue
        path = getattr(module, &#34;__file__&#34;, None)
        if not path:
            continue
        if path.endswith(&#34;.pyc&#34;) or path.endswith(&#34;.pyo&#34;):
            path = path[:-1]
        _check_file(modify_times, path)
    for path in _watched_files:
        _check_file(modify_times, path)


def _check_file(modify_times: Dict[str, float], path: str) -&gt; None:
    try:
        modified = os.stat(path).st_mtime
    except Exception:
        return
    if path not in modify_times:
        modify_times[path] = modified
        return
    if modify_times[path] != modified:
        logger.info(&#34;%s modified; restarting server&#34;, path)
        _reload()


def _reload() -&gt; None:
    global _reload_attempted
    _reload_attempted = True
    for fn in _reload_hooks:
        fn()
    if hasattr(signal, &#34;setitimer&#34;):
        # Clear the alarm signal set by
        # ioloop.set_blocking_log_threshold so it doesn&#39;t fire
        # after the exec.
        signal.setitimer(signal.ITIMER_REAL, 0, 0)
    # sys.path fixes: see comments at top of file.  If __main__.__spec__
    # exists, we were invoked with -m and the effective path is about to
    # change on re-exec.  Reconstruct the original command line to
    # ensure that the new process sees the same path we did.  If
    # __spec__ is not available (Python &lt; 3.4), check instead if
    # sys.path[0] is an empty string and add the current directory to
    # $PYTHONPATH.
    if _autoreload_is_main:
        assert _original_argv is not None
        spec = _original_spec
        argv = _original_argv
    else:
        spec = getattr(sys.modules[&#34;__main__&#34;], &#34;__spec__&#34;, None)
        argv = sys.argv
    if spec:
        argv = [&#34;-m&#34;, spec.name] + argv[1:]
    else:
        path_prefix = &#34;.&#34; + os.pathsep
        if sys.path[0] == &#34;&#34; and not os.environ.get(&#34;PYTHONPATH&#34;, &#34;&#34;).startswith(path_prefix):
            os.environ[&#34;PYTHONPATH&#34;] = path_prefix + os.environ.get(&#34;PYTHONPATH&#34;, &#34;&#34;)
    if not _has_execv:
        subprocess.Popen([sys.executable] + argv)
        os._exit(0)
    else:
        try:
            os.execv(sys.executable, [sys.executable] + argv)
        except OSError:
            # Mac OS X versions prior to 10.6 do not support execv in
            # a process that contains multiple threads.  Instead of
            # re-executing in the current process, start a new one
            # and cause the current process to exit.  This isn&#39;t
            # ideal since the new process is detached from the parent
            # terminal and thus cannot easily be killed with ctrl-C,
            # but it&#39;s better than not being able to autoreload at
            # all.
            # Unfortunately the errno returned in this case does not
            # appear to be consistent, so we can&#39;t easily check for
            # this error specifically.
            os.spawnv(
                os.P_NOWAIT, sys.executable, [sys.executable] + argv  # type: ignore
            )
            # At this point the event loop has been closed and finally
            # blocks will experience errors if we allow the stack to
            # unwind, so just exit uncleanly.
            os._exit(0)


_USAGE = &#34;&#34;&#34;\
Usage:
  python -m h2o_q -m module.to.run [args...]
  python -m h2o_q path/to/script.py [args...]
&#34;&#34;&#34;


def main() -&gt; None:
    &#34;&#34;&#34;Command-line wrapper to re-run a script whenever its source changes.

    Scripts may be specified by filename or module name::

        python -m h2o_q -m h2o_q.test.runtests
        python -m h2o_q h2o_q/test/runtests.py

    Running a script with this wrapper is similar to calling
    `h2o_q.autoreload.wait` at the end of the script, but this wrapper
    can catch import-time problems like syntax errors that would otherwise
    prevent the script from reaching its call to `wait`.
    &#34;&#34;&#34;
    # Remember that we were launched with autoreload as main.
    # The main module can be tricky; set the variables both in our globals
    # (which may be __main__) and the real importable version.

    import h2o_q.autoreload

    global _autoreload_is_main
    global _original_argv, _original_spec
    h2o_q.autoreload._autoreload_is_main = _autoreload_is_main = True
    original_argv = sys.argv
    h2o_q.autoreload._original_argv = _original_argv = original_argv
    original_spec = getattr(sys.modules[&#34;__main__&#34;], &#34;__spec__&#34;, None)
    h2o_q.autoreload._original_spec = _original_spec = original_spec
    sys.argv = sys.argv[:]
    if len(sys.argv) &gt;= 3 and sys.argv[1] == &#34;-m&#34;:
        mode = &#34;module&#34;
        module = sys.argv[2]
        del sys.argv[1:3]
    elif len(sys.argv) &gt;= 2:
        mode = &#34;script&#34;
        script = sys.argv[1]
        sys.argv = sys.argv[1:]
    else:
        print(_USAGE, file=sys.stderr)
        sys.exit(1)

    try:
        if mode == &#34;module&#34;:
            import runpy

            runpy.run_module(module, run_name=&#34;__main__&#34;, alter_sys=True)
        elif mode == &#34;script&#34;:
            with open(script) as f:
                # Execute the script in our namespace instead of creating
                # a new one so that something that tries to import __main__
                # (e.g. the unittest module) will see names defined in the
                # script instead of just those defined in this module.
                global __file__
                __file__ = script
                # If __package__ is defined, imports may be incorrectly
                # interpreted as relative to this module.
                global __package__
                del __package__
                rerun(f.read(), globals(), globals())
    except SystemExit as e:
        logging.basicConfig()
        logger.info(&#34;Script exited with status %s&#34;, e.code)
    except Exception as e:
        logging.basicConfig()
        logger.warning(&#34;Script exited with uncaught exception&#34;, exc_info=True)
        # If an exception occurred at import time, the file with the error
        # never made it into sys.modules and so we won&#39;t know to watch it.
        # Just to make sure we&#39;ve covered everything, walk the stack trace
        # from the exception and watch every file.
        for (filename, lineno, name, line) in traceback.extract_tb(sys.exc_info()[2]):
            watch(filename)
        if isinstance(e, SyntaxError):
            # SyntaxErrors are special:  their innermost stack frame is fake
            # so extract_tb won&#39;t see it and we have to get the filename
            # from the exception object.
            watch(e.filename)
    else:
        logging.basicConfig()
        logger.info(&#34;Script exited normally&#34;)
    # restore sys.argv so subsequent executions will include autoreload
    sys.argv = original_argv

    if mode == &#34;module&#34;:
        # runpy did a fake import of the module as __main__, but now it&#39;s
        # no longer in sys.modules.  Figure out where it is and watch it.
        loader = pkgutil.get_loader(module)
        if loader is not None:
            watch(loader.get_filename())  # type: ignore

    wait()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="h2o_q.autoreload.add_reload_hook"><code class="name flex">
<span>def <span class="ident">add_reload_hook</span></span>(<span>fn: Callable[[], NoneType]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add a function to be called before reloading the process.</p>
<p>Note that for open file and socket handles it is generally
preferable to set the <code>FD_CLOEXEC</code> flag (using <code>fcntl</code> or
<code>os.set_inheritable</code>) instead of using a reload hook to close them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_reload_hook(fn: Callable[[], None]) -&gt; None:
    &#34;&#34;&#34;Add a function to be called before reloading the process.

    Note that for open file and socket handles it is generally
    preferable to set the ``FD_CLOEXEC`` flag (using `fcntl` or
    `os.set_inheritable`) instead of using a reload hook to close them.
    &#34;&#34;&#34;
    _reload_hooks.append(fn)</code></pre>
</details>
</dd>
<dt id="h2o_q.autoreload.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Command-line wrapper to re-run a script whenever its source changes.</p>
<p>Scripts may be specified by filename or module name::</p>
<pre><code>python -m h2o_q -m h2o_q.test.runtests
python -m h2o_q h2o_q/test/runtests.py
</code></pre>
<p>Running a script with this wrapper is similar to calling
<code><a title="h2o_q.autoreload.wait" href="#h2o_q.autoreload.wait">wait()</a></code> at the end of the script, but this wrapper
can catch import-time problems like syntax errors that would otherwise
prevent the script from reaching its call to <code><a title="h2o_q.autoreload.wait" href="#h2o_q.autoreload.wait">wait()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main() -&gt; None:
    &#34;&#34;&#34;Command-line wrapper to re-run a script whenever its source changes.

    Scripts may be specified by filename or module name::

        python -m h2o_q -m h2o_q.test.runtests
        python -m h2o_q h2o_q/test/runtests.py

    Running a script with this wrapper is similar to calling
    `h2o_q.autoreload.wait` at the end of the script, but this wrapper
    can catch import-time problems like syntax errors that would otherwise
    prevent the script from reaching its call to `wait`.
    &#34;&#34;&#34;
    # Remember that we were launched with autoreload as main.
    # The main module can be tricky; set the variables both in our globals
    # (which may be __main__) and the real importable version.

    import h2o_q.autoreload

    global _autoreload_is_main
    global _original_argv, _original_spec
    h2o_q.autoreload._autoreload_is_main = _autoreload_is_main = True
    original_argv = sys.argv
    h2o_q.autoreload._original_argv = _original_argv = original_argv
    original_spec = getattr(sys.modules[&#34;__main__&#34;], &#34;__spec__&#34;, None)
    h2o_q.autoreload._original_spec = _original_spec = original_spec
    sys.argv = sys.argv[:]
    if len(sys.argv) &gt;= 3 and sys.argv[1] == &#34;-m&#34;:
        mode = &#34;module&#34;
        module = sys.argv[2]
        del sys.argv[1:3]
    elif len(sys.argv) &gt;= 2:
        mode = &#34;script&#34;
        script = sys.argv[1]
        sys.argv = sys.argv[1:]
    else:
        print(_USAGE, file=sys.stderr)
        sys.exit(1)

    try:
        if mode == &#34;module&#34;:
            import runpy

            runpy.run_module(module, run_name=&#34;__main__&#34;, alter_sys=True)
        elif mode == &#34;script&#34;:
            with open(script) as f:
                # Execute the script in our namespace instead of creating
                # a new one so that something that tries to import __main__
                # (e.g. the unittest module) will see names defined in the
                # script instead of just those defined in this module.
                global __file__
                __file__ = script
                # If __package__ is defined, imports may be incorrectly
                # interpreted as relative to this module.
                global __package__
                del __package__
                rerun(f.read(), globals(), globals())
    except SystemExit as e:
        logging.basicConfig()
        logger.info(&#34;Script exited with status %s&#34;, e.code)
    except Exception as e:
        logging.basicConfig()
        logger.warning(&#34;Script exited with uncaught exception&#34;, exc_info=True)
        # If an exception occurred at import time, the file with the error
        # never made it into sys.modules and so we won&#39;t know to watch it.
        # Just to make sure we&#39;ve covered everything, walk the stack trace
        # from the exception and watch every file.
        for (filename, lineno, name, line) in traceback.extract_tb(sys.exc_info()[2]):
            watch(filename)
        if isinstance(e, SyntaxError):
            # SyntaxErrors are special:  their innermost stack frame is fake
            # so extract_tb won&#39;t see it and we have to get the filename
            # from the exception object.
            watch(e.filename)
    else:
        logging.basicConfig()
        logger.info(&#34;Script exited normally&#34;)
    # restore sys.argv so subsequent executions will include autoreload
    sys.argv = original_argv

    if mode == &#34;module&#34;:
        # runpy did a fake import of the module as __main__, but now it&#39;s
        # no longer in sys.modules.  Figure out where it is and watch it.
        loader = pkgutil.get_loader(module)
        if loader is not None:
            watch(loader.get_filename())  # type: ignore

    wait()</code></pre>
</details>
</dd>
<dt id="h2o_q.autoreload.rerun"><code class="name flex">
<span>def <span class="ident">rerun</span></span>(<span>code: Any, glob: Dict[str, Any], loc: Union[Mapping[str, Any], NoneType] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rerun(code: Any, glob: Dict[str, Any], loc: Optional[Optional[Mapping[str, Any]]] = None) -&gt; None:
    if isinstance(code, str):
        # exec(string) inherits the caller&#39;s future imports; compile
        # the string first to prevent that.
        code = compile(code, &#34;&lt;string&gt;&#34;, &#34;exec&#34;, dont_inherit=True)
    exec(code, glob, loc)</code></pre>
</details>
</dd>
<dt id="h2o_q.autoreload.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>check_time: int = 500) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Begins watching source files for changes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(check_time: int = 500) -&gt; None:
    &#34;&#34;&#34;Begins watching source files for changes.
    &#34;&#34;&#34;
    io_loop = asyncio.get_event_loop()
    if io_loop in _io_loops:
        return
    _io_loops[io_loop] = True
    if len(_io_loops) &gt; 1:
        logger.warning(&#34;h2o_q.autoreload started more than once in the same process&#34;)
    modify_times = {}  # type: Dict[str, float]
    callback = functools.partial(_reload_on_update, modify_times)
    scheduler = _Poll(callback, check_time)
    scheduler.start()</code></pre>
</details>
</dd>
<dt id="h2o_q.autoreload.wait"><code class="name flex">
<span>def <span class="ident">wait</span></span>(<span>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Wait for a watched file to change, then restart the process.</p>
<p>Intended to be used at the end of scripts like unit test runners,
to run the tests again after any source file changes (but see also
the command-line interface in <code><a title="h2o_q.autoreload.main" href="#h2o_q.autoreload.main">main()</a></code>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait() -&gt; None:
    &#34;&#34;&#34;Wait for a watched file to change, then restart the process.

    Intended to be used at the end of scripts like unit test runners,
    to run the tests again after any source file changes (but see also
    the command-line interface in `main`)
    &#34;&#34;&#34;
    io_loop = asyncio.get_event_loop()
    io_loop.call_soon(start)
    io_loop.run_forever()
    io_loop.close()</code></pre>
</details>
</dd>
<dt id="h2o_q.autoreload.watch"><code class="name flex">
<span>def <span class="ident">watch</span></span>(<span>filename: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add a file to the watch list.</p>
<p>All imported modules are watched by default.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def watch(filename: str) -&gt; None:
    &#34;&#34;&#34;Add a file to the watch list.

    All imported modules are watched by default.
    &#34;&#34;&#34;
    _watched_files.add(filename)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<img class='logo' src='https://h2oai.github.io/qd/q.png'/>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="h2o_q" href="index.html">h2o_q</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="h2o_q.autoreload.add_reload_hook" href="#h2o_q.autoreload.add_reload_hook">add_reload_hook</a></code></li>
<li><code><a title="h2o_q.autoreload.main" href="#h2o_q.autoreload.main">main</a></code></li>
<li><code><a title="h2o_q.autoreload.rerun" href="#h2o_q.autoreload.rerun">rerun</a></code></li>
<li><code><a title="h2o_q.autoreload.start" href="#h2o_q.autoreload.start">start</a></code></li>
<li><code><a title="h2o_q.autoreload.wait" href="#h2o_q.autoreload.wait">wait</a></code></li>
<li><code><a title="h2o_q.autoreload.watch" href="#h2o_q.autoreload.watch">watch</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>