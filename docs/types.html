<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>h2o_q.types API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&display=swap" rel="stylesheet">
<link href="https://rsms.me/inter/inter-ui.css" rel="stylesheet">
<style>
body {
font-family: 'Inter', sans-serif;
font-size: 1rem;
color: #000;
-webkit-font-smoothing: antialiased;
line-height: 1.666666;
}
img {
max-width: 100%;
}
h1, h2, h3, h4, h5, h6, b, strong {
font-weight: 600;
}
h1, h2, h3, h4, h5, h6 {
font-size: 1rem;
line-height: 1.5;
}
h1 {
margin: 3rem 0 2rem 0;
border-top: 1px solid #000;
}
a {
text-decoration: none;
color: inherit;
border-color: #000;
border-bottom-style: solid;
border-bottom-width: 1px;
}
code {
font-family: 'Inconsolata', monospace;
}
pre {
border: none;
}
dd {
margin-left: 1em;
}
.http-server-breadcrumbs {
font-size: 100%;
}
#sidebar h1, #index h3, #index a, .toc a {
border: none;
}
.desc h2 {
font-size: 1rem;
font-weight: 600;
}
.name {
font-size:1em;
}
.hljs-comment {
font-style: normal;
}
.logo {
border: 10px solid #ffdf00;
height: 110px;
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>h2o_q.types</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#
# THIS FILE IS GENERATED; DO NOT EDIT
#

from typing import Any, Optional, Union, Dict, List
from .core import Data

Value = Union[str, float, int]
PackedRecord = Union[dict, str]
PackedRecords = Union[List[dict], str]
PackedData = Union[Data, str]


def _dump(**kwargs): return {k: v for k, v in kwargs.items() if v is not None}


class Breadcrumb:
    &#34;&#34;&#34;Create a breadcrumb for a `h2o_q.types.BreadcrumbsCard()`.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: str,
    ):
        self.name = name
        &#34;&#34;&#34;The name of this item. Prefix the name with a &#39;#&#39; to trigger hash-change navigation.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;The label to display.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Breadcrumb.name is required.&#39;)
        if self.label is None:
            raise ValueError(&#39;Breadcrumb.label is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Breadcrumb&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Breadcrumb.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        if __d_label is None:
            raise ValueError(&#39;Breadcrumb.label is required.&#39;)
        name: str = __d_name
        label: str = __d_label
        return Breadcrumb(
            name,
            label,
        )


class Command:
    &#34;&#34;&#34;Create a command.

    Commands are typically displayed as context menu items or toolbar button.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            caption: Optional[str] = None,
            icon: Optional[str] = None,
            items: Optional[List[&#39;Command&#39;]] = None,
            data: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component. If the name is prefixed with a &#39;#&#39;, the command sets the location hash to the name when executed.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;The text displayed for this command.&#34;&#34;&#34;
        self.caption = caption
        &#34;&#34;&#34;The caption for this command (typically a tooltip).&#34;&#34;&#34;
        self.icon = icon
        &#34;&#34;&#34;The icon to be displayed for this command.&#34;&#34;&#34;
        self.items = items
        &#34;&#34;&#34;Sub-commands, if any&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data associated with this command, if any.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Command.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            caption=self.caption,
            icon=self.icon,
            items=None if self.items is None else [__e.dump() for __e in self.items],
            data=self.data,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Command&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Command.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_caption: Any = __d.get(&#39;caption&#39;)
        __d_icon: Any = __d.get(&#39;icon&#39;)
        __d_items: Any = __d.get(&#39;items&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        caption: Optional[str] = __d_caption
        icon: Optional[str] = __d_icon
        items: Optional[List[&#39;Command&#39;]] = None if __d_items is None else [Command.load(__e) for __e in __d_items]
        data: Optional[str] = __d_data
        return Command(
            name,
            label,
            caption,
            icon,
            items,
            data,
        )


class BreadcrumbsCard:
    &#34;&#34;&#34;Create a card containing breadcrumbs.
    Breadcrumbs should be used as a navigational aid in your app or site.
    They indicate the current page’s location within a hierarchy and help
    the user understand where they are in relation to the rest of that hierarchy.
    They also afford one-click access to higher levels of that hierarchy.
    Breadcrumbs are typically placed, in horizontal form, under the masthead
    or navigation of an experience, above the primary content area.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            items: List[Breadcrumb],
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.items = items
        &#34;&#34;&#34;A list of `h2o_q.types.Breadcrumb` instances to display. See `h2o_q.ui.breadcrumb()`&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;BreadcrumbsCard.box is required.&#39;)
        if self.items is None:
            raise ValueError(&#39;BreadcrumbsCard.items is required.&#39;)
        return _dump(
            view=&#39;breadcrumbs&#39;,
            box=self.box,
            items=[__e.dump() for __e in self.items],
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;BreadcrumbsCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;BreadcrumbsCard.box is required.&#39;)
        __d_items: Any = __d.get(&#39;items&#39;)
        if __d_items is None:
            raise ValueError(&#39;BreadcrumbsCard.items is required.&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        items: List[Breadcrumb] = [Breadcrumb.load(__e) for __e in __d_items]
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return BreadcrumbsCard(
            box,
            items,
            commands,
        )


class FlexCard:
    &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.
    Create a card containing other cards laid out using a one-dimensional model with flexible alignemnt and wrapping capabilities.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            item_view: str,
            item_props: PackedRecord,
            data: PackedData,
            direction: Optional[str] = None,
            justify: Optional[str] = None,
            align: Optional[str] = None,
            wrap: Optional[str] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.item_view = item_view
        &#34;&#34;&#34;The child card type.&#34;&#34;&#34;
        self.item_props = item_props
        &#34;&#34;&#34;The child card properties.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.direction = direction
        &#34;&#34;&#34;Layout direction. One of &#39;horizontal&#39;, &#39;vertical&#39;.&#34;&#34;&#34;
        self.justify = justify
        &#34;&#34;&#34;Layout strategy for main axis. One of &#39;start&#39;, &#39;end&#39;, &#39;center&#39;, &#39;between&#39;, &#39;around&#39;.&#34;&#34;&#34;
        self.align = align
        &#34;&#34;&#34;Layout strategy for cross axis. One of &#39;start&#39;, &#39;end&#39;, &#39;center&#39;, &#39;baseline&#39;, &#39;stretch&#39;.&#34;&#34;&#34;
        self.wrap = wrap
        &#34;&#34;&#34;Wrapping strategy. One of &#39;start&#39;, &#39;end&#39;, &#39;center&#39;, &#39;between&#39;, &#39;around&#39;, &#39;stretch&#39;.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;FlexCard.box is required.&#39;)
        if self.item_view is None:
            raise ValueError(&#39;FlexCard.item_view is required.&#39;)
        if self.item_props is None:
            raise ValueError(&#39;FlexCard.item_props is required.&#39;)
        if self.data is None:
            raise ValueError(&#39;FlexCard.data is required.&#39;)
        return _dump(
            view=&#39;flex&#39;,
            box=self.box,
            item_view=self.item_view,
            item_props=self.item_props,
            data=self.data,
            direction=self.direction,
            justify=self.justify,
            align=self.align,
            wrap=self.wrap,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;FlexCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;FlexCard.box is required.&#39;)
        __d_item_view: Any = __d.get(&#39;item_view&#39;)
        if __d_item_view is None:
            raise ValueError(&#39;FlexCard.item_view is required.&#39;)
        __d_item_props: Any = __d.get(&#39;item_props&#39;)
        if __d_item_props is None:
            raise ValueError(&#39;FlexCard.item_props is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        if __d_data is None:
            raise ValueError(&#39;FlexCard.data is required.&#39;)
        __d_direction: Any = __d.get(&#39;direction&#39;)
        __d_justify: Any = __d.get(&#39;justify&#39;)
        __d_align: Any = __d.get(&#39;align&#39;)
        __d_wrap: Any = __d.get(&#39;wrap&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        item_view: str = __d_item_view
        item_props: PackedRecord = __d_item_props
        data: PackedData = __d_data
        direction: Optional[str] = __d_direction
        justify: Optional[str] = __d_justify
        align: Optional[str] = __d_align
        wrap: Optional[str] = __d_wrap
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return FlexCard(
            box,
            item_view,
            item_props,
            data,
            direction,
            justify,
            align,
            wrap,
            commands,
        )


class Text:
    &#34;&#34;&#34;Create text content.
    &#34;&#34;&#34;
    def __init__(
            self,
            content: str,
            size: Optional[str] = None,
            tooltip: Optional[str] = None,
    ):
        self.content = content
        &#34;&#34;&#34;The text content.&#34;&#34;&#34;
        self.size = size
        &#34;&#34;&#34;The font size of the text content. One of &#39;xl&#39;, &#39;l&#39;, &#39;m&#39;, &#39;s&#39;, &#39;xs&#39;.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;Tooltip message.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.content is None:
            raise ValueError(&#39;Text.content is required.&#39;)
        return _dump(
            content=self.content,
            size=self.size,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Text&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_content: Any = __d.get(&#39;content&#39;)
        if __d_content is None:
            raise ValueError(&#39;Text.content is required.&#39;)
        __d_size: Any = __d.get(&#39;size&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        content: str = __d_content
        size: Optional[str] = __d_size
        tooltip: Optional[str] = __d_tooltip
        return Text(
            content,
            size,
            tooltip,
        )


class TextXl:
    &#34;&#34;&#34;Create extra-large sized text content.
    &#34;&#34;&#34;
    def __init__(
            self,
            content: str,
            tooltip: Optional[str] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.content = content
        &#34;&#34;&#34;The text content.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;Tooltip message.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.content is None:
            raise ValueError(&#39;TextXl.content is required.&#39;)
        return _dump(
            content=self.content,
            tooltip=self.tooltip,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TextXl&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_content: Any = __d.get(&#39;content&#39;)
        if __d_content is None:
            raise ValueError(&#39;TextXl.content is required.&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        content: str = __d_content
        tooltip: Optional[str] = __d_tooltip
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return TextXl(
            content,
            tooltip,
            commands,
        )


class TextL:
    &#34;&#34;&#34;Create large sized text content.
    &#34;&#34;&#34;
    def __init__(
            self,
            content: str,
            tooltip: Optional[str] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.content = content
        &#34;&#34;&#34;The text content.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;Tooltip message.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.content is None:
            raise ValueError(&#39;TextL.content is required.&#39;)
        return _dump(
            content=self.content,
            tooltip=self.tooltip,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TextL&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_content: Any = __d.get(&#39;content&#39;)
        if __d_content is None:
            raise ValueError(&#39;TextL.content is required.&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        content: str = __d_content
        tooltip: Optional[str] = __d_tooltip
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return TextL(
            content,
            tooltip,
            commands,
        )


class TextM:
    &#34;&#34;&#34;Create medium sized text content.
    &#34;&#34;&#34;
    def __init__(
            self,
            content: str,
            tooltip: Optional[str] = None,
    ):
        self.content = content
        &#34;&#34;&#34;The text content.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;Tooltip message.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.content is None:
            raise ValueError(&#39;TextM.content is required.&#39;)
        return _dump(
            content=self.content,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TextM&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_content: Any = __d.get(&#39;content&#39;)
        if __d_content is None:
            raise ValueError(&#39;TextM.content is required.&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        content: str = __d_content
        tooltip: Optional[str] = __d_tooltip
        return TextM(
            content,
            tooltip,
        )


class TextS:
    &#34;&#34;&#34;Create small sized text content.
    &#34;&#34;&#34;
    def __init__(
            self,
            content: str,
            tooltip: Optional[str] = None,
    ):
        self.content = content
        &#34;&#34;&#34;The text content.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;Tooltip message.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.content is None:
            raise ValueError(&#39;TextS.content is required.&#39;)
        return _dump(
            content=self.content,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TextS&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_content: Any = __d.get(&#39;content&#39;)
        if __d_content is None:
            raise ValueError(&#39;TextS.content is required.&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        content: str = __d_content
        tooltip: Optional[str] = __d_tooltip
        return TextS(
            content,
            tooltip,
        )


class TextXs:
    &#34;&#34;&#34;Create extra-small sized text content.
    &#34;&#34;&#34;
    def __init__(
            self,
            content: str,
            tooltip: Optional[str] = None,
    ):
        self.content = content
        &#34;&#34;&#34;The text content.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;Tooltip message.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.content is None:
            raise ValueError(&#39;TextXs.content is required.&#39;)
        return _dump(
            content=self.content,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TextXs&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_content: Any = __d.get(&#39;content&#39;)
        if __d_content is None:
            raise ValueError(&#39;TextXs.content is required.&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        content: str = __d_content
        tooltip: Optional[str] = __d_tooltip
        return TextXs(
            content,
            tooltip,
        )


class Label:
    &#34;&#34;&#34;Create a label.

    Labels give a name or title to a component or group of components.
    Labels should be in close proximity to the component or group they are paired with.
    Some components, such as textboxes, dropdowns, or toggles, already have labels
    incorporated, but other components may optionally add a Label if it helps inform
    the user of the component’s purpose.
    &#34;&#34;&#34;
    def __init__(
            self,
            label: str,
            required: Optional[bool] = None,
            disabled: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.label = label
        &#34;&#34;&#34;The text displayed on the label.&#34;&#34;&#34;
        self.required = required
        &#34;&#34;&#34;True if the field is required.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if the label should be disabled.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.label is None:
            raise ValueError(&#39;Label.label is required.&#39;)
        return _dump(
            label=self.label,
            required=self.required,
            disabled=self.disabled,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Label&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_label: Any = __d.get(&#39;label&#39;)
        if __d_label is None:
            raise ValueError(&#39;Label.label is required.&#39;)
        __d_required: Any = __d.get(&#39;required&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        label: str = __d_label
        required: Optional[bool] = __d_required
        disabled: Optional[bool] = __d_disabled
        tooltip: Optional[str] = __d_tooltip
        return Label(
            label,
            required,
            disabled,
            tooltip,
        )


class Separator:
    &#34;&#34;&#34;Create a separator.

    A separator visually separates content into groups.
    &#34;&#34;&#34;
    def __init__(
            self,
            label: Optional[str] = None,
    ):
        self.label = label
        &#34;&#34;&#34;The text displayed on the separator.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        return _dump(
            label=self.label,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Separator&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_label: Any = __d.get(&#39;label&#39;)
        label: Optional[str] = __d_label
        return Separator(
            label,
        )


class Progress:
    &#34;&#34;&#34;Create a progress bar.

    Progress bars are used to show the completion status of an operation lasting more than 2 seconds.
    If the state of progress cannot be determined, do not set a value.
    Progress bars feature a bar showing total units to completion, and total units finished.
    The label appears above the bar, and the caption appears below.
    The label should tell someone exactly what the operation is doing.

    Examples of formatting include:
    [Object] is being [operation name], or
    [Object] is being [operation name] to [destination name] or
    [Object] is being [operation name] from [source name] to [destination name]

    Status text is generally in units elapsed and total units.
    Real-world examples include copying files to a storage location, saving edits to a file, and more.
    Use units that are informative and relevant to give the best idea to users of how long the operation will take to complete.
    Avoid time units as they are rarely accurate enough to be trustworthy.
    Also, combine steps of a complex operation into one total bar to avoid “rewinding” the bar.
    Instead change the label to reflect the change if necessary. Bars moving backwards reduce confidence in the service.
    &#34;&#34;&#34;
    def __init__(
            self,
            label: str,
            caption: Optional[str] = None,
            value: Optional[float] = None,
            tooltip: Optional[str] = None,
    ):
        self.label = label
        &#34;&#34;&#34;The text displayed above the bar.&#34;&#34;&#34;
        self.caption = caption
        &#34;&#34;&#34;The text displayed below the bar.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The progress, between 0.0 and 1.0, or -1 (default) if indeterminate.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.label is None:
            raise ValueError(&#39;Progress.label is required.&#39;)
        return _dump(
            label=self.label,
            caption=self.caption,
            value=self.value,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Progress&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_label: Any = __d.get(&#39;label&#39;)
        if __d_label is None:
            raise ValueError(&#39;Progress.label is required.&#39;)
        __d_caption: Any = __d.get(&#39;caption&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        label: str = __d_label
        caption: Optional[str] = __d_caption
        value: Optional[float] = __d_value
        tooltip: Optional[str] = __d_tooltip
        return Progress(
            label,
            caption,
            value,
            tooltip,
        )


class MessageBar:
    &#34;&#34;&#34;Create a message bar.

    A message bar is an area at the top of a primary view that displays relevant status information.
    You can use a message bar to tell the user about a situation that does not require their immediate attention and
    therefore does not need to block other activities.
    &#34;&#34;&#34;
    def __init__(
            self,
            type: Optional[str] = None,
            text: Optional[str] = None,
    ):
        self.type = type
        &#34;&#34;&#34;The icon and color of the message bar. One of &#39;info&#39;, &#39;error&#39;, &#39;warning&#39;, &#39;success&#39;, &#39;danger&#39;, &#39;blocked&#39;.&#34;&#34;&#34;
        self.text = text
        &#34;&#34;&#34;The text displayed on the message bar.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        return _dump(
            type=self.type,
            text=self.text,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;MessageBar&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_type: Any = __d.get(&#39;type&#39;)
        __d_text: Any = __d.get(&#39;text&#39;)
        type: Optional[str] = __d_type
        text: Optional[str] = __d_text
        return MessageBar(
            type,
            text,
        )


class Textbox:
    &#34;&#34;&#34;Create a text box.

    The text box component enables a user to type text into an app.
    It&#39;s typically used to capture a single line of text, but can be configured to capture multiple lines of text.
    The text displays on the screen in a simple, uniform format.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            placeholder: Optional[str] = None,
            value: Optional[str] = None,
            mask: Optional[str] = None,
            icon: Optional[str] = None,
            prefix: Optional[str] = None,
            suffix: Optional[str] = None,
            error: Optional[str] = None,
            required: Optional[bool] = None,
            disabled: Optional[bool] = None,
            readonly: Optional[bool] = None,
            multiline: Optional[bool] = None,
            password: Optional[bool] = None,
            trigger: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;The text displayed above the field.&#34;&#34;&#34;
        self.placeholder = placeholder
        &#34;&#34;&#34;A string that provides a brief hint to the user as to what kind of information is expected in the field. It should be a word or short phrase that demonstrates the expected type of data, rather than an explanatory message.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;Text to be displayed inside the text box.&#34;&#34;&#34;
        self.mask = mask
        &#34;&#34;&#34;The masking string that defines the mask&#39;s behavior. A backslash will escape any character. Special format characters are: &#39;9&#39;: [0-9] &#39;a&#39;: [a-zA-Z] &#39;*&#39;: [a-zA-Z0-9].&#34;&#34;&#34;
        self.icon = icon
        &#34;&#34;&#34;Icon displayed in the far right end of the text field.&#34;&#34;&#34;
        self.prefix = prefix
        &#34;&#34;&#34;Text to be displayed before the text box contents.&#34;&#34;&#34;
        self.suffix = suffix
        &#34;&#34;&#34;Text to be displayed after the text box contents.&#34;&#34;&#34;
        self.error = error
        &#34;&#34;&#34;Text to be displayed as an error below the text box.&#34;&#34;&#34;
        self.required = required
        &#34;&#34;&#34;True if the text box is a required field.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if the text box is disabled.&#34;&#34;&#34;
        self.readonly = readonly
        &#34;&#34;&#34;True if the text box is a read-only field.&#34;&#34;&#34;
        self.multiline = multiline
        &#34;&#34;&#34;True if the text box should allow multi-line text entry.&#34;&#34;&#34;
        self.password = password
        &#34;&#34;&#34;True if the text box should hide text content.&#34;&#34;&#34;
        self.trigger = trigger
        &#34;&#34;&#34;True if the form should be submitted when the text value changes.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Textbox.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            placeholder=self.placeholder,
            value=self.value,
            mask=self.mask,
            icon=self.icon,
            prefix=self.prefix,
            suffix=self.suffix,
            error=self.error,
            required=self.required,
            disabled=self.disabled,
            readonly=self.readonly,
            multiline=self.multiline,
            password=self.password,
            trigger=self.trigger,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Textbox&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Textbox.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_placeholder: Any = __d.get(&#39;placeholder&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_mask: Any = __d.get(&#39;mask&#39;)
        __d_icon: Any = __d.get(&#39;icon&#39;)
        __d_prefix: Any = __d.get(&#39;prefix&#39;)
        __d_suffix: Any = __d.get(&#39;suffix&#39;)
        __d_error: Any = __d.get(&#39;error&#39;)
        __d_required: Any = __d.get(&#39;required&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_readonly: Any = __d.get(&#39;readonly&#39;)
        __d_multiline: Any = __d.get(&#39;multiline&#39;)
        __d_password: Any = __d.get(&#39;password&#39;)
        __d_trigger: Any = __d.get(&#39;trigger&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        placeholder: Optional[str] = __d_placeholder
        value: Optional[str] = __d_value
        mask: Optional[str] = __d_mask
        icon: Optional[str] = __d_icon
        prefix: Optional[str] = __d_prefix
        suffix: Optional[str] = __d_suffix
        error: Optional[str] = __d_error
        required: Optional[bool] = __d_required
        disabled: Optional[bool] = __d_disabled
        readonly: Optional[bool] = __d_readonly
        multiline: Optional[bool] = __d_multiline
        password: Optional[bool] = __d_password
        trigger: Optional[bool] = __d_trigger
        tooltip: Optional[str] = __d_tooltip
        return Textbox(
            name,
            label,
            placeholder,
            value,
            mask,
            icon,
            prefix,
            suffix,
            error,
            required,
            disabled,
            readonly,
            multiline,
            password,
            trigger,
            tooltip,
        )


class Checkbox:
    &#34;&#34;&#34;Create a checkbox.

    A checkbox allows users to switch between two mutually exclusive options (checked or unchecked, on or off) through
    a single click or tap. It can also be used to indicate a subordinate setting or preference when paired with another
    component.

    A checkbox is used to select or deselect action items. It can be used for a single item or for a list of multiple
    items that a user can choose from. The component has two selection states: unselected and selected.

    For a binary choice, the main difference between a checkbox and a toggle switch is that the checkbox is for status
    and the toggle switch is for action.

    Use multiple checkboxes for multi-select scenarios in which a user chooses one or more items from a group of
    choices that are not mutually exclusive.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            value: Optional[bool] = None,
            indeterminate: Optional[bool] = None,
            disabled: Optional[bool] = None,
            trigger: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the checkbox.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;True if selected, False if unselected.&#34;&#34;&#34;
        self.indeterminate = indeterminate
        &#34;&#34;&#34;True if the selection is indeterminate (neither selected nor unselected).&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if the checkbox is disabled.&#34;&#34;&#34;
        self.trigger = trigger
        &#34;&#34;&#34;True if the form should be submitted when the checkbox value changes.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Checkbox.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            value=self.value,
            indeterminate=self.indeterminate,
            disabled=self.disabled,
            trigger=self.trigger,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Checkbox&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Checkbox.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_indeterminate: Any = __d.get(&#39;indeterminate&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_trigger: Any = __d.get(&#39;trigger&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        value: Optional[bool] = __d_value
        indeterminate: Optional[bool] = __d_indeterminate
        disabled: Optional[bool] = __d_disabled
        trigger: Optional[bool] = __d_trigger
        tooltip: Optional[str] = __d_tooltip
        return Checkbox(
            name,
            label,
            value,
            indeterminate,
            disabled,
            trigger,
            tooltip,
        )


class Toggle:
    &#34;&#34;&#34;Create a toggle.
    Toggles represent a physical switch that allows users to turn things on or off.
    Use toggles to present users with two mutually exclusive options (like on/off), where choosing an option results
    in an immediate action.

    Use a toggle for binary operations that take effect right after the user flips the Toggle.
    For example, use a Toggle to turn services or hardware components on or off.
    In other words, if a physical switch would work for the action, a Toggle is probably the best component to use.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            value: Optional[bool] = None,
            disabled: Optional[bool] = None,
            trigger: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the component.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;True if selected, False if unselected.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if the checkbox is disabled.&#34;&#34;&#34;
        self.trigger = trigger
        &#34;&#34;&#34;True if the form should be submitted when the toggle value changes.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Toggle.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            value=self.value,
            disabled=self.disabled,
            trigger=self.trigger,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Toggle&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Toggle.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_trigger: Any = __d.get(&#39;trigger&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        value: Optional[bool] = __d_value
        disabled: Optional[bool] = __d_disabled
        trigger: Optional[bool] = __d_trigger
        tooltip: Optional[str] = __d_tooltip
        return Toggle(
            name,
            label,
            value,
            disabled,
            trigger,
            tooltip,
        )


class Choice:
    &#34;&#34;&#34;Create a choice for a checklist, choice group or dropdown.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            disabled: Optional[bool] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the component.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if the checkbox is disabled.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Choice.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            disabled=self.disabled,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Choice&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Choice.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        disabled: Optional[bool] = __d_disabled
        return Choice(
            name,
            label,
            disabled,
        )


class ChoiceGroup:
    &#34;&#34;&#34;Create a choice group.
    The choice group component, also known as radio buttons, let users select one option from two or more choices.
    Each option is represented by one choice group button; a user can select only one choice group in a button group.

    Choice groups emphasize all options equally, and that may draw more attention to the options than necessary.
    Consider using other components, unless the options deserve extra attention from the user.
    For example, if the default option is recommended for most users in most situations, use a dropdown instead.

    If there are only two mutually exclusive options, combine them into a single Checkbox or Toggle switch.
    For example, use a checkbox for &#34;I agree&#34; instead of choice group buttons for &#34;I agree&#34; and &#34;I don&#39;t agree.&#34;
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            value: Optional[str] = None,
            choices: Optional[List[Choice]] = None,
            required: Optional[bool] = None,
            trigger: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the component.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The name of the selected choice.&#34;&#34;&#34;
        self.choices = choices
        &#34;&#34;&#34;The choices to be presented.&#34;&#34;&#34;
        self.required = required
        &#34;&#34;&#34;True if this field is required.&#34;&#34;&#34;
        self.trigger = trigger
        &#34;&#34;&#34;True if the form should be submitted when the selection changes.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;ChoiceGroup.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            value=self.value,
            choices=None if self.choices is None else [__e.dump() for __e in self.choices],
            required=self.required,
            trigger=self.trigger,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;ChoiceGroup&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;ChoiceGroup.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_choices: Any = __d.get(&#39;choices&#39;)
        __d_required: Any = __d.get(&#39;required&#39;)
        __d_trigger: Any = __d.get(&#39;trigger&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        value: Optional[str] = __d_value
        choices: Optional[List[Choice]] = None if __d_choices is None else [Choice.load(__e) for __e in __d_choices]
        required: Optional[bool] = __d_required
        trigger: Optional[bool] = __d_trigger
        tooltip: Optional[str] = __d_tooltip
        return ChoiceGroup(
            name,
            label,
            value,
            choices,
            required,
            trigger,
            tooltip,
        )


class Checklist:
    &#34;&#34;&#34;Create a set of checkboxes.
    Use this for multi-select scenarios in which a user chooses one or more items from a group of
    choices that are not mutually exclusive.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            values: Optional[List[str]] = None,
            choices: Optional[List[Choice]] = None,
            trigger: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed above the component.&#34;&#34;&#34;
        self.values = values
        &#34;&#34;&#34;The names of the selected choices.&#34;&#34;&#34;
        self.choices = choices
        &#34;&#34;&#34;The choices to be presented.&#34;&#34;&#34;
        self.trigger = trigger
        &#34;&#34;&#34;True if the form should be submitted when the checklist value changes.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Checklist.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            values=self.values,
            choices=None if self.choices is None else [__e.dump() for __e in self.choices],
            trigger=self.trigger,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Checklist&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Checklist.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_values: Any = __d.get(&#39;values&#39;)
        __d_choices: Any = __d.get(&#39;choices&#39;)
        __d_trigger: Any = __d.get(&#39;trigger&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        values: Optional[List[str]] = __d_values
        choices: Optional[List[Choice]] = None if __d_choices is None else [Choice.load(__e) for __e in __d_choices]
        trigger: Optional[bool] = __d_trigger
        tooltip: Optional[str] = __d_tooltip
        return Checklist(
            name,
            label,
            values,
            choices,
            trigger,
            tooltip,
        )


class Dropdown:
    &#34;&#34;&#34;Create a dropdown.

    A dropdown is a list in which the selected item is always visible, and the others are visible on demand by clicking
    a drop-down button. They are used to simplify the design and make a choice within the UI. When closed, only the
    selected item is visible. When users click the drop-down button, all the options become visible.

    To change the value, users open the list and click another value or use the arrow keys (up and down) to
    select a new value.

    Note: Use either the &#39;value&#39; parameter or the &#39;values&#39; parameter. Setting the &#39;values&#39; parameter renders a
    multi-select dropdown.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            placeholder: Optional[str] = None,
            value: Optional[str] = None,
            values: Optional[List[str]] = None,
            choices: Optional[List[Choice]] = None,
            required: Optional[bool] = None,
            disabled: Optional[bool] = None,
            trigger: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the component.&#34;&#34;&#34;
        self.placeholder = placeholder
        &#34;&#34;&#34;A string that provides a brief hint to the user as to what kind of information is expected in the field.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The name of the selected choice.&#34;&#34;&#34;
        self.values = values
        &#34;&#34;&#34;The names of the selected choices. If this parameter is set, multiple selections will be allowed.&#34;&#34;&#34;
        self.choices = choices
        &#34;&#34;&#34;The choices to be presented.&#34;&#34;&#34;
        self.required = required
        &#34;&#34;&#34;True if this is a required field.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if this field is disabled.&#34;&#34;&#34;
        self.trigger = trigger
        &#34;&#34;&#34;True if the form should be submitted when the dropdown value changes.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Dropdown.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            placeholder=self.placeholder,
            value=self.value,
            values=self.values,
            choices=None if self.choices is None else [__e.dump() for __e in self.choices],
            required=self.required,
            disabled=self.disabled,
            trigger=self.trigger,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Dropdown&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Dropdown.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_placeholder: Any = __d.get(&#39;placeholder&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_values: Any = __d.get(&#39;values&#39;)
        __d_choices: Any = __d.get(&#39;choices&#39;)
        __d_required: Any = __d.get(&#39;required&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_trigger: Any = __d.get(&#39;trigger&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        placeholder: Optional[str] = __d_placeholder
        value: Optional[str] = __d_value
        values: Optional[List[str]] = __d_values
        choices: Optional[List[Choice]] = None if __d_choices is None else [Choice.load(__e) for __e in __d_choices]
        required: Optional[bool] = __d_required
        disabled: Optional[bool] = __d_disabled
        trigger: Optional[bool] = __d_trigger
        tooltip: Optional[str] = __d_tooltip
        return Dropdown(
            name,
            label,
            placeholder,
            value,
            values,
            choices,
            required,
            disabled,
            trigger,
            tooltip,
        )


class Combobox:
    &#34;&#34;&#34;Create a combobox.

    A combobox is a list in which the selected item is always visible, and the others are visible on demand by
    clicking a drop-down button or by typing in the input.
    They are used to simplify the design and make a choice within the UI.

    When closed, only the selected item is visible.
    When users click the drop-down button, all the options become visible.
    To change the value, users open the list and click another value or use the arrow keys (up and down)
    to select a new value.
    When collapsed the user can select a new value by typing.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            placeholder: Optional[str] = None,
            value: Optional[str] = None,
            choices: Optional[List[str]] = None,
            error: Optional[str] = None,
            disabled: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the component.&#34;&#34;&#34;
        self.placeholder = placeholder
        &#34;&#34;&#34;A string that provides a brief hint to the user as to what kind of information is expected in the field.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The name of the selected choice.&#34;&#34;&#34;
        self.choices = choices
        &#34;&#34;&#34;The choices to be presented.&#34;&#34;&#34;
        self.error = error
        &#34;&#34;&#34;Text to be displayed as an error below the text box.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if this field is disabled.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Combobox.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            placeholder=self.placeholder,
            value=self.value,
            choices=self.choices,
            error=self.error,
            disabled=self.disabled,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Combobox&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Combobox.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_placeholder: Any = __d.get(&#39;placeholder&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_choices: Any = __d.get(&#39;choices&#39;)
        __d_error: Any = __d.get(&#39;error&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        placeholder: Optional[str] = __d_placeholder
        value: Optional[str] = __d_value
        choices: Optional[List[str]] = __d_choices
        error: Optional[str] = __d_error
        disabled: Optional[bool] = __d_disabled
        tooltip: Optional[str] = __d_tooltip
        return Combobox(
            name,
            label,
            placeholder,
            value,
            choices,
            error,
            disabled,
            tooltip,
        )


class Slider:
    &#34;&#34;&#34;Create a slider.

    A slider is an element used to set a value. It provides a visual indication of adjustable content, as well as the
    current setting in the total range of content. It is displayed as a horizontal track with options on either side.
    A knob or lever is dragged to one end or the other to make the choice, indicating the current value.
    Marks on the slider bar can show values and users can choose where they want to drag the knob or lever to
    set the value.

    A slider is a good choice when you know that users think of the value as a relative quantity, not a numeric value.
    For example, users think about setting their audio volume to low or medium — not about setting the
    value to two or five.

    The default value of the slider will be zero or be constrained to the min and max values. The min will be returned
    if the value is set under the min and the max will be returned if set higher than the max value.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            min: Optional[float] = None,
            max: Optional[float] = None,
            step: Optional[float] = None,
            value: Optional[float] = None,
            disabled: Optional[bool] = None,
            trigger: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the component.&#34;&#34;&#34;
        self.min = min
        &#34;&#34;&#34;The minimum value of the slider.&#34;&#34;&#34;
        self.max = max
        &#34;&#34;&#34;The maximum value of the slider.&#34;&#34;&#34;
        self.step = step
        &#34;&#34;&#34;The difference between two adjacent values of the slider.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The current value of the slider.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if this field is disabled.&#34;&#34;&#34;
        self.trigger = trigger
        &#34;&#34;&#34;True if the form should be submitted when the slider value changes.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Slider.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            min=self.min,
            max=self.max,
            step=self.step,
            value=self.value,
            disabled=self.disabled,
            trigger=self.trigger,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Slider&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Slider.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_min: Any = __d.get(&#39;min&#39;)
        __d_max: Any = __d.get(&#39;max&#39;)
        __d_step: Any = __d.get(&#39;step&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_trigger: Any = __d.get(&#39;trigger&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        min: Optional[float] = __d_min
        max: Optional[float] = __d_max
        step: Optional[float] = __d_step
        value: Optional[float] = __d_value
        disabled: Optional[bool] = __d_disabled
        trigger: Optional[bool] = __d_trigger
        tooltip: Optional[str] = __d_tooltip
        return Slider(
            name,
            label,
            min,
            max,
            step,
            value,
            disabled,
            trigger,
            tooltip,
        )


class Spinbox:
    &#34;&#34;&#34;Create a spinbox.

    A spinbox allows the user to incrementally adjust a value in small steps.
    It is mainly used for numeric values, but other values are supported too.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            min: Optional[float] = None,
            max: Optional[float] = None,
            step: Optional[float] = None,
            value: Optional[float] = None,
            disabled: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the component.&#34;&#34;&#34;
        self.min = min
        &#34;&#34;&#34;The minimum value of the spinbox.&#34;&#34;&#34;
        self.max = max
        &#34;&#34;&#34;The maximum value of the spinbox.&#34;&#34;&#34;
        self.step = step
        &#34;&#34;&#34;The difference between two adjacent values of the spinbox.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The current value of the spinbox.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if this field is disabled.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Spinbox.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            min=self.min,
            max=self.max,
            step=self.step,
            value=self.value,
            disabled=self.disabled,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Spinbox&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Spinbox.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_min: Any = __d.get(&#39;min&#39;)
        __d_max: Any = __d.get(&#39;max&#39;)
        __d_step: Any = __d.get(&#39;step&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        min: Optional[float] = __d_min
        max: Optional[float] = __d_max
        step: Optional[float] = __d_step
        value: Optional[float] = __d_value
        disabled: Optional[bool] = __d_disabled
        tooltip: Optional[str] = __d_tooltip
        return Spinbox(
            name,
            label,
            min,
            max,
            step,
            value,
            disabled,
            tooltip,
        )


class DatePicker:
    &#34;&#34;&#34;Create a date picker.

    A date picker allows a user to pick a date value.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            placeholder: Optional[str] = None,
            value: Optional[str] = None,
            disabled: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the component.&#34;&#34;&#34;
        self.placeholder = placeholder
        &#34;&#34;&#34;A string that provides a brief hint to the user as to what kind of information is expected in the field.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The date value in YYYY-MM-DD format.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if this field is disabled.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;DatePicker.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            placeholder=self.placeholder,
            value=self.value,
            disabled=self.disabled,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;DatePicker&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;DatePicker.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_placeholder: Any = __d.get(&#39;placeholder&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        placeholder: Optional[str] = __d_placeholder
        value: Optional[str] = __d_value
        disabled: Optional[bool] = __d_disabled
        tooltip: Optional[str] = __d_tooltip
        return DatePicker(
            name,
            label,
            placeholder,
            value,
            disabled,
            tooltip,
        )


class ColorPicker:
    &#34;&#34;&#34;Create a color picker.

    A date picker allows a user to pick a color value.
    If the &#39;choices&#39; parameter is set, a swatch picker is displayed instead of the standard color picker.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            value: Optional[str] = None,
            choices: Optional[List[str]] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the component.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The selected color (CSS-compatible string)&#34;&#34;&#34;
        self.choices = choices
        &#34;&#34;&#34;A list of colors (CSS-compatible strings) to limit color choices to.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;ColorPicker.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            value=self.value,
            choices=self.choices,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;ColorPicker&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;ColorPicker.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_choices: Any = __d.get(&#39;choices&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        value: Optional[str] = __d_value
        choices: Optional[List[str]] = __d_choices
        tooltip: Optional[str] = __d_tooltip
        return ColorPicker(
            name,
            label,
            value,
            choices,
            tooltip,
        )


class Button:
    &#34;&#34;&#34;Create a button.

    Buttons are best used to enable a user to commit a change or complete steps in a task.
    They are typically found inside forms, dialogs, panels or pages.
    An example of their usage is confirming the deletion of a file in a confirmation dialog.

    When considering their place in a layout, contemplate the order in which a user will flow through the UI.
    As an example, in a form, the individual will need to read and interact with the form fields before submitting
    the form. Therefore, as a general rule, the button should be placed at the bottom of the UI container
    which holds the related UI elements.

    Buttons may be placed within a &#34;buttons&#34; component which will lay out the buttons horizontally, or used
    individually and they will be stacked vertically.

    While buttons can technically be used to navigate a user to another part of the experience, this is not
    recommended unless that navigation is part of an action or their flow.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            caption: Optional[str] = None,
            value: Optional[str] = None,
            primary: Optional[bool] = None,
            disabled: Optional[bool] = None,
            link: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component. If the name is prefixed with a &#39;#&#39;, the button sets the location hash to the name when clicked.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;The text displayed on the button.&#34;&#34;&#34;
        self.caption = caption
        &#34;&#34;&#34;The caption displayed below the label. Setting a caption renders a compound button.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;A value for this button. If a value is set, it is used for the button&#39;s submitted instead of a boolean True.&#34;&#34;&#34;
        self.primary = primary
        &#34;&#34;&#34;True if the button should be rendered as the primary button in the set.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if the button should be disabled.&#34;&#34;&#34;
        self.link = link
        &#34;&#34;&#34;True if the button should be rendered as link text and not a standard button.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Button.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            caption=self.caption,
            value=self.value,
            primary=self.primary,
            disabled=self.disabled,
            link=self.link,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Button&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Button.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_caption: Any = __d.get(&#39;caption&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_primary: Any = __d.get(&#39;primary&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_link: Any = __d.get(&#39;link&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        caption: Optional[str] = __d_caption
        value: Optional[str] = __d_value
        primary: Optional[bool] = __d_primary
        disabled: Optional[bool] = __d_disabled
        link: Optional[bool] = __d_link
        tooltip: Optional[str] = __d_tooltip
        return Button(
            name,
            label,
            caption,
            value,
            primary,
            disabled,
            link,
            tooltip,
        )


class Buttons:
    &#34;&#34;&#34;Create a set of buttons to be layed out horizontally.
    &#34;&#34;&#34;
    def __init__(
            self,
            items: List[&#39;Component&#39;],
    ):
        self.items = items
        &#34;&#34;&#34;The button in this set.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.items is None:
            raise ValueError(&#39;Buttons.items is required.&#39;)
        return _dump(
            items=[__e.dump() for __e in self.items],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Buttons&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_items: Any = __d.get(&#39;items&#39;)
        if __d_items is None:
            raise ValueError(&#39;Buttons.items is required.&#39;)
        items: List[&#39;Component&#39;] = [Component.load(__e) for __e in __d_items]
        return Buttons(
            items,
        )


class FileUpload:
    &#34;&#34;&#34;Create a file upload component.
    A file upload component allows a user to browse, select and upload one or more files.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            multiple: Optional[bool] = None,
            file_extensions: Optional[List[str]] = None,
            max_file_size: Optional[float] = None,
            max_size: Optional[float] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the component.&#34;&#34;&#34;
        self.multiple = multiple
        &#34;&#34;&#34;True if the component should allow multiple files to be uploaded.&#34;&#34;&#34;
        self.file_extensions = file_extensions
        &#34;&#34;&#34;List of allowed file extensions, e.g. `pdf`, `docx`, etc.&#34;&#34;&#34;
        self.max_file_size = max_file_size
        &#34;&#34;&#34;Maximum allowed size (Mb) per file. Defaults to no limit.&#34;&#34;&#34;
        self.max_size = max_size
        &#34;&#34;&#34;Maximum allowed size (Mb) for all files combined. Defaults to no limit.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;FileUpload.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            multiple=self.multiple,
            file_extensions=self.file_extensions,
            max_file_size=self.max_file_size,
            max_size=self.max_size,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;FileUpload&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;FileUpload.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_multiple: Any = __d.get(&#39;multiple&#39;)
        __d_file_extensions: Any = __d.get(&#39;file_extensions&#39;)
        __d_max_file_size: Any = __d.get(&#39;max_file_size&#39;)
        __d_max_size: Any = __d.get(&#39;max_size&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        multiple: Optional[bool] = __d_multiple
        file_extensions: Optional[List[str]] = __d_file_extensions
        max_file_size: Optional[float] = __d_max_file_size
        max_size: Optional[float] = __d_max_size
        tooltip: Optional[str] = __d_tooltip
        return FileUpload(
            name,
            label,
            multiple,
            file_extensions,
            max_file_size,
            max_size,
            tooltip,
        )


class ProgressTableCellType:
    &#34;&#34;&#34;Create a cell type that renders a column&#39;s cells as progress bars instead of plain text.
    If set on a column, the cell value must be between 0.0 and 1.0.
    &#34;&#34;&#34;
    def __init__(
            self,
            color: Optional[str] = None,
    ):
        self.color = color
        &#34;&#34;&#34;Color of the progress arc.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        return _dump(
            color=self.color,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;ProgressTableCellType&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_color: Any = __d.get(&#39;color&#39;)
        color: Optional[str] = __d_color
        return ProgressTableCellType(
            color,
        )


class IconTableCellType:
    &#34;&#34;&#34;Create a cell type that renders a column&#39;s cells as icons instead of plain text.
    If set on a column, the cell value is interpreted as the name of the icon to be displayed.
    &#34;&#34;&#34;
    def __init__(
            self,
            color: Optional[str] = None,
    ):
        self.color = color
        &#34;&#34;&#34;Icon color.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        return _dump(
            color=self.color,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;IconTableCellType&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_color: Any = __d.get(&#39;color&#39;)
        color: Optional[str] = __d_color
        return IconTableCellType(
            color,
        )


class TableCellType:
    &#34;&#34;&#34;Defines cell content to be rendered instead of a simple text.
    &#34;&#34;&#34;
    def __init__(
            self,
            progress: Optional[ProgressTableCellType] = None,
            icon: Optional[IconTableCellType] = None,
    ):
        self.progress = progress
        &#34;&#34;&#34;No documentation available.&#34;&#34;&#34;
        self.icon = icon
        &#34;&#34;&#34;No documentation available.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        return _dump(
            progress=None if self.progress is None else self.progress.dump(),
            icon=None if self.icon is None else self.icon.dump(),
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TableCellType&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_progress: Any = __d.get(&#39;progress&#39;)
        __d_icon: Any = __d.get(&#39;icon&#39;)
        progress: Optional[ProgressTableCellType] = None if __d_progress is None else ProgressTableCellType.load(__d_progress)
        icon: Optional[IconTableCellType] = None if __d_icon is None else IconTableCellType.load(__d_icon)
        return TableCellType(
            progress,
            icon,
        )


class TableColumn:
    &#34;&#34;&#34;Create a table column.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: str,
            min_width: Optional[str] = None,
            max_width: Optional[str] = None,
            sortable: Optional[bool] = None,
            searchable: Optional[bool] = None,
            filterable: Optional[bool] = None,
            link: Optional[bool] = None,
            cell_type: Optional[TableCellType] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this column.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;The text displayed on the column header.&#34;&#34;&#34;
        self.min_width = min_width
        &#34;&#34;&#34;The minimum width of this column, e.g. &#39;50px&#39;. Only `px` units are supported at this time.&#34;&#34;&#34;
        self.max_width = max_width
        &#34;&#34;&#34;The maximum width of this column, e.g. &#39;100px&#39;. Only `px` units are supported at this time.&#34;&#34;&#34;
        self.sortable = sortable
        &#34;&#34;&#34;Indicates whether the column is sortable.&#34;&#34;&#34;
        self.searchable = searchable
        &#34;&#34;&#34;Indicates whether the contents of this column can be searched through. Enables a search box for the table if true.&#34;&#34;&#34;
        self.filterable = filterable
        &#34;&#34;&#34;Indicates whether the contents of this column are displayed as filters in a dropdown.&#34;&#34;&#34;
        self.link = link
        &#34;&#34;&#34;Indicates whether each cell in this column should be displayed as a clickable link.&#34;&#34;&#34;
        self.cell_type = cell_type
        &#34;&#34;&#34;Defines how to render each cell in this column. Defaults to plain text.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;TableColumn.name is required.&#39;)
        if self.label is None:
            raise ValueError(&#39;TableColumn.label is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            min_width=self.min_width,
            max_width=self.max_width,
            sortable=self.sortable,
            searchable=self.searchable,
            filterable=self.filterable,
            link=self.link,
            cell_type=None if self.cell_type is None else self.cell_type.dump(),
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TableColumn&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;TableColumn.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        if __d_label is None:
            raise ValueError(&#39;TableColumn.label is required.&#39;)
        __d_min_width: Any = __d.get(&#39;min_width&#39;)
        __d_max_width: Any = __d.get(&#39;max_width&#39;)
        __d_sortable: Any = __d.get(&#39;sortable&#39;)
        __d_searchable: Any = __d.get(&#39;searchable&#39;)
        __d_filterable: Any = __d.get(&#39;filterable&#39;)
        __d_link: Any = __d.get(&#39;link&#39;)
        __d_cell_type: Any = __d.get(&#39;cell_type&#39;)
        name: str = __d_name
        label: str = __d_label
        min_width: Optional[str] = __d_min_width
        max_width: Optional[str] = __d_max_width
        sortable: Optional[bool] = __d_sortable
        searchable: Optional[bool] = __d_searchable
        filterable: Optional[bool] = __d_filterable
        link: Optional[bool] = __d_link
        cell_type: Optional[TableCellType] = None if __d_cell_type is None else TableCellType.load(__d_cell_type)
        return TableColumn(
            name,
            label,
            min_width,
            max_width,
            sortable,
            searchable,
            filterable,
            link,
            cell_type,
        )


class TableRow:
    &#34;&#34;&#34;Create a table row.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            cells: List[str],
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this row.&#34;&#34;&#34;
        self.cells = cells
        &#34;&#34;&#34;The cells in this row (displayed left to right).&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;TableRow.name is required.&#39;)
        if self.cells is None:
            raise ValueError(&#39;TableRow.cells is required.&#39;)
        return _dump(
            name=self.name,
            cells=self.cells,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TableRow&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;TableRow.name is required.&#39;)
        __d_cells: Any = __d.get(&#39;cells&#39;)
        if __d_cells is None:
            raise ValueError(&#39;TableRow.cells is required.&#39;)
        name: str = __d_name
        cells: List[str] = __d_cells
        return TableRow(
            name,
            cells,
        )


class Table:
    &#34;&#34;&#34;Create an interactive table.

    This table differs from a markdown table in that it supports clicking or selecting rows. If you simply want to
    display a non-interactive table of information, use a markdown table.

    If `multiple` is set to False (default), each row in the table is clickable. When a row is clicked, the form is
    submitted automatically, and `q.args.table_name` is set to `[row_name]`, where `table_name` is the `name` of
    the table, and `row_name` is the `name` of the row that was clicked on.

    If `multiple` is set to True, each row in the table is selectable. A row can be selected by clicking on it.
    Multiple rows can be selected either by shift+clicking or using marquee selection. When the form is submitted,
    `q.args.table_name` is set to `[row1_name, row2_name, ...]` where `table_name` is the `name` of the table,
    and `row1_name`, `row2_name` are the `name` of the rows that were selected. Note that if `multiple` is
    set to True, the form is not submitted automatically, and one or more buttons are required in the form to trigger
    submission.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            columns: List[TableColumn],
            rows: List[TableRow],
            multiple: Optional[bool] = None,
            groupable: Optional[bool] = None,
            downloadable: Optional[bool] = None,
            resettable: Optional[bool] = None,
            height: Optional[str] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.columns = columns
        &#34;&#34;&#34;The columns in this table.&#34;&#34;&#34;
        self.rows = rows
        &#34;&#34;&#34;The rows in this table.&#34;&#34;&#34;
        self.multiple = multiple
        &#34;&#34;&#34;True to allow multiple rows to be selected.&#34;&#34;&#34;
        self.groupable = groupable
        &#34;&#34;&#34;True to allow group by feature.&#34;&#34;&#34;
        self.downloadable = downloadable
        &#34;&#34;&#34;Indicates whether the contents of this table can be downloaded and saved as a CSV file. Defaults to False.&#34;&#34;&#34;
        self.resettable = resettable
        &#34;&#34;&#34;Indicates whether a Reset button should be displayed to reset search / filter / group-by values to their defaults. Defaults to False.&#34;&#34;&#34;
        self.height = height
        &#34;&#34;&#34;The height of the table, e.g. &#39;400px&#39;, &#39;50%&#39;, etc.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Table.name is required.&#39;)
        if self.columns is None:
            raise ValueError(&#39;Table.columns is required.&#39;)
        if self.rows is None:
            raise ValueError(&#39;Table.rows is required.&#39;)
        return _dump(
            name=self.name,
            columns=[__e.dump() for __e in self.columns],
            rows=[__e.dump() for __e in self.rows],
            multiple=self.multiple,
            groupable=self.groupable,
            downloadable=self.downloadable,
            resettable=self.resettable,
            height=self.height,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Table&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Table.name is required.&#39;)
        __d_columns: Any = __d.get(&#39;columns&#39;)
        if __d_columns is None:
            raise ValueError(&#39;Table.columns is required.&#39;)
        __d_rows: Any = __d.get(&#39;rows&#39;)
        if __d_rows is None:
            raise ValueError(&#39;Table.rows is required.&#39;)
        __d_multiple: Any = __d.get(&#39;multiple&#39;)
        __d_groupable: Any = __d.get(&#39;groupable&#39;)
        __d_downloadable: Any = __d.get(&#39;downloadable&#39;)
        __d_resettable: Any = __d.get(&#39;resettable&#39;)
        __d_height: Any = __d.get(&#39;height&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        columns: List[TableColumn] = [TableColumn.load(__e) for __e in __d_columns]
        rows: List[TableRow] = [TableRow.load(__e) for __e in __d_rows]
        multiple: Optional[bool] = __d_multiple
        groupable: Optional[bool] = __d_groupable
        downloadable: Optional[bool] = __d_downloadable
        resettable: Optional[bool] = __d_resettable
        height: Optional[str] = __d_height
        tooltip: Optional[str] = __d_tooltip
        return Table(
            name,
            columns,
            rows,
            multiple,
            groupable,
            downloadable,
            resettable,
            height,
            tooltip,
        )


class Link:
    &#34;&#34;&#34;Create a hyperlink.

    Hyperlinks can be internal or external.
    Internal hyperlinks have paths that begin with a `/` and point to URLs within the Q UI.
    All other kinds of paths are treated as external hyperlinks.
    &#34;&#34;&#34;
    def __init__(
            self,
            label: Optional[str] = None,
            path: Optional[str] = None,
            disabled: Optional[bool] = None,
            download: Optional[bool] = None,
            button: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.label = label
        &#34;&#34;&#34;The text to be displayed. If blank, the `path` is used as the label.&#34;&#34;&#34;
        self.path = path
        &#34;&#34;&#34;The path or URL to link to.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if the link should be disabled.&#34;&#34;&#34;
        self.download = download
        &#34;&#34;&#34;True if the link should be used for file download.&#34;&#34;&#34;
        self.button = button
        &#34;&#34;&#34;True if the link should be rendered as a button.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        return _dump(
            label=self.label,
            path=self.path,
            disabled=self.disabled,
            download=self.download,
            button=self.button,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Link&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_path: Any = __d.get(&#39;path&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_download: Any = __d.get(&#39;download&#39;)
        __d_button: Any = __d.get(&#39;button&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        label: Optional[str] = __d_label
        path: Optional[str] = __d_path
        disabled: Optional[bool] = __d_disabled
        download: Optional[bool] = __d_download
        button: Optional[bool] = __d_button
        tooltip: Optional[str] = __d_tooltip
        return Link(
            label,
            path,
            disabled,
            download,
            button,
            tooltip,
        )


class Tab:
    &#34;&#34;&#34;Create a tab.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            icon: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;The text displayed on the tab.&#34;&#34;&#34;
        self.icon = icon
        &#34;&#34;&#34;The icon displayed on the tab.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Tab.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            icon=self.icon,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Tab&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Tab.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_icon: Any = __d.get(&#39;icon&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        icon: Optional[str] = __d_icon
        return Tab(
            name,
            label,
            icon,
        )


class Tabs:
    &#34;&#34;&#34;Create a tab bar.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            value: Optional[str] = None,
            items: Optional[List[Tab]] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The name of the tab to select.&#34;&#34;&#34;
        self.items = items
        &#34;&#34;&#34;The tabs in this tab bar.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Tabs.name is required.&#39;)
        return _dump(
            name=self.name,
            value=self.value,
            items=None if self.items is None else [__e.dump() for __e in self.items],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Tabs&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Tabs.name is required.&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_items: Any = __d.get(&#39;items&#39;)
        name: str = __d_name
        value: Optional[str] = __d_value
        items: Optional[List[Tab]] = None if __d_items is None else [Tab.load(__e) for __e in __d_items]
        return Tabs(
            name,
            value,
            items,
        )


class Expander:
    &#34;&#34;&#34;Creates a new expander.

    Expanders can be used to show or hide a group of related components.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            expanded: Optional[bool] = None,
            items: Optional[List[&#39;Component&#39;]] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;The text displayed on the expander.&#34;&#34;&#34;
        self.expanded = expanded
        &#34;&#34;&#34;True if expanded, False if collapsed.&#34;&#34;&#34;
        self.items = items
        &#34;&#34;&#34;List of components to be hideable by the expander.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Expander.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            expanded=self.expanded,
            items=None if self.items is None else [__e.dump() for __e in self.items],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Expander&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Expander.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_expanded: Any = __d.get(&#39;expanded&#39;)
        __d_items: Any = __d.get(&#39;items&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        expanded: Optional[bool] = __d_expanded
        items: Optional[List[&#39;Component&#39;]] = None if __d_items is None else [Component.load(__e) for __e in __d_items]
        return Expander(
            name,
            label,
            expanded,
            items,
        )


class Frame:
    &#34;&#34;&#34;Create a new inline frame (an `iframe`).
    &#34;&#34;&#34;
    def __init__(
            self,
            path: Optional[str] = None,
            content: Optional[str] = None,
            width: Optional[str] = None,
            height: Optional[str] = None,
    ):
        self.path = path
        &#34;&#34;&#34;The path or URL of the web page, e.g. `/foo.html` or `http://example.com/foo.html`&#34;&#34;&#34;
        self.content = content
        &#34;&#34;&#34;The HTML content of the page. A string containing `&lt;html&gt;...&lt;/html&gt;`.&#34;&#34;&#34;
        self.width = width
        &#34;&#34;&#34;The width of the frame, e.g. `200px`, `50%`, etc. Defaults to `100%`.&#34;&#34;&#34;
        self.height = height
        &#34;&#34;&#34;The height of the frame, e.g. `200px`, `50%`, etc. Defaults to `150px`.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        return _dump(
            path=self.path,
            content=self.content,
            width=self.width,
            height=self.height,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Frame&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_path: Any = __d.get(&#39;path&#39;)
        __d_content: Any = __d.get(&#39;content&#39;)
        __d_width: Any = __d.get(&#39;width&#39;)
        __d_height: Any = __d.get(&#39;height&#39;)
        path: Optional[str] = __d_path
        content: Optional[str] = __d_content
        width: Optional[str] = __d_width
        height: Optional[str] = __d_height
        return Frame(
            path,
            content,
            width,
            height,
        )


class Markup:
    &#34;&#34;&#34;Render HTML content.
    &#34;&#34;&#34;
    def __init__(
            self,
            content: str,
    ):
        self.content = content
        &#34;&#34;&#34;The HTML content.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.content is None:
            raise ValueError(&#39;Markup.content is required.&#39;)
        return _dump(
            content=self.content,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Markup&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_content: Any = __d.get(&#39;content&#39;)
        if __d_content is None:
            raise ValueError(&#39;Markup.content is required.&#39;)
        content: str = __d_content
        return Markup(
            content,
        )


class Template:
    &#34;&#34;&#34;Render dynamic content using a HTML template.
    &#34;&#34;&#34;
    def __init__(
            self,
            content: str,
            data: Optional[PackedRecord] = None,
    ):
        self.content = content
        &#34;&#34;&#34;The Handlebars template. https://handlebarsjs.com/guide/&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for the Handlebars template&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.content is None:
            raise ValueError(&#39;Template.content is required.&#39;)
        return _dump(
            content=self.content,
            data=self.data,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Template&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_content: Any = __d.get(&#39;content&#39;)
        if __d_content is None:
            raise ValueError(&#39;Template.content is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        content: str = __d_content
        data: Optional[PackedRecord] = __d_data
        return Template(
            content,
            data,
        )


class Picker:
    &#34;&#34;&#34;Create a picker.
    Pickers are used to select one or more choices, such as tags or files, from a list.
    Use a picker to allow the user to quickly search for or manage a few tags or files.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            choices: List[Choice],
            label: Optional[str] = None,
            values: Optional[List[str]] = None,
            max_choices: Optional[int] = None,
            disabled: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.choices = choices
        &#34;&#34;&#34;The choices to be presented.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed above the component.&#34;&#34;&#34;
        self.values = values
        &#34;&#34;&#34;The names of the selected choices.&#34;&#34;&#34;
        self.max_choices = max_choices
        &#34;&#34;&#34;Maximum number of selectable choices. Defaults to no limit.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;Controls whether the picker should be disabled or not.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Picker.name is required.&#39;)
        if self.choices is None:
            raise ValueError(&#39;Picker.choices is required.&#39;)
        return _dump(
            name=self.name,
            choices=[__e.dump() for __e in self.choices],
            label=self.label,
            values=self.values,
            max_choices=self.max_choices,
            disabled=self.disabled,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Picker&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Picker.name is required.&#39;)
        __d_choices: Any = __d.get(&#39;choices&#39;)
        if __d_choices is None:
            raise ValueError(&#39;Picker.choices is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_values: Any = __d.get(&#39;values&#39;)
        __d_max_choices: Any = __d.get(&#39;max_choices&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        choices: List[Choice] = [Choice.load(__e) for __e in __d_choices]
        label: Optional[str] = __d_label
        values: Optional[List[str]] = __d_values
        max_choices: Optional[int] = __d_max_choices
        disabled: Optional[bool] = __d_disabled
        tooltip: Optional[str] = __d_tooltip
        return Picker(
            name,
            choices,
            label,
            values,
            max_choices,
            disabled,
            tooltip,
        )


class RangeSlider:
    &#34;&#34;&#34;Create a range slider.

    A range slider is an element used to select a value range. It provides a visual indication of adjustable content, as well as the
    current setting in the total range of content. It is displayed as a horizontal track with options on either side.
    Knobs or levers are dragged to one end or the other to make the choice, indicating the current max and min value.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            min: Optional[float] = None,
            max: Optional[float] = None,
            step: Optional[float] = None,
            min_value: Optional[float] = None,
            max_value: Optional[float] = None,
            disabled: Optional[bool] = None,
            trigger: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the component.&#34;&#34;&#34;
        self.min = min
        &#34;&#34;&#34;The minimum value of the slider. Defaults to 0.&#34;&#34;&#34;
        self.max = max
        &#34;&#34;&#34;The maximum value of the slider. Defaults to 100.&#34;&#34;&#34;
        self.step = step
        &#34;&#34;&#34;The difference between two adjacent values of the slider.&#34;&#34;&#34;
        self.min_value = min_value
        &#34;&#34;&#34;The lower bound of the selected range.&#34;&#34;&#34;
        self.max_value = max_value
        &#34;&#34;&#34;The upper bound of the selected range.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if this field is disabled.&#34;&#34;&#34;
        self.trigger = trigger
        &#34;&#34;&#34;True if the form should be submitted when the slider value changes.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;RangeSlider.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            min=self.min,
            max=self.max,
            step=self.step,
            min_value=self.min_value,
            max_value=self.max_value,
            disabled=self.disabled,
            trigger=self.trigger,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;RangeSlider&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;RangeSlider.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_min: Any = __d.get(&#39;min&#39;)
        __d_max: Any = __d.get(&#39;max&#39;)
        __d_step: Any = __d.get(&#39;step&#39;)
        __d_min_value: Any = __d.get(&#39;min_value&#39;)
        __d_max_value: Any = __d.get(&#39;max_value&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_trigger: Any = __d.get(&#39;trigger&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        min: Optional[float] = __d_min
        max: Optional[float] = __d_max
        step: Optional[float] = __d_step
        min_value: Optional[float] = __d_min_value
        max_value: Optional[float] = __d_max_value
        disabled: Optional[bool] = __d_disabled
        trigger: Optional[bool] = __d_trigger
        tooltip: Optional[str] = __d_tooltip
        return RangeSlider(
            name,
            label,
            min,
            max,
            step,
            min_value,
            max_value,
            disabled,
            trigger,
            tooltip,
        )


class Step:
    &#34;&#34;&#34;Create a step for a stepper.
    &#34;&#34;&#34;
    def __init__(
            self,
            label: str,
            icon: Optional[str] = None,
            done: Optional[bool] = None,
    ):
        self.label = label
        &#34;&#34;&#34;Text displayed below icon.&#34;&#34;&#34;
        self.icon = icon
        &#34;&#34;&#34;Icon to be displayed.&#34;&#34;&#34;
        self.done = done
        &#34;&#34;&#34;Indicates whether this step has already been completed.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.label is None:
            raise ValueError(&#39;Step.label is required.&#39;)
        return _dump(
            label=self.label,
            icon=self.icon,
            done=self.done,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Step&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_label: Any = __d.get(&#39;label&#39;)
        if __d_label is None:
            raise ValueError(&#39;Step.label is required.&#39;)
        __d_icon: Any = __d.get(&#39;icon&#39;)
        __d_done: Any = __d.get(&#39;done&#39;)
        label: str = __d_label
        icon: Optional[str] = __d_icon
        done: Optional[bool] = __d_done
        return Step(
            label,
            icon,
            done,
        )


class Stepper:
    &#34;&#34;&#34;Create a component that displays a sequence of steps in a process.
    The steps keep users informed about where they are in the process and how much is left to complete.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            items: List[Step],
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.items = items
        &#34;&#34;&#34;The sequence of steps to be displayed.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Stepper.name is required.&#39;)
        if self.items is None:
            raise ValueError(&#39;Stepper.items is required.&#39;)
        return _dump(
            name=self.name,
            items=[__e.dump() for __e in self.items],
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Stepper&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Stepper.name is required.&#39;)
        __d_items: Any = __d.get(&#39;items&#39;)
        if __d_items is None:
            raise ValueError(&#39;Stepper.items is required.&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        items: List[Step] = [Step.load(__e) for __e in __d_items]
        tooltip: Optional[str] = __d_tooltip
        return Stepper(
            name,
            items,
            tooltip,
        )


class Mark:
    &#34;&#34;&#34;Create a specification for a layer of graphical marks such as bars, lines, points for a plot.
    A plot can contain multiple such layers of marks.
    &#34;&#34;&#34;
    def __init__(
            self,
            coord: Optional[str] = None,
            type: Optional[str] = None,
            x: Optional[Value] = None,
            x0: Optional[Value] = None,
            x1: Optional[Value] = None,
            x2: Optional[Value] = None,
            x_min: Optional[float] = None,
            x_max: Optional[float] = None,
            x_nice: Optional[bool] = None,
            x_scale: Optional[str] = None,
            x_title: Optional[str] = None,
            y: Optional[Value] = None,
            y0: Optional[Value] = None,
            y1: Optional[Value] = None,
            y2: Optional[Value] = None,
            y_min: Optional[float] = None,
            y_max: Optional[float] = None,
            y_nice: Optional[bool] = None,
            y_scale: Optional[str] = None,
            y_title: Optional[str] = None,
            color: Optional[str] = None,
            color_range: Optional[str] = None,
            color_domain: Optional[List[str]] = None,
            shape: Optional[str] = None,
            shape_range: Optional[str] = None,
            size: Optional[Value] = None,
            size_range: Optional[str] = None,
            stack: Optional[str] = None,
            dodge: Optional[str] = None,
            curve: Optional[str] = None,
            fill_color: Optional[str] = None,
            fill_opacity: Optional[float] = None,
            stroke_color: Optional[str] = None,
            stroke_opacity: Optional[float] = None,
            stroke_size: Optional[float] = None,
            stroke_dash: Optional[str] = None,
            label: Optional[str] = None,
            label_offset: Optional[float] = None,
            label_offset_x: Optional[float] = None,
            label_offset_y: Optional[float] = None,
            label_rotation: Optional[str] = None,
            label_position: Optional[str] = None,
            label_overlap: Optional[str] = None,
            label_fill_color: Optional[str] = None,
            label_fill_opacity: Optional[float] = None,
            label_stroke_color: Optional[str] = None,
            label_stroke_opacity: Optional[float] = None,
            label_stroke_size: Optional[float] = None,
            label_font_size: Optional[float] = None,
            label_font_weight: Optional[str] = None,
            label_line_height: Optional[float] = None,
            label_align: Optional[str] = None,
            ref_stroke_color: Optional[str] = None,
            ref_stroke_opacity: Optional[float] = None,
            ref_stroke_size: Optional[float] = None,
            ref_stroke_dash: Optional[str] = None,
    ):
        self.coord = coord
        &#34;&#34;&#34;Coordinate system. `rect` is synonymous to `cartesian`. `theta` is transposed `polar`. One of &#39;rect&#39;, &#39;cartesian&#39;, &#39;polar&#39;, &#39;theta&#39;, &#39;helix&#39;.&#34;&#34;&#34;
        self.type = type
        &#34;&#34;&#34;Graphical geometry. One of &#39;interval&#39;, &#39;line&#39;, &#39;path&#39;, &#39;point&#39;, &#39;area&#39;, &#39;polygon&#39;, &#39;schema&#39;, &#39;edge&#39;, &#39;heatmap&#39;.&#34;&#34;&#34;
        self.x = x
        &#34;&#34;&#34;X field or value.&#34;&#34;&#34;
        self.x0 = x0
        &#34;&#34;&#34;X base field or value.&#34;&#34;&#34;
        self.x1 = x1
        &#34;&#34;&#34;X bin lower bound field or value. For histograms.&#34;&#34;&#34;
        self.x2 = x2
        &#34;&#34;&#34;X bin upper bound field or value. For histograms.&#34;&#34;&#34;
        self.x_min = x_min
        &#34;&#34;&#34;X axis scale minimum.&#34;&#34;&#34;
        self.x_max = x_max
        &#34;&#34;&#34;X axis scale maximum.&#34;&#34;&#34;
        self.x_nice = x_nice
        &#34;&#34;&#34;Whether to nice X axis scale ticks.&#34;&#34;&#34;
        self.x_scale = x_scale
        &#34;&#34;&#34;X axis scale type. One of &#39;linear&#39;, &#39;cat&#39;, &#39;category&#39;, &#39;identity&#39;, &#39;log&#39;, &#39;pow&#39;, &#39;time&#39;, &#39;timeCat&#39;, &#39;quantize&#39;, &#39;quantile&#39;.&#34;&#34;&#34;
        self.x_title = x_title
        &#34;&#34;&#34;X axis title.&#34;&#34;&#34;
        self.y = y
        &#34;&#34;&#34;Y field or value.&#34;&#34;&#34;
        self.y0 = y0
        &#34;&#34;&#34;Y base field or value.&#34;&#34;&#34;
        self.y1 = y1
        &#34;&#34;&#34;Y bin lower bound field or value. For histograms.&#34;&#34;&#34;
        self.y2 = y2
        &#34;&#34;&#34;Y bin upper bound field or value. For histograms.&#34;&#34;&#34;
        self.y_min = y_min
        &#34;&#34;&#34;Y axis scale minimum.&#34;&#34;&#34;
        self.y_max = y_max
        &#34;&#34;&#34;Y axis scale maximum.&#34;&#34;&#34;
        self.y_nice = y_nice
        &#34;&#34;&#34;Whether to nice Y axis scale ticks.&#34;&#34;&#34;
        self.y_scale = y_scale
        &#34;&#34;&#34;Y axis scale type. One of &#39;linear&#39;, &#39;cat&#39;, &#39;category&#39;, &#39;identity&#39;, &#39;log&#39;, &#39;pow&#39;, &#39;time&#39;, &#39;timeCat&#39;, &#39;quantize&#39;, &#39;quantile&#39;.&#34;&#34;&#34;
        self.y_title = y_title
        &#34;&#34;&#34;Y axis title.&#34;&#34;&#34;
        self.color = color
        &#34;&#34;&#34;Mark color field or value.&#34;&#34;&#34;
        self.color_range = color_range
        &#34;&#34;&#34;Mark color range for multi-series plots. A string containing space-separated colors, e.g. `&#39;#fee8c8 #fdbb84 #e34a33&#39;`&#34;&#34;&#34;
        self.color_domain = color_domain
        &#34;&#34;&#34;The unique values in the data (labels or categories or classes) to map colors to, e.g. `[&#39;high&#39;, &#39;medium&#39;, &#39;low&#39;]`. If this is not provided, the unique values are automatically inferred from the `color` attribute.&#34;&#34;&#34;
        self.shape = shape
        &#34;&#34;&#34;Mark shape field or value for `point` mark types. Possible values are &#39;circle&#39;, &#39;square&#39;, &#39;bowtie&#39;, &#39;diamond&#39;, &#39;hexagon&#39;, &#39;triangle&#39;, &#39;triangle-down&#39;, &#39;cross&#39;, &#39;tick&#39;, &#39;plus&#39;, &#39;hyphen&#39;, &#39;line&#39;.&#34;&#34;&#34;
        self.shape_range = shape_range
        &#34;&#34;&#34;Mark shape range for multi-series plots using `point` mark types. A string containing space-separated shapes, e.g. `&#39;circle square diamond&#39;`&#34;&#34;&#34;
        self.size = size
        &#34;&#34;&#34;Mark size field or value.&#34;&#34;&#34;
        self.size_range = size_range
        &#34;&#34;&#34;Mark size range. A string containing space-separated integers, e.g. `&#39;4 30&#39;`&#34;&#34;&#34;
        self.stack = stack
        &#34;&#34;&#34;Field to stack marks by, or &#39;auto&#39; to infer.&#34;&#34;&#34;
        self.dodge = dodge
        &#34;&#34;&#34;Field to dodge marks by, or &#39;auto&#39; to infer.&#34;&#34;&#34;
        self.curve = curve
        &#34;&#34;&#34;Curve type for `line` and `area` mark types. One of &#39;none&#39;, &#39;smooth&#39;, &#39;step-before&#39;, &#39;step&#39;, &#39;step-after&#39;.&#34;&#34;&#34;
        self.fill_color = fill_color
        &#34;&#34;&#34;Mark fill color.&#34;&#34;&#34;
        self.fill_opacity = fill_opacity
        &#34;&#34;&#34;Mark fill opacity.&#34;&#34;&#34;
        self.stroke_color = stroke_color
        &#34;&#34;&#34;Mark stroke color.&#34;&#34;&#34;
        self.stroke_opacity = stroke_opacity
        &#34;&#34;&#34;Mark stroke opacity.&#34;&#34;&#34;
        self.stroke_size = stroke_size
        &#34;&#34;&#34;Mark stroke size.&#34;&#34;&#34;
        self.stroke_dash = stroke_dash
        &#34;&#34;&#34;Mark stroke dash style. A string containing space-separated integers that specify distances to alternately draw a line and a gap (in coordinate space units). If the number of elements in the array is odd, the elements of the array get copied and concatenated. For example, [5, 15, 25] will become [5, 15, 25, 5, 15, 25].&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Label field or value.&#34;&#34;&#34;
        self.label_offset = label_offset
        &#34;&#34;&#34;Distance between label and mark.&#34;&#34;&#34;
        self.label_offset_x = label_offset_x
        &#34;&#34;&#34;Horizontal distance between label and mark.&#34;&#34;&#34;
        self.label_offset_y = label_offset_y
        &#34;&#34;&#34;Vertical distance between label and mark.&#34;&#34;&#34;
        self.label_rotation = label_rotation
        &#34;&#34;&#34;Label rotation angle, in degrees, or &#39;none&#39; to disable automatic rotation. The default behavior is &#39;auto&#39; for automatic rotation.&#34;&#34;&#34;
        self.label_position = label_position
        &#34;&#34;&#34;Label position relative to the mark. One of &#39;top&#39;, &#39;bottom&#39;, &#39;middle&#39;, &#39;left&#39;, &#39;right&#39;.&#34;&#34;&#34;
        self.label_overlap = label_overlap
        &#34;&#34;&#34;Strategy to use if labels overlap. One of &#39;hide&#39;, &#39;overlap&#39;, &#39;constrain&#39;.&#34;&#34;&#34;
        self.label_fill_color = label_fill_color
        &#34;&#34;&#34;Label fill color.&#34;&#34;&#34;
        self.label_fill_opacity = label_fill_opacity
        &#34;&#34;&#34;Label fill opacity.&#34;&#34;&#34;
        self.label_stroke_color = label_stroke_color
        &#34;&#34;&#34;Label stroke color.&#34;&#34;&#34;
        self.label_stroke_opacity = label_stroke_opacity
        &#34;&#34;&#34;Label stroke opacity.&#34;&#34;&#34;
        self.label_stroke_size = label_stroke_size
        &#34;&#34;&#34;Label stroke size (line width or pen thickness).&#34;&#34;&#34;
        self.label_font_size = label_font_size
        &#34;&#34;&#34;Label font size.&#34;&#34;&#34;
        self.label_font_weight = label_font_weight
        &#34;&#34;&#34;Label font weight.&#34;&#34;&#34;
        self.label_line_height = label_line_height
        &#34;&#34;&#34;Label line height.&#34;&#34;&#34;
        self.label_align = label_align
        &#34;&#34;&#34;Label text alignment. One of &#39;left&#39;, &#39;right&#39;, &#39;center&#39;, &#39;start&#39;, &#39;end&#39;.&#34;&#34;&#34;
        self.ref_stroke_color = ref_stroke_color
        &#34;&#34;&#34;Reference line stroke color.&#34;&#34;&#34;
        self.ref_stroke_opacity = ref_stroke_opacity
        &#34;&#34;&#34;Reference line stroke opacity.&#34;&#34;&#34;
        self.ref_stroke_size = ref_stroke_size
        &#34;&#34;&#34;Reference line stroke size (line width or pen thickness).&#34;&#34;&#34;
        self.ref_stroke_dash = ref_stroke_dash
        &#34;&#34;&#34;Reference line stroke dash style. A string containing space-separated integers that specify distances to alternately draw a line and a gap (in coordinate space units). If the number of elements in the array is odd, the elements of the array get copied and concatenated. For example, [5, 15, 25] will become [5, 15, 25, 5, 15, 25].&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        return _dump(
            coord=self.coord,
            type=self.type,
            x=self.x,
            x0=self.x0,
            x1=self.x1,
            x2=self.x2,
            x_min=self.x_min,
            x_max=self.x_max,
            x_nice=self.x_nice,
            x_scale=self.x_scale,
            x_title=self.x_title,
            y=self.y,
            y0=self.y0,
            y1=self.y1,
            y2=self.y2,
            y_min=self.y_min,
            y_max=self.y_max,
            y_nice=self.y_nice,
            y_scale=self.y_scale,
            y_title=self.y_title,
            color=self.color,
            color_range=self.color_range,
            color_domain=self.color_domain,
            shape=self.shape,
            shape_range=self.shape_range,
            size=self.size,
            size_range=self.size_range,
            stack=self.stack,
            dodge=self.dodge,
            curve=self.curve,
            fill_color=self.fill_color,
            fill_opacity=self.fill_opacity,
            stroke_color=self.stroke_color,
            stroke_opacity=self.stroke_opacity,
            stroke_size=self.stroke_size,
            stroke_dash=self.stroke_dash,
            label=self.label,
            label_offset=self.label_offset,
            label_offset_x=self.label_offset_x,
            label_offset_y=self.label_offset_y,
            label_rotation=self.label_rotation,
            label_position=self.label_position,
            label_overlap=self.label_overlap,
            label_fill_color=self.label_fill_color,
            label_fill_opacity=self.label_fill_opacity,
            label_stroke_color=self.label_stroke_color,
            label_stroke_opacity=self.label_stroke_opacity,
            label_stroke_size=self.label_stroke_size,
            label_font_size=self.label_font_size,
            label_font_weight=self.label_font_weight,
            label_line_height=self.label_line_height,
            label_align=self.label_align,
            ref_stroke_color=self.ref_stroke_color,
            ref_stroke_opacity=self.ref_stroke_opacity,
            ref_stroke_size=self.ref_stroke_size,
            ref_stroke_dash=self.ref_stroke_dash,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Mark&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_coord: Any = __d.get(&#39;coord&#39;)
        __d_type: Any = __d.get(&#39;type&#39;)
        __d_x: Any = __d.get(&#39;x&#39;)
        __d_x0: Any = __d.get(&#39;x0&#39;)
        __d_x1: Any = __d.get(&#39;x1&#39;)
        __d_x2: Any = __d.get(&#39;x2&#39;)
        __d_x_min: Any = __d.get(&#39;x_min&#39;)
        __d_x_max: Any = __d.get(&#39;x_max&#39;)
        __d_x_nice: Any = __d.get(&#39;x_nice&#39;)
        __d_x_scale: Any = __d.get(&#39;x_scale&#39;)
        __d_x_title: Any = __d.get(&#39;x_title&#39;)
        __d_y: Any = __d.get(&#39;y&#39;)
        __d_y0: Any = __d.get(&#39;y0&#39;)
        __d_y1: Any = __d.get(&#39;y1&#39;)
        __d_y2: Any = __d.get(&#39;y2&#39;)
        __d_y_min: Any = __d.get(&#39;y_min&#39;)
        __d_y_max: Any = __d.get(&#39;y_max&#39;)
        __d_y_nice: Any = __d.get(&#39;y_nice&#39;)
        __d_y_scale: Any = __d.get(&#39;y_scale&#39;)
        __d_y_title: Any = __d.get(&#39;y_title&#39;)
        __d_color: Any = __d.get(&#39;color&#39;)
        __d_color_range: Any = __d.get(&#39;color_range&#39;)
        __d_color_domain: Any = __d.get(&#39;color_domain&#39;)
        __d_shape: Any = __d.get(&#39;shape&#39;)
        __d_shape_range: Any = __d.get(&#39;shape_range&#39;)
        __d_size: Any = __d.get(&#39;size&#39;)
        __d_size_range: Any = __d.get(&#39;size_range&#39;)
        __d_stack: Any = __d.get(&#39;stack&#39;)
        __d_dodge: Any = __d.get(&#39;dodge&#39;)
        __d_curve: Any = __d.get(&#39;curve&#39;)
        __d_fill_color: Any = __d.get(&#39;fill_color&#39;)
        __d_fill_opacity: Any = __d.get(&#39;fill_opacity&#39;)
        __d_stroke_color: Any = __d.get(&#39;stroke_color&#39;)
        __d_stroke_opacity: Any = __d.get(&#39;stroke_opacity&#39;)
        __d_stroke_size: Any = __d.get(&#39;stroke_size&#39;)
        __d_stroke_dash: Any = __d.get(&#39;stroke_dash&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_label_offset: Any = __d.get(&#39;label_offset&#39;)
        __d_label_offset_x: Any = __d.get(&#39;label_offset_x&#39;)
        __d_label_offset_y: Any = __d.get(&#39;label_offset_y&#39;)
        __d_label_rotation: Any = __d.get(&#39;label_rotation&#39;)
        __d_label_position: Any = __d.get(&#39;label_position&#39;)
        __d_label_overlap: Any = __d.get(&#39;label_overlap&#39;)
        __d_label_fill_color: Any = __d.get(&#39;label_fill_color&#39;)
        __d_label_fill_opacity: Any = __d.get(&#39;label_fill_opacity&#39;)
        __d_label_stroke_color: Any = __d.get(&#39;label_stroke_color&#39;)
        __d_label_stroke_opacity: Any = __d.get(&#39;label_stroke_opacity&#39;)
        __d_label_stroke_size: Any = __d.get(&#39;label_stroke_size&#39;)
        __d_label_font_size: Any = __d.get(&#39;label_font_size&#39;)
        __d_label_font_weight: Any = __d.get(&#39;label_font_weight&#39;)
        __d_label_line_height: Any = __d.get(&#39;label_line_height&#39;)
        __d_label_align: Any = __d.get(&#39;label_align&#39;)
        __d_ref_stroke_color: Any = __d.get(&#39;ref_stroke_color&#39;)
        __d_ref_stroke_opacity: Any = __d.get(&#39;ref_stroke_opacity&#39;)
        __d_ref_stroke_size: Any = __d.get(&#39;ref_stroke_size&#39;)
        __d_ref_stroke_dash: Any = __d.get(&#39;ref_stroke_dash&#39;)
        coord: Optional[str] = __d_coord
        type: Optional[str] = __d_type
        x: Optional[Value] = __d_x
        x0: Optional[Value] = __d_x0
        x1: Optional[Value] = __d_x1
        x2: Optional[Value] = __d_x2
        x_min: Optional[float] = __d_x_min
        x_max: Optional[float] = __d_x_max
        x_nice: Optional[bool] = __d_x_nice
        x_scale: Optional[str] = __d_x_scale
        x_title: Optional[str] = __d_x_title
        y: Optional[Value] = __d_y
        y0: Optional[Value] = __d_y0
        y1: Optional[Value] = __d_y1
        y2: Optional[Value] = __d_y2
        y_min: Optional[float] = __d_y_min
        y_max: Optional[float] = __d_y_max
        y_nice: Optional[bool] = __d_y_nice
        y_scale: Optional[str] = __d_y_scale
        y_title: Optional[str] = __d_y_title
        color: Optional[str] = __d_color
        color_range: Optional[str] = __d_color_range
        color_domain: Optional[List[str]] = __d_color_domain
        shape: Optional[str] = __d_shape
        shape_range: Optional[str] = __d_shape_range
        size: Optional[Value] = __d_size
        size_range: Optional[str] = __d_size_range
        stack: Optional[str] = __d_stack
        dodge: Optional[str] = __d_dodge
        curve: Optional[str] = __d_curve
        fill_color: Optional[str] = __d_fill_color
        fill_opacity: Optional[float] = __d_fill_opacity
        stroke_color: Optional[str] = __d_stroke_color
        stroke_opacity: Optional[float] = __d_stroke_opacity
        stroke_size: Optional[float] = __d_stroke_size
        stroke_dash: Optional[str] = __d_stroke_dash
        label: Optional[str] = __d_label
        label_offset: Optional[float] = __d_label_offset
        label_offset_x: Optional[float] = __d_label_offset_x
        label_offset_y: Optional[float] = __d_label_offset_y
        label_rotation: Optional[str] = __d_label_rotation
        label_position: Optional[str] = __d_label_position
        label_overlap: Optional[str] = __d_label_overlap
        label_fill_color: Optional[str] = __d_label_fill_color
        label_fill_opacity: Optional[float] = __d_label_fill_opacity
        label_stroke_color: Optional[str] = __d_label_stroke_color
        label_stroke_opacity: Optional[float] = __d_label_stroke_opacity
        label_stroke_size: Optional[float] = __d_label_stroke_size
        label_font_size: Optional[float] = __d_label_font_size
        label_font_weight: Optional[str] = __d_label_font_weight
        label_line_height: Optional[float] = __d_label_line_height
        label_align: Optional[str] = __d_label_align
        ref_stroke_color: Optional[str] = __d_ref_stroke_color
        ref_stroke_opacity: Optional[float] = __d_ref_stroke_opacity
        ref_stroke_size: Optional[float] = __d_ref_stroke_size
        ref_stroke_dash: Optional[str] = __d_ref_stroke_dash
        return Mark(
            coord,
            type,
            x,
            x0,
            x1,
            x2,
            x_min,
            x_max,
            x_nice,
            x_scale,
            x_title,
            y,
            y0,
            y1,
            y2,
            y_min,
            y_max,
            y_nice,
            y_scale,
            y_title,
            color,
            color_range,
            color_domain,
            shape,
            shape_range,
            size,
            size_range,
            stack,
            dodge,
            curve,
            fill_color,
            fill_opacity,
            stroke_color,
            stroke_opacity,
            stroke_size,
            stroke_dash,
            label,
            label_offset,
            label_offset_x,
            label_offset_y,
            label_rotation,
            label_position,
            label_overlap,
            label_fill_color,
            label_fill_opacity,
            label_stroke_color,
            label_stroke_opacity,
            label_stroke_size,
            label_font_size,
            label_font_weight,
            label_line_height,
            label_align,
            ref_stroke_color,
            ref_stroke_opacity,
            ref_stroke_size,
            ref_stroke_dash,
        )


class Plot:
    &#34;&#34;&#34;Create a plot. A plot is composed of one or more graphical mark layers.
    &#34;&#34;&#34;
    def __init__(
            self,
            marks: List[Mark],
    ):
        self.marks = marks
        &#34;&#34;&#34;The graphical mark layers contained in this plot.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.marks is None:
            raise ValueError(&#39;Plot.marks is required.&#39;)
        return _dump(
            marks=[__e.dump() for __e in self.marks],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Plot&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_marks: Any = __d.get(&#39;marks&#39;)
        if __d_marks is None:
            raise ValueError(&#39;Plot.marks is required.&#39;)
        marks: List[Mark] = [Mark.load(__e) for __e in __d_marks]
        return Plot(
            marks,
        )


class Visualization:
    &#34;&#34;&#34;Create a visualization for display inside a form.
    &#34;&#34;&#34;
    def __init__(
            self,
            plot: Plot,
            data: PackedRecord,
            width: Optional[str] = None,
            height: Optional[str] = None,
    ):
        self.plot = plot
        &#34;&#34;&#34;The plot to be rendered in this visualization.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this visualization.&#34;&#34;&#34;
        self.width = width
        &#34;&#34;&#34;The width of the visualization. Defaults to 100%.&#34;&#34;&#34;
        self.height = height
        &#34;&#34;&#34;The height of the visualization. Defaults to 300px.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.plot is None:
            raise ValueError(&#39;Visualization.plot is required.&#39;)
        if self.data is None:
            raise ValueError(&#39;Visualization.data is required.&#39;)
        return _dump(
            plot=self.plot.dump(),
            data=self.data,
            width=self.width,
            height=self.height,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Visualization&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_plot: Any = __d.get(&#39;plot&#39;)
        if __d_plot is None:
            raise ValueError(&#39;Visualization.plot is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        if __d_data is None:
            raise ValueError(&#39;Visualization.data is required.&#39;)
        __d_width: Any = __d.get(&#39;width&#39;)
        __d_height: Any = __d.get(&#39;height&#39;)
        plot: Plot = Plot.load(__d_plot)
        data: PackedRecord = __d_data
        width: Optional[str] = __d_width
        height: Optional[str] = __d_height
        return Visualization(
            plot,
            data,
            width,
            height,
        )


class VegaVisualization:
    &#34;&#34;&#34;Create a Vega-lite plot for display inside a form.
    &#34;&#34;&#34;
    def __init__(
            self,
            specification: str,
            data: Optional[PackedRecord] = None,
            width: Optional[str] = None,
            height: Optional[str] = None,
    ):
        self.specification = specification
        &#34;&#34;&#34;The Vega-lite specification.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for the plot, if any.&#34;&#34;&#34;
        self.width = width
        &#34;&#34;&#34;The width of the visualization. Defaults to 100%.&#34;&#34;&#34;
        self.height = height
        &#34;&#34;&#34;The height of the visualization. Defaults to 300px.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.specification is None:
            raise ValueError(&#39;VegaVisualization.specification is required.&#39;)
        return _dump(
            specification=self.specification,
            data=self.data,
            width=self.width,
            height=self.height,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;VegaVisualization&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_specification: Any = __d.get(&#39;specification&#39;)
        if __d_specification is None:
            raise ValueError(&#39;VegaVisualization.specification is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_width: Any = __d.get(&#39;width&#39;)
        __d_height: Any = __d.get(&#39;height&#39;)
        specification: str = __d_specification
        data: Optional[PackedRecord] = __d_data
        width: Optional[str] = __d_width
        height: Optional[str] = __d_height
        return VegaVisualization(
            specification,
            data,
            width,
            height,
        )


class Component:
    &#34;&#34;&#34;Create a component.
    &#34;&#34;&#34;
    def __init__(
            self,
            text: Optional[Text] = None,
            text_xl: Optional[TextXl] = None,
            text_l: Optional[TextL] = None,
            text_m: Optional[TextM] = None,
            text_s: Optional[TextS] = None,
            text_xs: Optional[TextXs] = None,
            label: Optional[Label] = None,
            separator: Optional[Separator] = None,
            progress: Optional[Progress] = None,
            message_bar: Optional[MessageBar] = None,
            textbox: Optional[Textbox] = None,
            checkbox: Optional[Checkbox] = None,
            toggle: Optional[Toggle] = None,
            choice_group: Optional[ChoiceGroup] = None,
            checklist: Optional[Checklist] = None,
            dropdown: Optional[Dropdown] = None,
            combobox: Optional[Combobox] = None,
            slider: Optional[Slider] = None,
            spinbox: Optional[Spinbox] = None,
            date_picker: Optional[DatePicker] = None,
            color_picker: Optional[ColorPicker] = None,
            button: Optional[Button] = None,
            buttons: Optional[Buttons] = None,
            file_upload: Optional[FileUpload] = None,
            table: Optional[Table] = None,
            link: Optional[Link] = None,
            tabs: Optional[Tabs] = None,
            expander: Optional[Expander] = None,
            frame: Optional[Frame] = None,
            markup: Optional[Markup] = None,
            template: Optional[Template] = None,
            picker: Optional[Picker] = None,
            range_slider: Optional[RangeSlider] = None,
            stepper: Optional[Stepper] = None,
            visualization: Optional[Visualization] = None,
            vega_visualization: Optional[VegaVisualization] = None,
    ):
        self.text = text
        &#34;&#34;&#34;Text block.&#34;&#34;&#34;
        self.text_xl = text_xl
        &#34;&#34;&#34;Extra-large sized text block.&#34;&#34;&#34;
        self.text_l = text_l
        &#34;&#34;&#34;Large sized text block.&#34;&#34;&#34;
        self.text_m = text_m
        &#34;&#34;&#34;Medium sized text block.&#34;&#34;&#34;
        self.text_s = text_s
        &#34;&#34;&#34;Small sized text block.&#34;&#34;&#34;
        self.text_xs = text_xs
        &#34;&#34;&#34;Extra-small sized text block.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Label.&#34;&#34;&#34;
        self.separator = separator
        &#34;&#34;&#34;Separator.&#34;&#34;&#34;
        self.progress = progress
        &#34;&#34;&#34;Progress bar.&#34;&#34;&#34;
        self.message_bar = message_bar
        &#34;&#34;&#34;Message bar.&#34;&#34;&#34;
        self.textbox = textbox
        &#34;&#34;&#34;Textbox.&#34;&#34;&#34;
        self.checkbox = checkbox
        &#34;&#34;&#34;Checkbox.&#34;&#34;&#34;
        self.toggle = toggle
        &#34;&#34;&#34;Toggle.&#34;&#34;&#34;
        self.choice_group = choice_group
        &#34;&#34;&#34;Choice group.&#34;&#34;&#34;
        self.checklist = checklist
        &#34;&#34;&#34;Checklist.&#34;&#34;&#34;
        self.dropdown = dropdown
        &#34;&#34;&#34;Dropdown.&#34;&#34;&#34;
        self.combobox = combobox
        &#34;&#34;&#34;Combobox.&#34;&#34;&#34;
        self.slider = slider
        &#34;&#34;&#34;Slider.&#34;&#34;&#34;
        self.spinbox = spinbox
        &#34;&#34;&#34;Spinbox.&#34;&#34;&#34;
        self.date_picker = date_picker
        &#34;&#34;&#34;Date picker.&#34;&#34;&#34;
        self.color_picker = color_picker
        &#34;&#34;&#34;Color picker.&#34;&#34;&#34;
        self.button = button
        &#34;&#34;&#34;Button.&#34;&#34;&#34;
        self.buttons = buttons
        &#34;&#34;&#34;Button set.&#34;&#34;&#34;
        self.file_upload = file_upload
        &#34;&#34;&#34;File upload.&#34;&#34;&#34;
        self.table = table
        &#34;&#34;&#34;Table.&#34;&#34;&#34;
        self.link = link
        &#34;&#34;&#34;Link.&#34;&#34;&#34;
        self.tabs = tabs
        &#34;&#34;&#34;Tabs.&#34;&#34;&#34;
        self.expander = expander
        &#34;&#34;&#34;Expander.&#34;&#34;&#34;
        self.frame = frame
        &#34;&#34;&#34;Frame.&#34;&#34;&#34;
        self.markup = markup
        &#34;&#34;&#34;Markup&#34;&#34;&#34;
        self.template = template
        &#34;&#34;&#34;Template&#34;&#34;&#34;
        self.picker = picker
        &#34;&#34;&#34;Picker.&#34;&#34;&#34;
        self.range_slider = range_slider
        &#34;&#34;&#34;Range Slider.&#34;&#34;&#34;
        self.stepper = stepper
        &#34;&#34;&#34;Stepper.&#34;&#34;&#34;
        self.visualization = visualization
        &#34;&#34;&#34;Visualization.&#34;&#34;&#34;
        self.vega_visualization = vega_visualization
        &#34;&#34;&#34;Vega-lite Visualization.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        return _dump(
            text=None if self.text is None else self.text.dump(),
            text_xl=None if self.text_xl is None else self.text_xl.dump(),
            text_l=None if self.text_l is None else self.text_l.dump(),
            text_m=None if self.text_m is None else self.text_m.dump(),
            text_s=None if self.text_s is None else self.text_s.dump(),
            text_xs=None if self.text_xs is None else self.text_xs.dump(),
            label=None if self.label is None else self.label.dump(),
            separator=None if self.separator is None else self.separator.dump(),
            progress=None if self.progress is None else self.progress.dump(),
            message_bar=None if self.message_bar is None else self.message_bar.dump(),
            textbox=None if self.textbox is None else self.textbox.dump(),
            checkbox=None if self.checkbox is None else self.checkbox.dump(),
            toggle=None if self.toggle is None else self.toggle.dump(),
            choice_group=None if self.choice_group is None else self.choice_group.dump(),
            checklist=None if self.checklist is None else self.checklist.dump(),
            dropdown=None if self.dropdown is None else self.dropdown.dump(),
            combobox=None if self.combobox is None else self.combobox.dump(),
            slider=None if self.slider is None else self.slider.dump(),
            spinbox=None if self.spinbox is None else self.spinbox.dump(),
            date_picker=None if self.date_picker is None else self.date_picker.dump(),
            color_picker=None if self.color_picker is None else self.color_picker.dump(),
            button=None if self.button is None else self.button.dump(),
            buttons=None if self.buttons is None else self.buttons.dump(),
            file_upload=None if self.file_upload is None else self.file_upload.dump(),
            table=None if self.table is None else self.table.dump(),
            link=None if self.link is None else self.link.dump(),
            tabs=None if self.tabs is None else self.tabs.dump(),
            expander=None if self.expander is None else self.expander.dump(),
            frame=None if self.frame is None else self.frame.dump(),
            markup=None if self.markup is None else self.markup.dump(),
            template=None if self.template is None else self.template.dump(),
            picker=None if self.picker is None else self.picker.dump(),
            range_slider=None if self.range_slider is None else self.range_slider.dump(),
            stepper=None if self.stepper is None else self.stepper.dump(),
            visualization=None if self.visualization is None else self.visualization.dump(),
            vega_visualization=None if self.vega_visualization is None else self.vega_visualization.dump(),
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Component&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_text: Any = __d.get(&#39;text&#39;)
        __d_text_xl: Any = __d.get(&#39;text_xl&#39;)
        __d_text_l: Any = __d.get(&#39;text_l&#39;)
        __d_text_m: Any = __d.get(&#39;text_m&#39;)
        __d_text_s: Any = __d.get(&#39;text_s&#39;)
        __d_text_xs: Any = __d.get(&#39;text_xs&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_separator: Any = __d.get(&#39;separator&#39;)
        __d_progress: Any = __d.get(&#39;progress&#39;)
        __d_message_bar: Any = __d.get(&#39;message_bar&#39;)
        __d_textbox: Any = __d.get(&#39;textbox&#39;)
        __d_checkbox: Any = __d.get(&#39;checkbox&#39;)
        __d_toggle: Any = __d.get(&#39;toggle&#39;)
        __d_choice_group: Any = __d.get(&#39;choice_group&#39;)
        __d_checklist: Any = __d.get(&#39;checklist&#39;)
        __d_dropdown: Any = __d.get(&#39;dropdown&#39;)
        __d_combobox: Any = __d.get(&#39;combobox&#39;)
        __d_slider: Any = __d.get(&#39;slider&#39;)
        __d_spinbox: Any = __d.get(&#39;spinbox&#39;)
        __d_date_picker: Any = __d.get(&#39;date_picker&#39;)
        __d_color_picker: Any = __d.get(&#39;color_picker&#39;)
        __d_button: Any = __d.get(&#39;button&#39;)
        __d_buttons: Any = __d.get(&#39;buttons&#39;)
        __d_file_upload: Any = __d.get(&#39;file_upload&#39;)
        __d_table: Any = __d.get(&#39;table&#39;)
        __d_link: Any = __d.get(&#39;link&#39;)
        __d_tabs: Any = __d.get(&#39;tabs&#39;)
        __d_expander: Any = __d.get(&#39;expander&#39;)
        __d_frame: Any = __d.get(&#39;frame&#39;)
        __d_markup: Any = __d.get(&#39;markup&#39;)
        __d_template: Any = __d.get(&#39;template&#39;)
        __d_picker: Any = __d.get(&#39;picker&#39;)
        __d_range_slider: Any = __d.get(&#39;range_slider&#39;)
        __d_stepper: Any = __d.get(&#39;stepper&#39;)
        __d_visualization: Any = __d.get(&#39;visualization&#39;)
        __d_vega_visualization: Any = __d.get(&#39;vega_visualization&#39;)
        text: Optional[Text] = None if __d_text is None else Text.load(__d_text)
        text_xl: Optional[TextXl] = None if __d_text_xl is None else TextXl.load(__d_text_xl)
        text_l: Optional[TextL] = None if __d_text_l is None else TextL.load(__d_text_l)
        text_m: Optional[TextM] = None if __d_text_m is None else TextM.load(__d_text_m)
        text_s: Optional[TextS] = None if __d_text_s is None else TextS.load(__d_text_s)
        text_xs: Optional[TextXs] = None if __d_text_xs is None else TextXs.load(__d_text_xs)
        label: Optional[Label] = None if __d_label is None else Label.load(__d_label)
        separator: Optional[Separator] = None if __d_separator is None else Separator.load(__d_separator)
        progress: Optional[Progress] = None if __d_progress is None else Progress.load(__d_progress)
        message_bar: Optional[MessageBar] = None if __d_message_bar is None else MessageBar.load(__d_message_bar)
        textbox: Optional[Textbox] = None if __d_textbox is None else Textbox.load(__d_textbox)
        checkbox: Optional[Checkbox] = None if __d_checkbox is None else Checkbox.load(__d_checkbox)
        toggle: Optional[Toggle] = None if __d_toggle is None else Toggle.load(__d_toggle)
        choice_group: Optional[ChoiceGroup] = None if __d_choice_group is None else ChoiceGroup.load(__d_choice_group)
        checklist: Optional[Checklist] = None if __d_checklist is None else Checklist.load(__d_checklist)
        dropdown: Optional[Dropdown] = None if __d_dropdown is None else Dropdown.load(__d_dropdown)
        combobox: Optional[Combobox] = None if __d_combobox is None else Combobox.load(__d_combobox)
        slider: Optional[Slider] = None if __d_slider is None else Slider.load(__d_slider)
        spinbox: Optional[Spinbox] = None if __d_spinbox is None else Spinbox.load(__d_spinbox)
        date_picker: Optional[DatePicker] = None if __d_date_picker is None else DatePicker.load(__d_date_picker)
        color_picker: Optional[ColorPicker] = None if __d_color_picker is None else ColorPicker.load(__d_color_picker)
        button: Optional[Button] = None if __d_button is None else Button.load(__d_button)
        buttons: Optional[Buttons] = None if __d_buttons is None else Buttons.load(__d_buttons)
        file_upload: Optional[FileUpload] = None if __d_file_upload is None else FileUpload.load(__d_file_upload)
        table: Optional[Table] = None if __d_table is None else Table.load(__d_table)
        link: Optional[Link] = None if __d_link is None else Link.load(__d_link)
        tabs: Optional[Tabs] = None if __d_tabs is None else Tabs.load(__d_tabs)
        expander: Optional[Expander] = None if __d_expander is None else Expander.load(__d_expander)
        frame: Optional[Frame] = None if __d_frame is None else Frame.load(__d_frame)
        markup: Optional[Markup] = None if __d_markup is None else Markup.load(__d_markup)
        template: Optional[Template] = None if __d_template is None else Template.load(__d_template)
        picker: Optional[Picker] = None if __d_picker is None else Picker.load(__d_picker)
        range_slider: Optional[RangeSlider] = None if __d_range_slider is None else RangeSlider.load(__d_range_slider)
        stepper: Optional[Stepper] = None if __d_stepper is None else Stepper.load(__d_stepper)
        visualization: Optional[Visualization] = None if __d_visualization is None else Visualization.load(__d_visualization)
        vega_visualization: Optional[VegaVisualization] = None if __d_vega_visualization is None else VegaVisualization.load(__d_vega_visualization)
        return Component(
            text,
            text_xl,
            text_l,
            text_m,
            text_s,
            text_xs,
            label,
            separator,
            progress,
            message_bar,
            textbox,
            checkbox,
            toggle,
            choice_group,
            checklist,
            dropdown,
            combobox,
            slider,
            spinbox,
            date_picker,
            color_picker,
            button,
            buttons,
            file_upload,
            table,
            link,
            tabs,
            expander,
            frame,
            markup,
            template,
            picker,
            range_slider,
            stepper,
            visualization,
            vega_visualization,
        )


class FormCard:
    &#34;&#34;&#34;Create a form.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            items: Union[List[Component], str],
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.items = items
        &#34;&#34;&#34;The components in this form.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;FormCard.box is required.&#39;)
        if self.items is None:
            raise ValueError(&#39;FormCard.items is required.&#39;)
        return _dump(
            view=&#39;form&#39;,
            box=self.box,
            items=self.items if isinstance(self.items, str) else [__e.dump() for __e in self.items],
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;FormCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;FormCard.box is required.&#39;)
        __d_items: Any = __d.get(&#39;items&#39;)
        if __d_items is None:
            raise ValueError(&#39;FormCard.items is required.&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        items: Union[List[Component], str] = __d_items if isinstance(__d_items, str) else [Component.load(__e) for __e in __d_items]
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return FormCard(
            box,
            items,
            commands,
        )


class FrameCard:
    &#34;&#34;&#34;Render a card containing a HTML page inside an inline frame (an `iframe`).

    Either a path or content can be provided as arguments.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            path: Optional[str] = None,
            content: Optional[str] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The title for this card.&#34;&#34;&#34;
        self.path = path
        &#34;&#34;&#34;The path or URL of the web page, e.g. `/foo.html` or `http://example.com/foo.html`&#34;&#34;&#34;
        self.content = content
        &#34;&#34;&#34;The HTML content of the page. A string containing `&lt;html&gt;...&lt;/html&gt;`&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;FrameCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;FrameCard.title is required.&#39;)
        return _dump(
            view=&#39;frame&#39;,
            box=self.box,
            title=self.title,
            path=self.path,
            content=self.content,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;FrameCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;FrameCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;FrameCard.title is required.&#39;)
        __d_path: Any = __d.get(&#39;path&#39;)
        __d_content: Any = __d.get(&#39;content&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        path: Optional[str] = __d_path
        content: Optional[str] = __d_content
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return FrameCard(
            box,
            title,
            path,
            content,
            commands,
        )


class GraphicsCard:
    &#34;&#34;&#34;Create a card for displaying vector graphics.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            view_box: str,
            stage: Optional[PackedRecords] = None,
            scene: Optional[PackedData] = None,
            width: Optional[str] = None,
            height: Optional[str] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.view_box = view_box
        &#34;&#34;&#34;The position and dimension of the SVG viewport, in user space. A space-separated list of four numbers: min-x, min-y, width and height. For example, &#39;0 0 400 300&#39;. See: https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/viewBox&#34;&#34;&#34;
        self.stage = stage
        &#34;&#34;&#34;Background layer for rendering static SVG elements. Must be packed to conserve memory.&#34;&#34;&#34;
        self.scene = scene
        &#34;&#34;&#34;Foreground layer for rendering dynamic SVG elements.&#34;&#34;&#34;
        self.width = width
        &#34;&#34;&#34;The displayed width of the rectangular viewport. (Not the width of its coordinate system.)&#34;&#34;&#34;
        self.height = height
        &#34;&#34;&#34;The displayed height of the rectangular viewport. (Not the height of its coordinate system.)&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;GraphicsCard.box is required.&#39;)
        if self.view_box is None:
            raise ValueError(&#39;GraphicsCard.view_box is required.&#39;)
        return _dump(
            view=&#39;graphics&#39;,
            box=self.box,
            view_box=self.view_box,
            stage=self.stage,
            scene=self.scene,
            width=self.width,
            height=self.height,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;GraphicsCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;GraphicsCard.box is required.&#39;)
        __d_view_box: Any = __d.get(&#39;view_box&#39;)
        if __d_view_box is None:
            raise ValueError(&#39;GraphicsCard.view_box is required.&#39;)
        __d_stage: Any = __d.get(&#39;stage&#39;)
        __d_scene: Any = __d.get(&#39;scene&#39;)
        __d_width: Any = __d.get(&#39;width&#39;)
        __d_height: Any = __d.get(&#39;height&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        view_box: str = __d_view_box
        stage: Optional[PackedRecords] = __d_stage
        scene: Optional[PackedData] = __d_scene
        width: Optional[str] = __d_width
        height: Optional[str] = __d_height
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return GraphicsCard(
            box,
            view_box,
            stage,
            scene,
            width,
            height,
            commands,
        )


class GridCard:
    &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            cells: PackedData,
            data: PackedData,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.&#34;&#34;&#34;
        self.cells = cells
        &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;GridCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;GridCard.title is required.&#39;)
        if self.cells is None:
            raise ValueError(&#39;GridCard.cells is required.&#39;)
        if self.data is None:
            raise ValueError(&#39;GridCard.data is required.&#39;)
        return _dump(
            view=&#39;grid&#39;,
            box=self.box,
            title=self.title,
            cells=self.cells,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;GridCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;GridCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;GridCard.title is required.&#39;)
        __d_cells: Any = __d.get(&#39;cells&#39;)
        if __d_cells is None:
            raise ValueError(&#39;GridCard.cells is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        if __d_data is None:
            raise ValueError(&#39;GridCard.data is required.&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        cells: PackedData = __d_cells
        data: PackedData = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return GridCard(
            box,
            title,
            cells,
            data,
            commands,
        )


class HeaderCard:
    &#34;&#34;&#34;Render a card containing a HTML page inside an inline frame (iframe).

    Either a path or content can be provided as arguments.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            subtitle: str,
            icon: Optional[str] = None,
            icon_color: Optional[str] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The title.&#34;&#34;&#34;
        self.subtitle = subtitle
        &#34;&#34;&#34;The subtitle, displayed below the title.&#34;&#34;&#34;
        self.icon = icon
        &#34;&#34;&#34;The icon type, displayed to the left.&#34;&#34;&#34;
        self.icon_color = icon_color
        &#34;&#34;&#34;The icon&#39;s color.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;HeaderCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;HeaderCard.title is required.&#39;)
        if self.subtitle is None:
            raise ValueError(&#39;HeaderCard.subtitle is required.&#39;)
        return _dump(
            view=&#39;header&#39;,
            box=self.box,
            title=self.title,
            subtitle=self.subtitle,
            icon=self.icon,
            icon_color=self.icon_color,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;HeaderCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;HeaderCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;HeaderCard.title is required.&#39;)
        __d_subtitle: Any = __d.get(&#39;subtitle&#39;)
        if __d_subtitle is None:
            raise ValueError(&#39;HeaderCard.subtitle is required.&#39;)
        __d_icon: Any = __d.get(&#39;icon&#39;)
        __d_icon_color: Any = __d.get(&#39;icon_color&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        subtitle: str = __d_subtitle
        icon: Optional[str] = __d_icon
        icon_color: Optional[str] = __d_icon_color
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return HeaderCard(
            box,
            title,
            subtitle,
            icon,
            icon_color,
            commands,
        )


class ImageCard:
    &#34;&#34;&#34;Create a card that displays a base64-encoded image.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            type: str,
            image: str,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The card&#39;s title.&#34;&#34;&#34;
        self.type = type
        &#34;&#34;&#34;The image MIME subtype. One of `apng`, `bmp`, `gif`, `x-icon`, `jpeg`, `png`, `webp`.&#34;&#34;&#34;
        self.image = image
        &#34;&#34;&#34;Image data, base64-encoded.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;ImageCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;ImageCard.title is required.&#39;)
        if self.type is None:
            raise ValueError(&#39;ImageCard.type is required.&#39;)
        if self.image is None:
            raise ValueError(&#39;ImageCard.image is required.&#39;)
        return _dump(
            view=&#39;image&#39;,
            box=self.box,
            title=self.title,
            type=self.type,
            image=self.image,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;ImageCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;ImageCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;ImageCard.title is required.&#39;)
        __d_type: Any = __d.get(&#39;type&#39;)
        if __d_type is None:
            raise ValueError(&#39;ImageCard.type is required.&#39;)
        __d_image: Any = __d.get(&#39;image&#39;)
        if __d_image is None:
            raise ValueError(&#39;ImageCard.image is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        type: str = __d_type
        image: str = __d_image
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return ImageCard(
            box,
            title,
            type,
            image,
            data,
            commands,
        )


class LargeBarStatCard:
    &#34;&#34;&#34;Create a large captioned card displaying a primary value, an auxiliary value and a progress bar, with captions for each value.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            caption: str,
            value: str,
            aux_value: str,
            value_caption: str,
            aux_value_caption: str,
            progress: float,
            plot_color: Optional[str] = None,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The card&#39;s title.&#34;&#34;&#34;
        self.caption = caption
        &#34;&#34;&#34;The card&#39;s caption.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The primary value displayed.&#34;&#34;&#34;
        self.aux_value = aux_value
        &#34;&#34;&#34;The auxiliary value, typically a target value.&#34;&#34;&#34;
        self.value_caption = value_caption
        &#34;&#34;&#34;The caption displayed below the primary value.&#34;&#34;&#34;
        self.aux_value_caption = aux_value_caption
        &#34;&#34;&#34;The caption displayed below the auxiliary value.&#34;&#34;&#34;
        self.progress = progress
        &#34;&#34;&#34;The value of the progress bar, between 0 and 1.&#34;&#34;&#34;
        self.plot_color = plot_color
        &#34;&#34;&#34;The color of the progress bar.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;LargeBarStatCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;LargeBarStatCard.title is required.&#39;)
        if self.caption is None:
            raise ValueError(&#39;LargeBarStatCard.caption is required.&#39;)
        if self.value is None:
            raise ValueError(&#39;LargeBarStatCard.value is required.&#39;)
        if self.aux_value is None:
            raise ValueError(&#39;LargeBarStatCard.aux_value is required.&#39;)
        if self.value_caption is None:
            raise ValueError(&#39;LargeBarStatCard.value_caption is required.&#39;)
        if self.aux_value_caption is None:
            raise ValueError(&#39;LargeBarStatCard.aux_value_caption is required.&#39;)
        if self.progress is None:
            raise ValueError(&#39;LargeBarStatCard.progress is required.&#39;)
        return _dump(
            view=&#39;large_bar_stat&#39;,
            box=self.box,
            title=self.title,
            caption=self.caption,
            value=self.value,
            aux_value=self.aux_value,
            value_caption=self.value_caption,
            aux_value_caption=self.aux_value_caption,
            progress=self.progress,
            plot_color=self.plot_color,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;LargeBarStatCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;LargeBarStatCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;LargeBarStatCard.title is required.&#39;)
        __d_caption: Any = __d.get(&#39;caption&#39;)
        if __d_caption is None:
            raise ValueError(&#39;LargeBarStatCard.caption is required.&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        if __d_value is None:
            raise ValueError(&#39;LargeBarStatCard.value is required.&#39;)
        __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
        if __d_aux_value is None:
            raise ValueError(&#39;LargeBarStatCard.aux_value is required.&#39;)
        __d_value_caption: Any = __d.get(&#39;value_caption&#39;)
        if __d_value_caption is None:
            raise ValueError(&#39;LargeBarStatCard.value_caption is required.&#39;)
        __d_aux_value_caption: Any = __d.get(&#39;aux_value_caption&#39;)
        if __d_aux_value_caption is None:
            raise ValueError(&#39;LargeBarStatCard.aux_value_caption is required.&#39;)
        __d_progress: Any = __d.get(&#39;progress&#39;)
        if __d_progress is None:
            raise ValueError(&#39;LargeBarStatCard.progress is required.&#39;)
        __d_plot_color: Any = __d.get(&#39;plot_color&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        caption: str = __d_caption
        value: str = __d_value
        aux_value: str = __d_aux_value
        value_caption: str = __d_value_caption
        aux_value_caption: str = __d_aux_value_caption
        progress: float = __d_progress
        plot_color: Optional[str] = __d_plot_color
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return LargeBarStatCard(
            box,
            title,
            caption,
            value,
            aux_value,
            value_caption,
            aux_value_caption,
            progress,
            plot_color,
            data,
            commands,
        )


class LargeStatCard:
    &#34;&#34;&#34;Create a stat card displaying a primary value, an auxiliary value and a caption.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            value: str,
            aux_value: str,
            caption: str,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The card&#39;s title.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The primary value displayed.&#34;&#34;&#34;
        self.aux_value = aux_value
        &#34;&#34;&#34;The auxiliary value displayed next to the primary value.&#34;&#34;&#34;
        self.caption = caption
        &#34;&#34;&#34;The caption displayed below the primary value.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;LargeStatCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;LargeStatCard.title is required.&#39;)
        if self.value is None:
            raise ValueError(&#39;LargeStatCard.value is required.&#39;)
        if self.aux_value is None:
            raise ValueError(&#39;LargeStatCard.aux_value is required.&#39;)
        if self.caption is None:
            raise ValueError(&#39;LargeStatCard.caption is required.&#39;)
        return _dump(
            view=&#39;large_stat&#39;,
            box=self.box,
            title=self.title,
            value=self.value,
            aux_value=self.aux_value,
            caption=self.caption,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;LargeStatCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;LargeStatCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;LargeStatCard.title is required.&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        if __d_value is None:
            raise ValueError(&#39;LargeStatCard.value is required.&#39;)
        __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
        if __d_aux_value is None:
            raise ValueError(&#39;LargeStatCard.aux_value is required.&#39;)
        __d_caption: Any = __d.get(&#39;caption&#39;)
        if __d_caption is None:
            raise ValueError(&#39;LargeStatCard.caption is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        value: str = __d_value
        aux_value: str = __d_aux_value
        caption: str = __d_caption
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return LargeStatCard(
            box,
            title,
            value,
            aux_value,
            caption,
            data,
            commands,
        )


class ListCard:
    &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.
    Create a card containing other cards laid out in the form of a list (vertically, top-to-bottom).
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            item_view: str,
            item_props: PackedRecord,
            data: PackedData,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The title for this card.&#34;&#34;&#34;
        self.item_view = item_view
        &#34;&#34;&#34;The child card type.&#34;&#34;&#34;
        self.item_props = item_props
        &#34;&#34;&#34;The child card properties.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;ListCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;ListCard.title is required.&#39;)
        if self.item_view is None:
            raise ValueError(&#39;ListCard.item_view is required.&#39;)
        if self.item_props is None:
            raise ValueError(&#39;ListCard.item_props is required.&#39;)
        if self.data is None:
            raise ValueError(&#39;ListCard.data is required.&#39;)
        return _dump(
            view=&#39;list&#39;,
            box=self.box,
            title=self.title,
            item_view=self.item_view,
            item_props=self.item_props,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;ListCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;ListCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;ListCard.title is required.&#39;)
        __d_item_view: Any = __d.get(&#39;item_view&#39;)
        if __d_item_view is None:
            raise ValueError(&#39;ListCard.item_view is required.&#39;)
        __d_item_props: Any = __d.get(&#39;item_props&#39;)
        if __d_item_props is None:
            raise ValueError(&#39;ListCard.item_props is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        if __d_data is None:
            raise ValueError(&#39;ListCard.data is required.&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        item_view: str = __d_item_view
        item_props: PackedRecord = __d_item_props
        data: PackedData = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return ListCard(
            box,
            title,
            item_view,
            item_props,
            data,
            commands,
        )


class ListItem1Card:
    &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            caption: str,
            value: str,
            aux_value: str,
            data: PackedRecord,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.&#34;&#34;&#34;
        self.caption = caption
        &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.&#34;&#34;&#34;
        self.aux_value = aux_value
        &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;ListItem1Card.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;ListItem1Card.title is required.&#39;)
        if self.caption is None:
            raise ValueError(&#39;ListItem1Card.caption is required.&#39;)
        if self.value is None:
            raise ValueError(&#39;ListItem1Card.value is required.&#39;)
        if self.aux_value is None:
            raise ValueError(&#39;ListItem1Card.aux_value is required.&#39;)
        if self.data is None:
            raise ValueError(&#39;ListItem1Card.data is required.&#39;)
        return _dump(
            view=&#39;list_item1&#39;,
            box=self.box,
            title=self.title,
            caption=self.caption,
            value=self.value,
            aux_value=self.aux_value,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;ListItem1Card&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;ListItem1Card.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;ListItem1Card.title is required.&#39;)
        __d_caption: Any = __d.get(&#39;caption&#39;)
        if __d_caption is None:
            raise ValueError(&#39;ListItem1Card.caption is required.&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        if __d_value is None:
            raise ValueError(&#39;ListItem1Card.value is required.&#39;)
        __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
        if __d_aux_value is None:
            raise ValueError(&#39;ListItem1Card.aux_value is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        if __d_data is None:
            raise ValueError(&#39;ListItem1Card.data is required.&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        caption: str = __d_caption
        value: str = __d_value
        aux_value: str = __d_aux_value
        data: PackedRecord = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return ListItem1Card(
            box,
            title,
            caption,
            value,
            aux_value,
            data,
            commands,
        )


class MarkdownCard:
    &#34;&#34;&#34;Create a card that renders Markdown content.

    Github-flavored markdown is supported.
    HTML markup is allowed in markdown content.
    URLs, if found, are displayed as hyperlinks.
    Copyright, reserved, trademark, quotes, etc. are replaced with language-neutral symbols.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            content: str,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The title for this card.&#34;&#34;&#34;
        self.content = content
        &#34;&#34;&#34;The markdown content. Supports Github Flavored Markdown (GFM): https://guides.github.com/features/mastering-markdown/&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Additional data for the card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;MarkdownCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;MarkdownCard.title is required.&#39;)
        if self.content is None:
            raise ValueError(&#39;MarkdownCard.content is required.&#39;)
        return _dump(
            view=&#39;markdown&#39;,
            box=self.box,
            title=self.title,
            content=self.content,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;MarkdownCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;MarkdownCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;MarkdownCard.title is required.&#39;)
        __d_content: Any = __d.get(&#39;content&#39;)
        if __d_content is None:
            raise ValueError(&#39;MarkdownCard.content is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        content: str = __d_content
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return MarkdownCard(
            box,
            title,
            content,
            data,
            commands,
        )


class MarkupCard:
    &#34;&#34;&#34;Render HTML content.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            content: str,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The title for this card.&#34;&#34;&#34;
        self.content = content
        &#34;&#34;&#34;The HTML content.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;MarkupCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;MarkupCard.title is required.&#39;)
        if self.content is None:
            raise ValueError(&#39;MarkupCard.content is required.&#39;)
        return _dump(
            view=&#39;markup&#39;,
            box=self.box,
            title=self.title,
            content=self.content,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;MarkupCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;MarkupCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;MarkupCard.title is required.&#39;)
        __d_content: Any = __d.get(&#39;content&#39;)
        if __d_content is None:
            raise ValueError(&#39;MarkupCard.content is required.&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        content: str = __d_content
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return MarkupCard(
            box,
            title,
            content,
            commands,
        )


class MetaCard:
    &#34;&#34;&#34;Represents page-global state.

    This card is invisible.
    It is used to control attributes of the active page.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: Optional[str] = None,
            refresh: Optional[int] = None,
            notification: Optional[str] = None,
            redirect: Optional[str] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The title of the page.&#34;&#34;&#34;
        self.refresh = refresh
        &#34;&#34;&#34;Refresh rate in seconds. A value of 0 turns off live-updates. Values != 0 are currently ignored (reserved for future use).&#34;&#34;&#34;
        self.notification = notification
        &#34;&#34;&#34;Display a desktop notification to the user.&#34;&#34;&#34;
        self.redirect = redirect
        &#34;&#34;&#34;Redirect the page to a new URL.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;MetaCard.box is required.&#39;)
        return _dump(
            view=&#39;meta&#39;,
            box=self.box,
            title=self.title,
            refresh=self.refresh,
            notification=self.notification,
            redirect=self.redirect,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;MetaCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;MetaCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        __d_refresh: Any = __d.get(&#39;refresh&#39;)
        __d_notification: Any = __d.get(&#39;notification&#39;)
        __d_redirect: Any = __d.get(&#39;redirect&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: Optional[str] = __d_title
        refresh: Optional[int] = __d_refresh
        notification: Optional[str] = __d_notification
        redirect: Optional[str] = __d_redirect
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return MetaCard(
            box,
            title,
            refresh,
            notification,
            redirect,
            commands,
        )


class NavItem:
    &#34;&#34;&#34;Create a navigation item.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: str,
    ):
        self.name = name
        &#34;&#34;&#34;The name of this item. Prefix the name with a &#39;#&#39; to trigger hash-change navigation.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;The label to display.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;NavItem.name is required.&#39;)
        if self.label is None:
            raise ValueError(&#39;NavItem.label is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;NavItem&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;NavItem.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        if __d_label is None:
            raise ValueError(&#39;NavItem.label is required.&#39;)
        name: str = __d_name
        label: str = __d_label
        return NavItem(
            name,
            label,
        )


class NavGroup:
    &#34;&#34;&#34;Create a group of navigation items.
    &#34;&#34;&#34;
    def __init__(
            self,
            label: str,
            items: List[NavItem],
    ):
        self.label = label
        &#34;&#34;&#34;The label to display for this group.&#34;&#34;&#34;
        self.items = items
        &#34;&#34;&#34;The navigation items contained in this group.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.label is None:
            raise ValueError(&#39;NavGroup.label is required.&#39;)
        if self.items is None:
            raise ValueError(&#39;NavGroup.items is required.&#39;)
        return _dump(
            label=self.label,
            items=[__e.dump() for __e in self.items],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;NavGroup&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_label: Any = __d.get(&#39;label&#39;)
        if __d_label is None:
            raise ValueError(&#39;NavGroup.label is required.&#39;)
        __d_items: Any = __d.get(&#39;items&#39;)
        if __d_items is None:
            raise ValueError(&#39;NavGroup.items is required.&#39;)
        label: str = __d_label
        items: List[NavItem] = [NavItem.load(__e) for __e in __d_items]
        return NavGroup(
            label,
            items,
        )


class NavCard:
    &#34;&#34;&#34;Create a card containing a navigation pane.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            items: List[NavGroup],
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.items = items
        &#34;&#34;&#34;The navigation groups contained in this pane.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;NavCard.box is required.&#39;)
        if self.items is None:
            raise ValueError(&#39;NavCard.items is required.&#39;)
        return _dump(
            view=&#39;nav&#39;,
            box=self.box,
            items=[__e.dump() for __e in self.items],
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;NavCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;NavCard.box is required.&#39;)
        __d_items: Any = __d.get(&#39;items&#39;)
        if __d_items is None:
            raise ValueError(&#39;NavCard.items is required.&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        items: List[NavGroup] = [NavGroup.load(__e) for __e in __d_items]
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return NavCard(
            box,
            items,
            commands,
        )


class PixelArtCard:
    &#34;&#34;&#34;Create a card displaying a collaborative Pixel art tool, just for kicks.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            data: PackedRecord,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The title for this card.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;The data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;PixelArtCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;PixelArtCard.title is required.&#39;)
        if self.data is None:
            raise ValueError(&#39;PixelArtCard.data is required.&#39;)
        return _dump(
            view=&#39;pixel_art&#39;,
            box=self.box,
            title=self.title,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;PixelArtCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;PixelArtCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;PixelArtCard.title is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        if __d_data is None:
            raise ValueError(&#39;PixelArtCard.data is required.&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        data: PackedRecord = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return PixelArtCard(
            box,
            title,
            data,
            commands,
        )


class PlotCard:
    &#34;&#34;&#34;Create a card displaying a plot.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            data: PackedRecord,
            plot: Plot,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The title for this card.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.plot = plot
        &#34;&#34;&#34;The plot to be displayed in this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;PlotCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;PlotCard.title is required.&#39;)
        if self.data is None:
            raise ValueError(&#39;PlotCard.data is required.&#39;)
        if self.plot is None:
            raise ValueError(&#39;PlotCard.plot is required.&#39;)
        return _dump(
            view=&#39;plot&#39;,
            box=self.box,
            title=self.title,
            data=self.data,
            plot=self.plot.dump(),
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;PlotCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;PlotCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;PlotCard.title is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        if __d_data is None:
            raise ValueError(&#39;PlotCard.data is required.&#39;)
        __d_plot: Any = __d.get(&#39;plot&#39;)
        if __d_plot is None:
            raise ValueError(&#39;PlotCard.plot is required.&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        data: PackedRecord = __d_data
        plot: Plot = Plot.load(__d_plot)
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return PlotCard(
            box,
            title,
            data,
            plot,
            commands,
        )


class RepeatCard:
    &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.
    Create a card containing other cards.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            item_view: str,
            item_props: PackedRecord,
            data: PackedData,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.item_view = item_view
        &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.&#34;&#34;&#34;
        self.item_props = item_props
        &#34;&#34;&#34;The child card properties.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;RepeatCard.box is required.&#39;)
        if self.item_view is None:
            raise ValueError(&#39;RepeatCard.item_view is required.&#39;)
        if self.item_props is None:
            raise ValueError(&#39;RepeatCard.item_props is required.&#39;)
        if self.data is None:
            raise ValueError(&#39;RepeatCard.data is required.&#39;)
        return _dump(
            view=&#39;repeat&#39;,
            box=self.box,
            item_view=self.item_view,
            item_props=self.item_props,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;RepeatCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;RepeatCard.box is required.&#39;)
        __d_item_view: Any = __d.get(&#39;item_view&#39;)
        if __d_item_view is None:
            raise ValueError(&#39;RepeatCard.item_view is required.&#39;)
        __d_item_props: Any = __d.get(&#39;item_props&#39;)
        if __d_item_props is None:
            raise ValueError(&#39;RepeatCard.item_props is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        if __d_data is None:
            raise ValueError(&#39;RepeatCard.data is required.&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        item_view: str = __d_item_view
        item_props: PackedRecord = __d_item_props
        data: PackedData = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return RepeatCard(
            box,
            item_view,
            item_props,
            data,
            commands,
        )


class SmallSeriesStatCard:
    &#34;&#34;&#34;Create a small stat card displaying a primary value and a series plot.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            value: str,
            plot_data: PackedData,
            plot_value: str,
            plot_zero_value: Optional[float] = None,
            plot_category: Optional[str] = None,
            plot_type: Optional[str] = None,
            plot_curve: Optional[str] = None,
            plot_color: Optional[str] = None,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The card&#39;s title.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The primary value displayed.&#34;&#34;&#34;
        self.plot_data = plot_data
        &#34;&#34;&#34;The plot&#39;s data.&#34;&#34;&#34;
        self.plot_value = plot_value
        &#34;&#34;&#34;The data field to use for y-axis values.&#34;&#34;&#34;
        self.plot_zero_value = plot_zero_value
        &#34;&#34;&#34;The base value to use for each y-axis mark. Set this to `0` if you want to pin the x-axis at `y=0`. If not provided, the minimum value from the data is used.&#34;&#34;&#34;
        self.plot_category = plot_category
        &#34;&#34;&#34;The data field to use for x-axis values (ignored if `plot_type` is `area`; must be provided if `plot_type` is `interval`). Defaults to &#39;x&#39;.&#34;&#34;&#34;
        self.plot_type = plot_type
        &#34;&#34;&#34;The type of plot. Defaults to `area`. One of &#39;area&#39;, &#39;interval&#39;.&#34;&#34;&#34;
        self.plot_curve = plot_curve
        &#34;&#34;&#34;The plot&#39;s curve style. Defaults to `linear`. One of &#39;linear&#39;, &#39;smooth&#39;, &#39;step&#39;, &#39;step-after&#39;, &#39;step-before&#39;.&#34;&#34;&#34;
        self.plot_color = plot_color
        &#34;&#34;&#34;The plot&#39;s color.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;SmallSeriesStatCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;SmallSeriesStatCard.title is required.&#39;)
        if self.value is None:
            raise ValueError(&#39;SmallSeriesStatCard.value is required.&#39;)
        if self.plot_data is None:
            raise ValueError(&#39;SmallSeriesStatCard.plot_data is required.&#39;)
        if self.plot_value is None:
            raise ValueError(&#39;SmallSeriesStatCard.plot_value is required.&#39;)
        return _dump(
            view=&#39;small_series_stat&#39;,
            box=self.box,
            title=self.title,
            value=self.value,
            plot_data=self.plot_data,
            plot_value=self.plot_value,
            plot_zero_value=self.plot_zero_value,
            plot_category=self.plot_category,
            plot_type=self.plot_type,
            plot_curve=self.plot_curve,
            plot_color=self.plot_color,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;SmallSeriesStatCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;SmallSeriesStatCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;SmallSeriesStatCard.title is required.&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        if __d_value is None:
            raise ValueError(&#39;SmallSeriesStatCard.value is required.&#39;)
        __d_plot_data: Any = __d.get(&#39;plot_data&#39;)
        if __d_plot_data is None:
            raise ValueError(&#39;SmallSeriesStatCard.plot_data is required.&#39;)
        __d_plot_value: Any = __d.get(&#39;plot_value&#39;)
        if __d_plot_value is None:
            raise ValueError(&#39;SmallSeriesStatCard.plot_value is required.&#39;)
        __d_plot_zero_value: Any = __d.get(&#39;plot_zero_value&#39;)
        __d_plot_category: Any = __d.get(&#39;plot_category&#39;)
        __d_plot_type: Any = __d.get(&#39;plot_type&#39;)
        __d_plot_curve: Any = __d.get(&#39;plot_curve&#39;)
        __d_plot_color: Any = __d.get(&#39;plot_color&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        value: str = __d_value
        plot_data: PackedData = __d_plot_data
        plot_value: str = __d_plot_value
        plot_zero_value: Optional[float] = __d_plot_zero_value
        plot_category: Optional[str] = __d_plot_category
        plot_type: Optional[str] = __d_plot_type
        plot_curve: Optional[str] = __d_plot_curve
        plot_color: Optional[str] = __d_plot_color
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return SmallSeriesStatCard(
            box,
            title,
            value,
            plot_data,
            plot_value,
            plot_zero_value,
            plot_category,
            plot_type,
            plot_curve,
            plot_color,
            data,
            commands,
        )


class SmallStatCard:
    &#34;&#34;&#34;Create a stat card displaying a single value.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            value: str,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The card&#39;s title.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The primary value displayed.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;SmallStatCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;SmallStatCard.title is required.&#39;)
        if self.value is None:
            raise ValueError(&#39;SmallStatCard.value is required.&#39;)
        return _dump(
            view=&#39;small_stat&#39;,
            box=self.box,
            title=self.title,
            value=self.value,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;SmallStatCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;SmallStatCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;SmallStatCard.title is required.&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        if __d_value is None:
            raise ValueError(&#39;SmallStatCard.value is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        value: str = __d_value
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return SmallStatCard(
            box,
            title,
            value,
            data,
            commands,
        )


class TabCard:
    &#34;&#34;&#34;Create a card containing tabs for navigation.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            items: List[Tab],
            link: Optional[bool] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.items = items
        &#34;&#34;&#34;Items to render.&#34;&#34;&#34;
        self.link = link
        &#34;&#34;&#34;True if tabs should be rendered as links and not a standard tab.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;TabCard.box is required.&#39;)
        if self.items is None:
            raise ValueError(&#39;TabCard.items is required.&#39;)
        return _dump(
            view=&#39;tab&#39;,
            box=self.box,
            items=[__e.dump() for __e in self.items],
            link=self.link,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TabCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;TabCard.box is required.&#39;)
        __d_items: Any = __d.get(&#39;items&#39;)
        if __d_items is None:
            raise ValueError(&#39;TabCard.items is required.&#39;)
        __d_link: Any = __d.get(&#39;link&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        items: List[Tab] = [Tab.load(__e) for __e in __d_items]
        link: Optional[bool] = __d_link
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return TabCard(
            box,
            items,
            link,
            commands,
        )


class TallGaugeStatCard:
    &#34;&#34;&#34;Create a tall stat card displaying a primary value, an auxiliary value and a progress gauge.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            value: str,
            aux_value: str,
            progress: float,
            plot_color: Optional[str] = None,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The card&#39;s title.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The primary value displayed.&#34;&#34;&#34;
        self.aux_value = aux_value
        &#34;&#34;&#34;The auxiliary value displayed next to the primary value.&#34;&#34;&#34;
        self.progress = progress
        &#34;&#34;&#34;The value of the progress gauge, between 0 and 1.&#34;&#34;&#34;
        self.plot_color = plot_color
        &#34;&#34;&#34;The color of the progress gauge.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;TallGaugeStatCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;TallGaugeStatCard.title is required.&#39;)
        if self.value is None:
            raise ValueError(&#39;TallGaugeStatCard.value is required.&#39;)
        if self.aux_value is None:
            raise ValueError(&#39;TallGaugeStatCard.aux_value is required.&#39;)
        if self.progress is None:
            raise ValueError(&#39;TallGaugeStatCard.progress is required.&#39;)
        return _dump(
            view=&#39;tall_gauge_stat&#39;,
            box=self.box,
            title=self.title,
            value=self.value,
            aux_value=self.aux_value,
            progress=self.progress,
            plot_color=self.plot_color,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TallGaugeStatCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;TallGaugeStatCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;TallGaugeStatCard.title is required.&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        if __d_value is None:
            raise ValueError(&#39;TallGaugeStatCard.value is required.&#39;)
        __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
        if __d_aux_value is None:
            raise ValueError(&#39;TallGaugeStatCard.aux_value is required.&#39;)
        __d_progress: Any = __d.get(&#39;progress&#39;)
        if __d_progress is None:
            raise ValueError(&#39;TallGaugeStatCard.progress is required.&#39;)
        __d_plot_color: Any = __d.get(&#39;plot_color&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        value: str = __d_value
        aux_value: str = __d_aux_value
        progress: float = __d_progress
        plot_color: Optional[str] = __d_plot_color
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return TallGaugeStatCard(
            box,
            title,
            value,
            aux_value,
            progress,
            plot_color,
            data,
            commands,
        )


class TallSeriesStatCard:
    &#34;&#34;&#34;Create a tall stat card displaying a primary value, an auxiliary value and a series plot.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            value: str,
            aux_value: str,
            plot_data: PackedData,
            plot_value: str,
            plot_zero_value: Optional[float] = None,
            plot_category: Optional[str] = None,
            plot_type: Optional[str] = None,
            plot_curve: Optional[str] = None,
            plot_color: Optional[str] = None,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The card&#39;s title.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The primary value displayed.&#34;&#34;&#34;
        self.aux_value = aux_value
        &#34;&#34;&#34;The auxiliary value displayed below the primary value.&#34;&#34;&#34;
        self.plot_data = plot_data
        &#34;&#34;&#34;The plot&#39;s data.&#34;&#34;&#34;
        self.plot_value = plot_value
        &#34;&#34;&#34;The data field to use for y-axis values.&#34;&#34;&#34;
        self.plot_zero_value = plot_zero_value
        &#34;&#34;&#34;The base value to use for each y-axis mark. Set this to `0` if you want to pin the x-axis at `y=0`. If not provided, the minimum value from the data is used.&#34;&#34;&#34;
        self.plot_category = plot_category
        &#34;&#34;&#34;The data field to use for x-axis values (ignored if `plot_type` is `area`; must be provided if `plot_type` is `interval`). Defaults to &#39;x&#39;.&#34;&#34;&#34;
        self.plot_type = plot_type
        &#34;&#34;&#34;The type of plot. Defaults to `area`. One of &#39;area&#39;, &#39;interval&#39;.&#34;&#34;&#34;
        self.plot_curve = plot_curve
        &#34;&#34;&#34;The plot&#39;s curve style. Defaults to `linear`. One of &#39;linear&#39;, &#39;smooth&#39;, &#39;step&#39;, &#39;step-after&#39;, &#39;step-before&#39;.&#34;&#34;&#34;
        self.plot_color = plot_color
        &#34;&#34;&#34;The plot&#39;s color.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;TallSeriesStatCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;TallSeriesStatCard.title is required.&#39;)
        if self.value is None:
            raise ValueError(&#39;TallSeriesStatCard.value is required.&#39;)
        if self.aux_value is None:
            raise ValueError(&#39;TallSeriesStatCard.aux_value is required.&#39;)
        if self.plot_data is None:
            raise ValueError(&#39;TallSeriesStatCard.plot_data is required.&#39;)
        if self.plot_value is None:
            raise ValueError(&#39;TallSeriesStatCard.plot_value is required.&#39;)
        return _dump(
            view=&#39;tall_series_stat&#39;,
            box=self.box,
            title=self.title,
            value=self.value,
            aux_value=self.aux_value,
            plot_data=self.plot_data,
            plot_value=self.plot_value,
            plot_zero_value=self.plot_zero_value,
            plot_category=self.plot_category,
            plot_type=self.plot_type,
            plot_curve=self.plot_curve,
            plot_color=self.plot_color,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TallSeriesStatCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;TallSeriesStatCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;TallSeriesStatCard.title is required.&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        if __d_value is None:
            raise ValueError(&#39;TallSeriesStatCard.value is required.&#39;)
        __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
        if __d_aux_value is None:
            raise ValueError(&#39;TallSeriesStatCard.aux_value is required.&#39;)
        __d_plot_data: Any = __d.get(&#39;plot_data&#39;)
        if __d_plot_data is None:
            raise ValueError(&#39;TallSeriesStatCard.plot_data is required.&#39;)
        __d_plot_value: Any = __d.get(&#39;plot_value&#39;)
        if __d_plot_value is None:
            raise ValueError(&#39;TallSeriesStatCard.plot_value is required.&#39;)
        __d_plot_zero_value: Any = __d.get(&#39;plot_zero_value&#39;)
        __d_plot_category: Any = __d.get(&#39;plot_category&#39;)
        __d_plot_type: Any = __d.get(&#39;plot_type&#39;)
        __d_plot_curve: Any = __d.get(&#39;plot_curve&#39;)
        __d_plot_color: Any = __d.get(&#39;plot_color&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        value: str = __d_value
        aux_value: str = __d_aux_value
        plot_data: PackedData = __d_plot_data
        plot_value: str = __d_plot_value
        plot_zero_value: Optional[float] = __d_plot_zero_value
        plot_category: Optional[str] = __d_plot_category
        plot_type: Optional[str] = __d_plot_type
        plot_curve: Optional[str] = __d_plot_curve
        plot_color: Optional[str] = __d_plot_color
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return TallSeriesStatCard(
            box,
            title,
            value,
            aux_value,
            plot_data,
            plot_value,
            plot_zero_value,
            plot_category,
            plot_type,
            plot_curve,
            plot_color,
            data,
            commands,
        )


class TemplateCard:
    &#34;&#34;&#34;Render dynamic content using a HTML template.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            content: str,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The title for this card.&#34;&#34;&#34;
        self.content = content
        &#34;&#34;&#34;The Handlebars template. https://handlebarsjs.com/guide/&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for the Handlebars template&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;TemplateCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;TemplateCard.title is required.&#39;)
        if self.content is None:
            raise ValueError(&#39;TemplateCard.content is required.&#39;)
        return _dump(
            view=&#39;template&#39;,
            box=self.box,
            title=self.title,
            content=self.content,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TemplateCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;TemplateCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;TemplateCard.title is required.&#39;)
        __d_content: Any = __d.get(&#39;content&#39;)
        if __d_content is None:
            raise ValueError(&#39;TemplateCard.content is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        content: str = __d_content
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return TemplateCard(
            box,
            title,
            content,
            data,
            commands,
        )


class ToolbarCard:
    &#34;&#34;&#34;Create a card containing a toolbar.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            items: List[Command],
            secondary_items: Optional[List[Command]] = None,
            overflow_items: Optional[List[Command]] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.items = items
        &#34;&#34;&#34;Items to render.&#34;&#34;&#34;
        self.secondary_items = secondary_items
        &#34;&#34;&#34;Items to render on the right side (or left, in RTL).&#34;&#34;&#34;
        self.overflow_items = overflow_items
        &#34;&#34;&#34;Items to render in an overflow menu.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;ToolbarCard.box is required.&#39;)
        if self.items is None:
            raise ValueError(&#39;ToolbarCard.items is required.&#39;)
        return _dump(
            view=&#39;toolbar&#39;,
            box=self.box,
            items=[__e.dump() for __e in self.items],
            secondary_items=None if self.secondary_items is None else [__e.dump() for __e in self.secondary_items],
            overflow_items=None if self.overflow_items is None else [__e.dump() for __e in self.overflow_items],
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;ToolbarCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;ToolbarCard.box is required.&#39;)
        __d_items: Any = __d.get(&#39;items&#39;)
        if __d_items is None:
            raise ValueError(&#39;ToolbarCard.items is required.&#39;)
        __d_secondary_items: Any = __d.get(&#39;secondary_items&#39;)
        __d_overflow_items: Any = __d.get(&#39;overflow_items&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        items: List[Command] = [Command.load(__e) for __e in __d_items]
        secondary_items: Optional[List[Command]] = None if __d_secondary_items is None else [Command.load(__e) for __e in __d_secondary_items]
        overflow_items: Optional[List[Command]] = None if __d_overflow_items is None else [Command.load(__e) for __e in __d_overflow_items]
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return ToolbarCard(
            box,
            items,
            secondary_items,
            overflow_items,
            commands,
        )


class VegaCard:
    &#34;&#34;&#34;Create a card containing a Vega-lite plot.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            specification: str,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The title of this card.&#34;&#34;&#34;
        self.specification = specification
        &#34;&#34;&#34;The Vega-lite specification.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for the plot, if any.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;VegaCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;VegaCard.title is required.&#39;)
        if self.specification is None:
            raise ValueError(&#39;VegaCard.specification is required.&#39;)
        return _dump(
            view=&#39;vega&#39;,
            box=self.box,
            title=self.title,
            specification=self.specification,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;VegaCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;VegaCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;VegaCard.title is required.&#39;)
        __d_specification: Any = __d.get(&#39;specification&#39;)
        if __d_specification is None:
            raise ValueError(&#39;VegaCard.specification is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        specification: str = __d_specification
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return VegaCard(
            box,
            title,
            specification,
            data,
            commands,
        )


class WideBarStatCard:
    &#34;&#34;&#34;Create a wide stat card displaying a primary value, an auxiliary value and a progress bar.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            value: str,
            aux_value: str,
            progress: float,
            plot_color: Optional[str] = None,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The card&#39;s title.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The primary value displayed.&#34;&#34;&#34;
        self.aux_value = aux_value
        &#34;&#34;&#34;The auxiliary value displayed next to the primary value.&#34;&#34;&#34;
        self.progress = progress
        &#34;&#34;&#34;The value of the progress bar, between 0 and 1.&#34;&#34;&#34;
        self.plot_color = plot_color
        &#34;&#34;&#34;The color of the progress bar.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;WideBarStatCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;WideBarStatCard.title is required.&#39;)
        if self.value is None:
            raise ValueError(&#39;WideBarStatCard.value is required.&#39;)
        if self.aux_value is None:
            raise ValueError(&#39;WideBarStatCard.aux_value is required.&#39;)
        if self.progress is None:
            raise ValueError(&#39;WideBarStatCard.progress is required.&#39;)
        return _dump(
            view=&#39;wide_bar_stat&#39;,
            box=self.box,
            title=self.title,
            value=self.value,
            aux_value=self.aux_value,
            progress=self.progress,
            plot_color=self.plot_color,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;WideBarStatCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;WideBarStatCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;WideBarStatCard.title is required.&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        if __d_value is None:
            raise ValueError(&#39;WideBarStatCard.value is required.&#39;)
        __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
        if __d_aux_value is None:
            raise ValueError(&#39;WideBarStatCard.aux_value is required.&#39;)
        __d_progress: Any = __d.get(&#39;progress&#39;)
        if __d_progress is None:
            raise ValueError(&#39;WideBarStatCard.progress is required.&#39;)
        __d_plot_color: Any = __d.get(&#39;plot_color&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        value: str = __d_value
        aux_value: str = __d_aux_value
        progress: float = __d_progress
        plot_color: Optional[str] = __d_plot_color
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return WideBarStatCard(
            box,
            title,
            value,
            aux_value,
            progress,
            plot_color,
            data,
            commands,
        )


class WideGaugeStatCard:
    &#34;&#34;&#34;Create a wide stat card displaying a primary value, an auxiliary value and a progress gauge.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            value: str,
            aux_value: str,
            progress: float,
            plot_color: Optional[str] = None,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The card&#39;s title.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The primary value displayed.&#34;&#34;&#34;
        self.aux_value = aux_value
        &#34;&#34;&#34;The auxiliary value displayed next to the primary value.&#34;&#34;&#34;
        self.progress = progress
        &#34;&#34;&#34;The value of the progress gauge, between 0 and 1.&#34;&#34;&#34;
        self.plot_color = plot_color
        &#34;&#34;&#34;The color of the progress gauge.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;WideGaugeStatCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;WideGaugeStatCard.title is required.&#39;)
        if self.value is None:
            raise ValueError(&#39;WideGaugeStatCard.value is required.&#39;)
        if self.aux_value is None:
            raise ValueError(&#39;WideGaugeStatCard.aux_value is required.&#39;)
        if self.progress is None:
            raise ValueError(&#39;WideGaugeStatCard.progress is required.&#39;)
        return _dump(
            view=&#39;wide_gauge_stat&#39;,
            box=self.box,
            title=self.title,
            value=self.value,
            aux_value=self.aux_value,
            progress=self.progress,
            plot_color=self.plot_color,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;WideGaugeStatCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;WideGaugeStatCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;WideGaugeStatCard.title is required.&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        if __d_value is None:
            raise ValueError(&#39;WideGaugeStatCard.value is required.&#39;)
        __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
        if __d_aux_value is None:
            raise ValueError(&#39;WideGaugeStatCard.aux_value is required.&#39;)
        __d_progress: Any = __d.get(&#39;progress&#39;)
        if __d_progress is None:
            raise ValueError(&#39;WideGaugeStatCard.progress is required.&#39;)
        __d_plot_color: Any = __d.get(&#39;plot_color&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        value: str = __d_value
        aux_value: str = __d_aux_value
        progress: float = __d_progress
        plot_color: Optional[str] = __d_plot_color
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return WideGaugeStatCard(
            box,
            title,
            value,
            aux_value,
            progress,
            plot_color,
            data,
            commands,
        )


class WideSeriesStatCard:
    &#34;&#34;&#34;Create a wide stat card displaying a primary value, an auxiliary value and a series plot.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            value: str,
            aux_value: str,
            plot_data: PackedData,
            plot_value: str,
            plot_zero_value: Optional[float] = None,
            plot_category: Optional[str] = None,
            plot_type: Optional[str] = None,
            plot_curve: Optional[str] = None,
            plot_color: Optional[str] = None,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The card&#39;s title.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The primary value displayed.&#34;&#34;&#34;
        self.aux_value = aux_value
        &#34;&#34;&#34;The auxiliary value displayed below the primary value.&#34;&#34;&#34;
        self.plot_data = plot_data
        &#34;&#34;&#34;The plot&#39;s data.&#34;&#34;&#34;
        self.plot_value = plot_value
        &#34;&#34;&#34;The data field to use for y-axis values.&#34;&#34;&#34;
        self.plot_zero_value = plot_zero_value
        &#34;&#34;&#34;The base value to use for each y-axis mark. Set this to `0` if you want to pin the x-axis at `y=0`. If not provided, the minimum value from the data is used.&#34;&#34;&#34;
        self.plot_category = plot_category
        &#34;&#34;&#34;The data field to use for x-axis values (ignored if `plot_type` is `area`; must be provided if `plot_type` is `interval`). Defaults to &#39;x&#39;.&#34;&#34;&#34;
        self.plot_type = plot_type
        &#34;&#34;&#34;The type of plot. Defaults to `area`. One of &#39;area&#39;, &#39;interval&#39;.&#34;&#34;&#34;
        self.plot_curve = plot_curve
        &#34;&#34;&#34;The plot&#39;s curve style. Defaults to `linear`. One of &#39;linear&#39;, &#39;smooth&#39;, &#39;step&#39;, &#39;step-after&#39;, &#39;step-before&#39;.&#34;&#34;&#34;
        self.plot_color = plot_color
        &#34;&#34;&#34;The plot&#39;s color.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;WideSeriesStatCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;WideSeriesStatCard.title is required.&#39;)
        if self.value is None:
            raise ValueError(&#39;WideSeriesStatCard.value is required.&#39;)
        if self.aux_value is None:
            raise ValueError(&#39;WideSeriesStatCard.aux_value is required.&#39;)
        if self.plot_data is None:
            raise ValueError(&#39;WideSeriesStatCard.plot_data is required.&#39;)
        if self.plot_value is None:
            raise ValueError(&#39;WideSeriesStatCard.plot_value is required.&#39;)
        return _dump(
            view=&#39;wide_series_stat&#39;,
            box=self.box,
            title=self.title,
            value=self.value,
            aux_value=self.aux_value,
            plot_data=self.plot_data,
            plot_value=self.plot_value,
            plot_zero_value=self.plot_zero_value,
            plot_category=self.plot_category,
            plot_type=self.plot_type,
            plot_curve=self.plot_curve,
            plot_color=self.plot_color,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;WideSeriesStatCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;WideSeriesStatCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;WideSeriesStatCard.title is required.&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        if __d_value is None:
            raise ValueError(&#39;WideSeriesStatCard.value is required.&#39;)
        __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
        if __d_aux_value is None:
            raise ValueError(&#39;WideSeriesStatCard.aux_value is required.&#39;)
        __d_plot_data: Any = __d.get(&#39;plot_data&#39;)
        if __d_plot_data is None:
            raise ValueError(&#39;WideSeriesStatCard.plot_data is required.&#39;)
        __d_plot_value: Any = __d.get(&#39;plot_value&#39;)
        if __d_plot_value is None:
            raise ValueError(&#39;WideSeriesStatCard.plot_value is required.&#39;)
        __d_plot_zero_value: Any = __d.get(&#39;plot_zero_value&#39;)
        __d_plot_category: Any = __d.get(&#39;plot_category&#39;)
        __d_plot_type: Any = __d.get(&#39;plot_type&#39;)
        __d_plot_curve: Any = __d.get(&#39;plot_curve&#39;)
        __d_plot_color: Any = __d.get(&#39;plot_color&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        value: str = __d_value
        aux_value: str = __d_aux_value
        plot_data: PackedData = __d_plot_data
        plot_value: str = __d_plot_value
        plot_zero_value: Optional[float] = __d_plot_zero_value
        plot_category: Optional[str] = __d_plot_category
        plot_type: Optional[str] = __d_plot_type
        plot_curve: Optional[str] = __d_plot_curve
        plot_color: Optional[str] = __d_plot_color
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return WideSeriesStatCard(
            box,
            title,
            value,
            aux_value,
            plot_data,
            plot_value,
            plot_zero_value,
            plot_category,
            plot_type,
            plot_curve,
            plot_color,
            data,
            commands,
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="h2o_q.types.Breadcrumb"><code class="flex name class">
<span>class <span class="ident">Breadcrumb</span></span>
<span>(</span><span>name: str, label: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a breadcrumb for a <code><a title="h2o_q.types.BreadcrumbsCard" href="#h2o_q.types.BreadcrumbsCard">BreadcrumbsCard</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Breadcrumb:
    &#34;&#34;&#34;Create a breadcrumb for a `h2o_q.types.BreadcrumbsCard()`.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: str,
    ):
        self.name = name
        &#34;&#34;&#34;The name of this item. Prefix the name with a &#39;#&#39; to trigger hash-change navigation.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;The label to display.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Breadcrumb.name is required.&#39;)
        if self.label is None:
            raise ValueError(&#39;Breadcrumb.label is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Breadcrumb&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Breadcrumb.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        if __d_label is None:
            raise ValueError(&#39;Breadcrumb.label is required.&#39;)
        name: str = __d_name
        label: str = __d_label
        return Breadcrumb(
            name,
            label,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Breadcrumb.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Breadcrumb__d: Dict) ‑> <a title="h2o_q.types.Breadcrumb" href="#h2o_q.types.Breadcrumb">Breadcrumb</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Breadcrumb&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;Breadcrumb.name is required.&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    if __d_label is None:
        raise ValueError(&#39;Breadcrumb.label is required.&#39;)
    name: str = __d_name
    label: str = __d_label
    return Breadcrumb(
        name,
        label,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Breadcrumb.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>The label to display.</p></div>
</dd>
<dt id="h2o_q.types.Breadcrumb.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>The name of this item. Prefix the name with a '#' to trigger hash-change navigation.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Breadcrumb.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;Breadcrumb.name is required.&#39;)
    if self.label is None:
        raise ValueError(&#39;Breadcrumb.label is required.&#39;)
    return _dump(
        name=self.name,
        label=self.label,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.BreadcrumbsCard"><code class="flex name class">
<span>class <span class="ident">BreadcrumbsCard</span></span>
<span>(</span><span>box: str, items: List[<a title="h2o_q.types.Breadcrumb" href="#h2o_q.types.Breadcrumb">Breadcrumb</a>], commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a card containing breadcrumbs.
Breadcrumbs should be used as a navigational aid in your app or site.
They indicate the current page’s location within a hierarchy and help
the user understand where they are in relation to the rest of that hierarchy.
They also afford one-click access to higher levels of that hierarchy.
Breadcrumbs are typically placed, in horizontal form, under the masthead
or navigation of an experience, above the primary content area.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BreadcrumbsCard:
    &#34;&#34;&#34;Create a card containing breadcrumbs.
    Breadcrumbs should be used as a navigational aid in your app or site.
    They indicate the current page’s location within a hierarchy and help
    the user understand where they are in relation to the rest of that hierarchy.
    They also afford one-click access to higher levels of that hierarchy.
    Breadcrumbs are typically placed, in horizontal form, under the masthead
    or navigation of an experience, above the primary content area.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            items: List[Breadcrumb],
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.items = items
        &#34;&#34;&#34;A list of `h2o_q.types.Breadcrumb` instances to display. See `h2o_q.ui.breadcrumb()`&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;BreadcrumbsCard.box is required.&#39;)
        if self.items is None:
            raise ValueError(&#39;BreadcrumbsCard.items is required.&#39;)
        return _dump(
            view=&#39;breadcrumbs&#39;,
            box=self.box,
            items=[__e.dump() for __e in self.items],
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;BreadcrumbsCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;BreadcrumbsCard.box is required.&#39;)
        __d_items: Any = __d.get(&#39;items&#39;)
        if __d_items is None:
            raise ValueError(&#39;BreadcrumbsCard.items is required.&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        items: List[Breadcrumb] = [Breadcrumb.load(__e) for __e in __d_items]
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return BreadcrumbsCard(
            box,
            items,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.BreadcrumbsCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_BreadcrumbsCard__d: Dict) ‑> <a title="h2o_q.types.BreadcrumbsCard" href="#h2o_q.types.BreadcrumbsCard">BreadcrumbsCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;BreadcrumbsCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;BreadcrumbsCard.box is required.&#39;)
    __d_items: Any = __d.get(&#39;items&#39;)
    if __d_items is None:
        raise ValueError(&#39;BreadcrumbsCard.items is required.&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    items: List[Breadcrumb] = [Breadcrumb.load(__e) for __e in __d_items]
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return BreadcrumbsCard(
        box,
        items,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.BreadcrumbsCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.BreadcrumbsCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.BreadcrumbsCard.items"><code class="name">var <span class="ident">items</span></code></dt>
<dd>
<div class="desc"><p>A list of <code><a title="h2o_q.types.Breadcrumb" href="#h2o_q.types.Breadcrumb">Breadcrumb</a></code> instances to display. See <code><a title="h2o_q.ui.breadcrumb" href="ui.html#h2o_q.ui.breadcrumb">breadcrumb()</a></code></p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.BreadcrumbsCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;BreadcrumbsCard.box is required.&#39;)
    if self.items is None:
        raise ValueError(&#39;BreadcrumbsCard.items is required.&#39;)
    return _dump(
        view=&#39;breadcrumbs&#39;,
        box=self.box,
        items=[__e.dump() for __e in self.items],
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Button"><code class="flex name class">
<span>class <span class="ident">Button</span></span>
<span>(</span><span>name: str, label: Union[str, NoneType] = None, caption: Union[str, NoneType] = None, value: Union[str, NoneType] = None, primary: Union[bool, NoneType] = None, disabled: Union[bool, NoneType] = None, link: Union[bool, NoneType] = None, tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a button.</p>
<p>Buttons are best used to enable a user to commit a change or complete steps in a task.
They are typically found inside forms, dialogs, panels or pages.
An example of their usage is confirming the deletion of a file in a confirmation dialog.</p>
<p>When considering their place in a layout, contemplate the order in which a user will flow through the UI.
As an example, in a form, the individual will need to read and interact with the form fields before submitting
the form. Therefore, as a general rule, the button should be placed at the bottom of the UI container
which holds the related UI elements.</p>
<p>Buttons may be placed within a "buttons" component which will lay out the buttons horizontally, or used
individually and they will be stacked vertically.</p>
<p>While buttons can technically be used to navigate a user to another part of the experience, this is not
recommended unless that navigation is part of an action or their flow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Button:
    &#34;&#34;&#34;Create a button.

    Buttons are best used to enable a user to commit a change or complete steps in a task.
    They are typically found inside forms, dialogs, panels or pages.
    An example of their usage is confirming the deletion of a file in a confirmation dialog.

    When considering their place in a layout, contemplate the order in which a user will flow through the UI.
    As an example, in a form, the individual will need to read and interact with the form fields before submitting
    the form. Therefore, as a general rule, the button should be placed at the bottom of the UI container
    which holds the related UI elements.

    Buttons may be placed within a &#34;buttons&#34; component which will lay out the buttons horizontally, or used
    individually and they will be stacked vertically.

    While buttons can technically be used to navigate a user to another part of the experience, this is not
    recommended unless that navigation is part of an action or their flow.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            caption: Optional[str] = None,
            value: Optional[str] = None,
            primary: Optional[bool] = None,
            disabled: Optional[bool] = None,
            link: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component. If the name is prefixed with a &#39;#&#39;, the button sets the location hash to the name when clicked.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;The text displayed on the button.&#34;&#34;&#34;
        self.caption = caption
        &#34;&#34;&#34;The caption displayed below the label. Setting a caption renders a compound button.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;A value for this button. If a value is set, it is used for the button&#39;s submitted instead of a boolean True.&#34;&#34;&#34;
        self.primary = primary
        &#34;&#34;&#34;True if the button should be rendered as the primary button in the set.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if the button should be disabled.&#34;&#34;&#34;
        self.link = link
        &#34;&#34;&#34;True if the button should be rendered as link text and not a standard button.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Button.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            caption=self.caption,
            value=self.value,
            primary=self.primary,
            disabled=self.disabled,
            link=self.link,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Button&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Button.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_caption: Any = __d.get(&#39;caption&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_primary: Any = __d.get(&#39;primary&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_link: Any = __d.get(&#39;link&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        caption: Optional[str] = __d_caption
        value: Optional[str] = __d_value
        primary: Optional[bool] = __d_primary
        disabled: Optional[bool] = __d_disabled
        link: Optional[bool] = __d_link
        tooltip: Optional[str] = __d_tooltip
        return Button(
            name,
            label,
            caption,
            value,
            primary,
            disabled,
            link,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Button.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Button__d: Dict) ‑> <a title="h2o_q.types.Button" href="#h2o_q.types.Button">Button</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Button&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;Button.name is required.&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    __d_caption: Any = __d.get(&#39;caption&#39;)
    __d_value: Any = __d.get(&#39;value&#39;)
    __d_primary: Any = __d.get(&#39;primary&#39;)
    __d_disabled: Any = __d.get(&#39;disabled&#39;)
    __d_link: Any = __d.get(&#39;link&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    name: str = __d_name
    label: Optional[str] = __d_label
    caption: Optional[str] = __d_caption
    value: Optional[str] = __d_value
    primary: Optional[bool] = __d_primary
    disabled: Optional[bool] = __d_disabled
    link: Optional[bool] = __d_link
    tooltip: Optional[str] = __d_tooltip
    return Button(
        name,
        label,
        caption,
        value,
        primary,
        disabled,
        link,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Button.caption"><code class="name">var <span class="ident">caption</span></code></dt>
<dd>
<div class="desc"><p>The caption displayed below the label. Setting a caption renders a compound button.</p></div>
</dd>
<dt id="h2o_q.types.Button.disabled"><code class="name">var <span class="ident">disabled</span></code></dt>
<dd>
<div class="desc"><p>True if the button should be disabled.</p></div>
</dd>
<dt id="h2o_q.types.Button.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>The text displayed on the button.</p></div>
</dd>
<dt id="h2o_q.types.Button.link"><code class="name">var <span class="ident">link</span></code></dt>
<dd>
<div class="desc"><p>True if the button should be rendered as link text and not a standard button.</p></div>
</dd>
<dt id="h2o_q.types.Button.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this component. If the name is prefixed with a '#', the button sets the location hash to the name when clicked.</p></div>
</dd>
<dt id="h2o_q.types.Button.primary"><code class="name">var <span class="ident">primary</span></code></dt>
<dd>
<div class="desc"><p>True if the button should be rendered as the primary button in the set.</p></div>
</dd>
<dt id="h2o_q.types.Button.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>An optional tooltip message displayed when a user clicks the help icon to the right of the component.</p></div>
</dd>
<dt id="h2o_q.types.Button.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>A value for this button. If a value is set, it is used for the button's submitted instead of a boolean True.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Button.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;Button.name is required.&#39;)
    return _dump(
        name=self.name,
        label=self.label,
        caption=self.caption,
        value=self.value,
        primary=self.primary,
        disabled=self.disabled,
        link=self.link,
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Buttons"><code class="flex name class">
<span>class <span class="ident">Buttons</span></span>
<span>(</span><span>items: List[ForwardRef('<a title="h2o_q.types.Component" href="#h2o_q.types.Component">Component</a>')])</span>
</code></dt>
<dd>
<div class="desc"><p>Create a set of buttons to be layed out horizontally.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Buttons:
    &#34;&#34;&#34;Create a set of buttons to be layed out horizontally.
    &#34;&#34;&#34;
    def __init__(
            self,
            items: List[&#39;Component&#39;],
    ):
        self.items = items
        &#34;&#34;&#34;The button in this set.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.items is None:
            raise ValueError(&#39;Buttons.items is required.&#39;)
        return _dump(
            items=[__e.dump() for __e in self.items],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Buttons&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_items: Any = __d.get(&#39;items&#39;)
        if __d_items is None:
            raise ValueError(&#39;Buttons.items is required.&#39;)
        items: List[&#39;Component&#39;] = [Component.load(__e) for __e in __d_items]
        return Buttons(
            items,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Buttons.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Buttons__d: Dict) ‑> <a title="h2o_q.types.Buttons" href="#h2o_q.types.Buttons">Buttons</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Buttons&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_items: Any = __d.get(&#39;items&#39;)
    if __d_items is None:
        raise ValueError(&#39;Buttons.items is required.&#39;)
    items: List[&#39;Component&#39;] = [Component.load(__e) for __e in __d_items]
    return Buttons(
        items,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Buttons.items"><code class="name">var <span class="ident">items</span></code></dt>
<dd>
<div class="desc"><p>The button in this set.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Buttons.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.items is None:
        raise ValueError(&#39;Buttons.items is required.&#39;)
    return _dump(
        items=[__e.dump() for __e in self.items],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Checkbox"><code class="flex name class">
<span>class <span class="ident">Checkbox</span></span>
<span>(</span><span>name: str, label: Union[str, NoneType] = None, value: Union[bool, NoneType] = None, indeterminate: Union[bool, NoneType] = None, disabled: Union[bool, NoneType] = None, trigger: Union[bool, NoneType] = None, tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a checkbox.</p>
<p>A checkbox allows users to switch between two mutually exclusive options (checked or unchecked, on or off) through
a single click or tap. It can also be used to indicate a subordinate setting or preference when paired with another
component.</p>
<p>A checkbox is used to select or deselect action items. It can be used for a single item or for a list of multiple
items that a user can choose from. The component has two selection states: unselected and selected.</p>
<p>For a binary choice, the main difference between a checkbox and a toggle switch is that the checkbox is for status
and the toggle switch is for action.</p>
<p>Use multiple checkboxes for multi-select scenarios in which a user chooses one or more items from a group of
choices that are not mutually exclusive.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Checkbox:
    &#34;&#34;&#34;Create a checkbox.

    A checkbox allows users to switch between two mutually exclusive options (checked or unchecked, on or off) through
    a single click or tap. It can also be used to indicate a subordinate setting or preference when paired with another
    component.

    A checkbox is used to select or deselect action items. It can be used for a single item or for a list of multiple
    items that a user can choose from. The component has two selection states: unselected and selected.

    For a binary choice, the main difference between a checkbox and a toggle switch is that the checkbox is for status
    and the toggle switch is for action.

    Use multiple checkboxes for multi-select scenarios in which a user chooses one or more items from a group of
    choices that are not mutually exclusive.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            value: Optional[bool] = None,
            indeterminate: Optional[bool] = None,
            disabled: Optional[bool] = None,
            trigger: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the checkbox.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;True if selected, False if unselected.&#34;&#34;&#34;
        self.indeterminate = indeterminate
        &#34;&#34;&#34;True if the selection is indeterminate (neither selected nor unselected).&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if the checkbox is disabled.&#34;&#34;&#34;
        self.trigger = trigger
        &#34;&#34;&#34;True if the form should be submitted when the checkbox value changes.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Checkbox.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            value=self.value,
            indeterminate=self.indeterminate,
            disabled=self.disabled,
            trigger=self.trigger,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Checkbox&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Checkbox.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_indeterminate: Any = __d.get(&#39;indeterminate&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_trigger: Any = __d.get(&#39;trigger&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        value: Optional[bool] = __d_value
        indeterminate: Optional[bool] = __d_indeterminate
        disabled: Optional[bool] = __d_disabled
        trigger: Optional[bool] = __d_trigger
        tooltip: Optional[str] = __d_tooltip
        return Checkbox(
            name,
            label,
            value,
            indeterminate,
            disabled,
            trigger,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Checkbox.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Checkbox__d: Dict) ‑> <a title="h2o_q.types.Checkbox" href="#h2o_q.types.Checkbox">Checkbox</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Checkbox&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;Checkbox.name is required.&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    __d_value: Any = __d.get(&#39;value&#39;)
    __d_indeterminate: Any = __d.get(&#39;indeterminate&#39;)
    __d_disabled: Any = __d.get(&#39;disabled&#39;)
    __d_trigger: Any = __d.get(&#39;trigger&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    name: str = __d_name
    label: Optional[str] = __d_label
    value: Optional[bool] = __d_value
    indeterminate: Optional[bool] = __d_indeterminate
    disabled: Optional[bool] = __d_disabled
    trigger: Optional[bool] = __d_trigger
    tooltip: Optional[str] = __d_tooltip
    return Checkbox(
        name,
        label,
        value,
        indeterminate,
        disabled,
        trigger,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Checkbox.disabled"><code class="name">var <span class="ident">disabled</span></code></dt>
<dd>
<div class="desc"><p>True if the checkbox is disabled.</p></div>
</dd>
<dt id="h2o_q.types.Checkbox.indeterminate"><code class="name">var <span class="ident">indeterminate</span></code></dt>
<dd>
<div class="desc"><p>True if the selection is indeterminate (neither selected nor unselected).</p></div>
</dd>
<dt id="h2o_q.types.Checkbox.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>Text to be displayed alongside the checkbox.</p></div>
</dd>
<dt id="h2o_q.types.Checkbox.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this component.</p></div>
</dd>
<dt id="h2o_q.types.Checkbox.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>An optional tooltip message displayed when a user clicks the help icon to the right of the component.</p></div>
</dd>
<dt id="h2o_q.types.Checkbox.trigger"><code class="name">var <span class="ident">trigger</span></code></dt>
<dd>
<div class="desc"><p>True if the form should be submitted when the checkbox value changes.</p></div>
</dd>
<dt id="h2o_q.types.Checkbox.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>True if selected, False if unselected.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Checkbox.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;Checkbox.name is required.&#39;)
    return _dump(
        name=self.name,
        label=self.label,
        value=self.value,
        indeterminate=self.indeterminate,
        disabled=self.disabled,
        trigger=self.trigger,
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Checklist"><code class="flex name class">
<span>class <span class="ident">Checklist</span></span>
<span>(</span><span>name: str, label: Union[str, NoneType] = None, values: Union[List[str], NoneType] = None, choices: Union[List[<a title="h2o_q.types.Choice" href="#h2o_q.types.Choice">Choice</a>], NoneType] = None, trigger: Union[bool, NoneType] = None, tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a set of checkboxes.
Use this for multi-select scenarios in which a user chooses one or more items from a group of
choices that are not mutually exclusive.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Checklist:
    &#34;&#34;&#34;Create a set of checkboxes.
    Use this for multi-select scenarios in which a user chooses one or more items from a group of
    choices that are not mutually exclusive.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            values: Optional[List[str]] = None,
            choices: Optional[List[Choice]] = None,
            trigger: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed above the component.&#34;&#34;&#34;
        self.values = values
        &#34;&#34;&#34;The names of the selected choices.&#34;&#34;&#34;
        self.choices = choices
        &#34;&#34;&#34;The choices to be presented.&#34;&#34;&#34;
        self.trigger = trigger
        &#34;&#34;&#34;True if the form should be submitted when the checklist value changes.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Checklist.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            values=self.values,
            choices=None if self.choices is None else [__e.dump() for __e in self.choices],
            trigger=self.trigger,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Checklist&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Checklist.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_values: Any = __d.get(&#39;values&#39;)
        __d_choices: Any = __d.get(&#39;choices&#39;)
        __d_trigger: Any = __d.get(&#39;trigger&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        values: Optional[List[str]] = __d_values
        choices: Optional[List[Choice]] = None if __d_choices is None else [Choice.load(__e) for __e in __d_choices]
        trigger: Optional[bool] = __d_trigger
        tooltip: Optional[str] = __d_tooltip
        return Checklist(
            name,
            label,
            values,
            choices,
            trigger,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Checklist.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Checklist__d: Dict) ‑> <a title="h2o_q.types.Checklist" href="#h2o_q.types.Checklist">Checklist</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Checklist&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;Checklist.name is required.&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    __d_values: Any = __d.get(&#39;values&#39;)
    __d_choices: Any = __d.get(&#39;choices&#39;)
    __d_trigger: Any = __d.get(&#39;trigger&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    name: str = __d_name
    label: Optional[str] = __d_label
    values: Optional[List[str]] = __d_values
    choices: Optional[List[Choice]] = None if __d_choices is None else [Choice.load(__e) for __e in __d_choices]
    trigger: Optional[bool] = __d_trigger
    tooltip: Optional[str] = __d_tooltip
    return Checklist(
        name,
        label,
        values,
        choices,
        trigger,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Checklist.choices"><code class="name">var <span class="ident">choices</span></code></dt>
<dd>
<div class="desc"><p>The choices to be presented.</p></div>
</dd>
<dt id="h2o_q.types.Checklist.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>Text to be displayed above the component.</p></div>
</dd>
<dt id="h2o_q.types.Checklist.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this component.</p></div>
</dd>
<dt id="h2o_q.types.Checklist.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>An optional tooltip message displayed when a user clicks the help icon to the right of the component.</p></div>
</dd>
<dt id="h2o_q.types.Checklist.trigger"><code class="name">var <span class="ident">trigger</span></code></dt>
<dd>
<div class="desc"><p>True if the form should be submitted when the checklist value changes.</p></div>
</dd>
<dt id="h2o_q.types.Checklist.values"><code class="name">var <span class="ident">values</span></code></dt>
<dd>
<div class="desc"><p>The names of the selected choices.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Checklist.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;Checklist.name is required.&#39;)
    return _dump(
        name=self.name,
        label=self.label,
        values=self.values,
        choices=None if self.choices is None else [__e.dump() for __e in self.choices],
        trigger=self.trigger,
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Choice"><code class="flex name class">
<span>class <span class="ident">Choice</span></span>
<span>(</span><span>name: str, label: Union[str, NoneType] = None, disabled: Union[bool, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a choice for a checklist, choice group or dropdown.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Choice:
    &#34;&#34;&#34;Create a choice for a checklist, choice group or dropdown.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            disabled: Optional[bool] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the component.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if the checkbox is disabled.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Choice.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            disabled=self.disabled,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Choice&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Choice.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        disabled: Optional[bool] = __d_disabled
        return Choice(
            name,
            label,
            disabled,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Choice.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Choice__d: Dict) ‑> <a title="h2o_q.types.Choice" href="#h2o_q.types.Choice">Choice</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Choice&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;Choice.name is required.&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    __d_disabled: Any = __d.get(&#39;disabled&#39;)
    name: str = __d_name
    label: Optional[str] = __d_label
    disabled: Optional[bool] = __d_disabled
    return Choice(
        name,
        label,
        disabled,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Choice.disabled"><code class="name">var <span class="ident">disabled</span></code></dt>
<dd>
<div class="desc"><p>True if the checkbox is disabled.</p></div>
</dd>
<dt id="h2o_q.types.Choice.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>Text to be displayed alongside the component.</p></div>
</dd>
<dt id="h2o_q.types.Choice.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this component.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Choice.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;Choice.name is required.&#39;)
    return _dump(
        name=self.name,
        label=self.label,
        disabled=self.disabled,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.ChoiceGroup"><code class="flex name class">
<span>class <span class="ident">ChoiceGroup</span></span>
<span>(</span><span>name: str, label: Union[str, NoneType] = None, value: Union[str, NoneType] = None, choices: Union[List[<a title="h2o_q.types.Choice" href="#h2o_q.types.Choice">Choice</a>], NoneType] = None, required: Union[bool, NoneType] = None, trigger: Union[bool, NoneType] = None, tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a choice group.
The choice group component, also known as radio buttons, let users select one option from two or more choices.
Each option is represented by one choice group button; a user can select only one choice group in a button group.</p>
<p>Choice groups emphasize all options equally, and that may draw more attention to the options than necessary.
Consider using other components, unless the options deserve extra attention from the user.
For example, if the default option is recommended for most users in most situations, use a dropdown instead.</p>
<p>If there are only two mutually exclusive options, combine them into a single Checkbox or Toggle switch.
For example, use a checkbox for "I agree" instead of choice group buttons for "I agree" and "I don't agree."</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChoiceGroup:
    &#34;&#34;&#34;Create a choice group.
    The choice group component, also known as radio buttons, let users select one option from two or more choices.
    Each option is represented by one choice group button; a user can select only one choice group in a button group.

    Choice groups emphasize all options equally, and that may draw more attention to the options than necessary.
    Consider using other components, unless the options deserve extra attention from the user.
    For example, if the default option is recommended for most users in most situations, use a dropdown instead.

    If there are only two mutually exclusive options, combine them into a single Checkbox or Toggle switch.
    For example, use a checkbox for &#34;I agree&#34; instead of choice group buttons for &#34;I agree&#34; and &#34;I don&#39;t agree.&#34;
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            value: Optional[str] = None,
            choices: Optional[List[Choice]] = None,
            required: Optional[bool] = None,
            trigger: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the component.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The name of the selected choice.&#34;&#34;&#34;
        self.choices = choices
        &#34;&#34;&#34;The choices to be presented.&#34;&#34;&#34;
        self.required = required
        &#34;&#34;&#34;True if this field is required.&#34;&#34;&#34;
        self.trigger = trigger
        &#34;&#34;&#34;True if the form should be submitted when the selection changes.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;ChoiceGroup.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            value=self.value,
            choices=None if self.choices is None else [__e.dump() for __e in self.choices],
            required=self.required,
            trigger=self.trigger,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;ChoiceGroup&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;ChoiceGroup.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_choices: Any = __d.get(&#39;choices&#39;)
        __d_required: Any = __d.get(&#39;required&#39;)
        __d_trigger: Any = __d.get(&#39;trigger&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        value: Optional[str] = __d_value
        choices: Optional[List[Choice]] = None if __d_choices is None else [Choice.load(__e) for __e in __d_choices]
        required: Optional[bool] = __d_required
        trigger: Optional[bool] = __d_trigger
        tooltip: Optional[str] = __d_tooltip
        return ChoiceGroup(
            name,
            label,
            value,
            choices,
            required,
            trigger,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.ChoiceGroup.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_ChoiceGroup__d: Dict) ‑> <a title="h2o_q.types.ChoiceGroup" href="#h2o_q.types.ChoiceGroup">ChoiceGroup</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;ChoiceGroup&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;ChoiceGroup.name is required.&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    __d_value: Any = __d.get(&#39;value&#39;)
    __d_choices: Any = __d.get(&#39;choices&#39;)
    __d_required: Any = __d.get(&#39;required&#39;)
    __d_trigger: Any = __d.get(&#39;trigger&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    name: str = __d_name
    label: Optional[str] = __d_label
    value: Optional[str] = __d_value
    choices: Optional[List[Choice]] = None if __d_choices is None else [Choice.load(__e) for __e in __d_choices]
    required: Optional[bool] = __d_required
    trigger: Optional[bool] = __d_trigger
    tooltip: Optional[str] = __d_tooltip
    return ChoiceGroup(
        name,
        label,
        value,
        choices,
        required,
        trigger,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.ChoiceGroup.choices"><code class="name">var <span class="ident">choices</span></code></dt>
<dd>
<div class="desc"><p>The choices to be presented.</p></div>
</dd>
<dt id="h2o_q.types.ChoiceGroup.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>Text to be displayed alongside the component.</p></div>
</dd>
<dt id="h2o_q.types.ChoiceGroup.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this component.</p></div>
</dd>
<dt id="h2o_q.types.ChoiceGroup.required"><code class="name">var <span class="ident">required</span></code></dt>
<dd>
<div class="desc"><p>True if this field is required.</p></div>
</dd>
<dt id="h2o_q.types.ChoiceGroup.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>An optional tooltip message displayed when a user clicks the help icon to the right of the component.</p></div>
</dd>
<dt id="h2o_q.types.ChoiceGroup.trigger"><code class="name">var <span class="ident">trigger</span></code></dt>
<dd>
<div class="desc"><p>True if the form should be submitted when the selection changes.</p></div>
</dd>
<dt id="h2o_q.types.ChoiceGroup.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>The name of the selected choice.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.ChoiceGroup.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;ChoiceGroup.name is required.&#39;)
    return _dump(
        name=self.name,
        label=self.label,
        value=self.value,
        choices=None if self.choices is None else [__e.dump() for __e in self.choices],
        required=self.required,
        trigger=self.trigger,
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.ColorPicker"><code class="flex name class">
<span>class <span class="ident">ColorPicker</span></span>
<span>(</span><span>name: str, label: Union[str, NoneType] = None, value: Union[str, NoneType] = None, choices: Union[List[str], NoneType] = None, tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a color picker.</p>
<p>A date picker allows a user to pick a color value.
If the 'choices' parameter is set, a swatch picker is displayed instead of the standard color picker.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ColorPicker:
    &#34;&#34;&#34;Create a color picker.

    A date picker allows a user to pick a color value.
    If the &#39;choices&#39; parameter is set, a swatch picker is displayed instead of the standard color picker.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            value: Optional[str] = None,
            choices: Optional[List[str]] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the component.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The selected color (CSS-compatible string)&#34;&#34;&#34;
        self.choices = choices
        &#34;&#34;&#34;A list of colors (CSS-compatible strings) to limit color choices to.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;ColorPicker.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            value=self.value,
            choices=self.choices,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;ColorPicker&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;ColorPicker.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_choices: Any = __d.get(&#39;choices&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        value: Optional[str] = __d_value
        choices: Optional[List[str]] = __d_choices
        tooltip: Optional[str] = __d_tooltip
        return ColorPicker(
            name,
            label,
            value,
            choices,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.ColorPicker.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_ColorPicker__d: Dict) ‑> <a title="h2o_q.types.ColorPicker" href="#h2o_q.types.ColorPicker">ColorPicker</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;ColorPicker&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;ColorPicker.name is required.&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    __d_value: Any = __d.get(&#39;value&#39;)
    __d_choices: Any = __d.get(&#39;choices&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    name: str = __d_name
    label: Optional[str] = __d_label
    value: Optional[str] = __d_value
    choices: Optional[List[str]] = __d_choices
    tooltip: Optional[str] = __d_tooltip
    return ColorPicker(
        name,
        label,
        value,
        choices,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.ColorPicker.choices"><code class="name">var <span class="ident">choices</span></code></dt>
<dd>
<div class="desc"><p>A list of colors (CSS-compatible strings) to limit color choices to.</p></div>
</dd>
<dt id="h2o_q.types.ColorPicker.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>Text to be displayed alongside the component.</p></div>
</dd>
<dt id="h2o_q.types.ColorPicker.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this component.</p></div>
</dd>
<dt id="h2o_q.types.ColorPicker.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>An optional tooltip message displayed when a user clicks the help icon to the right of the component.</p></div>
</dd>
<dt id="h2o_q.types.ColorPicker.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>The selected color (CSS-compatible string)</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.ColorPicker.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;ColorPicker.name is required.&#39;)
    return _dump(
        name=self.name,
        label=self.label,
        value=self.value,
        choices=self.choices,
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Combobox"><code class="flex name class">
<span>class <span class="ident">Combobox</span></span>
<span>(</span><span>name: str, label: Union[str, NoneType] = None, placeholder: Union[str, NoneType] = None, value: Union[str, NoneType] = None, choices: Union[List[str], NoneType] = None, error: Union[str, NoneType] = None, disabled: Union[bool, NoneType] = None, tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combobox.</p>
<p>A combobox is a list in which the selected item is always visible, and the others are visible on demand by
clicking a drop-down button or by typing in the input.
They are used to simplify the design and make a choice within the UI.</p>
<p>When closed, only the selected item is visible.
When users click the drop-down button, all the options become visible.
To change the value, users open the list and click another value or use the arrow keys (up and down)
to select a new value.
When collapsed the user can select a new value by typing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Combobox:
    &#34;&#34;&#34;Create a combobox.

    A combobox is a list in which the selected item is always visible, and the others are visible on demand by
    clicking a drop-down button or by typing in the input.
    They are used to simplify the design and make a choice within the UI.

    When closed, only the selected item is visible.
    When users click the drop-down button, all the options become visible.
    To change the value, users open the list and click another value or use the arrow keys (up and down)
    to select a new value.
    When collapsed the user can select a new value by typing.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            placeholder: Optional[str] = None,
            value: Optional[str] = None,
            choices: Optional[List[str]] = None,
            error: Optional[str] = None,
            disabled: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the component.&#34;&#34;&#34;
        self.placeholder = placeholder
        &#34;&#34;&#34;A string that provides a brief hint to the user as to what kind of information is expected in the field.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The name of the selected choice.&#34;&#34;&#34;
        self.choices = choices
        &#34;&#34;&#34;The choices to be presented.&#34;&#34;&#34;
        self.error = error
        &#34;&#34;&#34;Text to be displayed as an error below the text box.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if this field is disabled.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Combobox.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            placeholder=self.placeholder,
            value=self.value,
            choices=self.choices,
            error=self.error,
            disabled=self.disabled,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Combobox&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Combobox.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_placeholder: Any = __d.get(&#39;placeholder&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_choices: Any = __d.get(&#39;choices&#39;)
        __d_error: Any = __d.get(&#39;error&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        placeholder: Optional[str] = __d_placeholder
        value: Optional[str] = __d_value
        choices: Optional[List[str]] = __d_choices
        error: Optional[str] = __d_error
        disabled: Optional[bool] = __d_disabled
        tooltip: Optional[str] = __d_tooltip
        return Combobox(
            name,
            label,
            placeholder,
            value,
            choices,
            error,
            disabled,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Combobox.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Combobox__d: Dict) ‑> <a title="h2o_q.types.Combobox" href="#h2o_q.types.Combobox">Combobox</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Combobox&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;Combobox.name is required.&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    __d_placeholder: Any = __d.get(&#39;placeholder&#39;)
    __d_value: Any = __d.get(&#39;value&#39;)
    __d_choices: Any = __d.get(&#39;choices&#39;)
    __d_error: Any = __d.get(&#39;error&#39;)
    __d_disabled: Any = __d.get(&#39;disabled&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    name: str = __d_name
    label: Optional[str] = __d_label
    placeholder: Optional[str] = __d_placeholder
    value: Optional[str] = __d_value
    choices: Optional[List[str]] = __d_choices
    error: Optional[str] = __d_error
    disabled: Optional[bool] = __d_disabled
    tooltip: Optional[str] = __d_tooltip
    return Combobox(
        name,
        label,
        placeholder,
        value,
        choices,
        error,
        disabled,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Combobox.choices"><code class="name">var <span class="ident">choices</span></code></dt>
<dd>
<div class="desc"><p>The choices to be presented.</p></div>
</dd>
<dt id="h2o_q.types.Combobox.disabled"><code class="name">var <span class="ident">disabled</span></code></dt>
<dd>
<div class="desc"><p>True if this field is disabled.</p></div>
</dd>
<dt id="h2o_q.types.Combobox.error"><code class="name">var <span class="ident">error</span></code></dt>
<dd>
<div class="desc"><p>Text to be displayed as an error below the text box.</p></div>
</dd>
<dt id="h2o_q.types.Combobox.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>Text to be displayed alongside the component.</p></div>
</dd>
<dt id="h2o_q.types.Combobox.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this component.</p></div>
</dd>
<dt id="h2o_q.types.Combobox.placeholder"><code class="name">var <span class="ident">placeholder</span></code></dt>
<dd>
<div class="desc"><p>A string that provides a brief hint to the user as to what kind of information is expected in the field.</p></div>
</dd>
<dt id="h2o_q.types.Combobox.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>An optional tooltip message displayed when a user clicks the help icon to the right of the component.</p></div>
</dd>
<dt id="h2o_q.types.Combobox.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>The name of the selected choice.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Combobox.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;Combobox.name is required.&#39;)
    return _dump(
        name=self.name,
        label=self.label,
        placeholder=self.placeholder,
        value=self.value,
        choices=self.choices,
        error=self.error,
        disabled=self.disabled,
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Command"><code class="flex name class">
<span>class <span class="ident">Command</span></span>
<span>(</span><span>name: str, label: Union[str, NoneType] = None, caption: Union[str, NoneType] = None, icon: Union[str, NoneType] = None, items: Union[List[ForwardRef('<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>')], NoneType] = None, data: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a command.</p>
<p>Commands are typically displayed as context menu items or toolbar button.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Command:
    &#34;&#34;&#34;Create a command.

    Commands are typically displayed as context menu items or toolbar button.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            caption: Optional[str] = None,
            icon: Optional[str] = None,
            items: Optional[List[&#39;Command&#39;]] = None,
            data: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component. If the name is prefixed with a &#39;#&#39;, the command sets the location hash to the name when executed.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;The text displayed for this command.&#34;&#34;&#34;
        self.caption = caption
        &#34;&#34;&#34;The caption for this command (typically a tooltip).&#34;&#34;&#34;
        self.icon = icon
        &#34;&#34;&#34;The icon to be displayed for this command.&#34;&#34;&#34;
        self.items = items
        &#34;&#34;&#34;Sub-commands, if any&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data associated with this command, if any.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Command.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            caption=self.caption,
            icon=self.icon,
            items=None if self.items is None else [__e.dump() for __e in self.items],
            data=self.data,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Command&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Command.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_caption: Any = __d.get(&#39;caption&#39;)
        __d_icon: Any = __d.get(&#39;icon&#39;)
        __d_items: Any = __d.get(&#39;items&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        caption: Optional[str] = __d_caption
        icon: Optional[str] = __d_icon
        items: Optional[List[&#39;Command&#39;]] = None if __d_items is None else [Command.load(__e) for __e in __d_items]
        data: Optional[str] = __d_data
        return Command(
            name,
            label,
            caption,
            icon,
            items,
            data,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Command.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Command__d: Dict) ‑> <a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Command&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;Command.name is required.&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    __d_caption: Any = __d.get(&#39;caption&#39;)
    __d_icon: Any = __d.get(&#39;icon&#39;)
    __d_items: Any = __d.get(&#39;items&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    name: str = __d_name
    label: Optional[str] = __d_label
    caption: Optional[str] = __d_caption
    icon: Optional[str] = __d_icon
    items: Optional[List[&#39;Command&#39;]] = None if __d_items is None else [Command.load(__e) for __e in __d_items]
    data: Optional[str] = __d_data
    return Command(
        name,
        label,
        caption,
        icon,
        items,
        data,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Command.caption"><code class="name">var <span class="ident">caption</span></code></dt>
<dd>
<div class="desc"><p>The caption for this command (typically a tooltip).</p></div>
</dd>
<dt id="h2o_q.types.Command.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Data associated with this command, if any.</p></div>
</dd>
<dt id="h2o_q.types.Command.icon"><code class="name">var <span class="ident">icon</span></code></dt>
<dd>
<div class="desc"><p>The icon to be displayed for this command.</p></div>
</dd>
<dt id="h2o_q.types.Command.items"><code class="name">var <span class="ident">items</span></code></dt>
<dd>
<div class="desc"><p>Sub-commands, if any</p></div>
</dd>
<dt id="h2o_q.types.Command.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>The text displayed for this command.</p></div>
</dd>
<dt id="h2o_q.types.Command.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this component. If the name is prefixed with a '#', the command sets the location hash to the name when executed.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Command.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;Command.name is required.&#39;)
    return _dump(
        name=self.name,
        label=self.label,
        caption=self.caption,
        icon=self.icon,
        items=None if self.items is None else [__e.dump() for __e in self.items],
        data=self.data,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Component"><code class="flex name class">
<span>class <span class="ident">Component</span></span>
<span>(</span><span>text: Union[<a title="h2o_q.types.Text" href="#h2o_q.types.Text">Text</a>, NoneType] = None, text_xl: Union[<a title="h2o_q.types.TextXl" href="#h2o_q.types.TextXl">TextXl</a>, NoneType] = None, text_l: Union[<a title="h2o_q.types.TextL" href="#h2o_q.types.TextL">TextL</a>, NoneType] = None, text_m: Union[<a title="h2o_q.types.TextM" href="#h2o_q.types.TextM">TextM</a>, NoneType] = None, text_s: Union[<a title="h2o_q.types.TextS" href="#h2o_q.types.TextS">TextS</a>, NoneType] = None, text_xs: Union[<a title="h2o_q.types.TextXs" href="#h2o_q.types.TextXs">TextXs</a>, NoneType] = None, label: Union[<a title="h2o_q.types.Label" href="#h2o_q.types.Label">Label</a>, NoneType] = None, separator: Union[<a title="h2o_q.types.Separator" href="#h2o_q.types.Separator">Separator</a>, NoneType] = None, progress: Union[<a title="h2o_q.types.Progress" href="#h2o_q.types.Progress">Progress</a>, NoneType] = None, message_bar: Union[<a title="h2o_q.types.MessageBar" href="#h2o_q.types.MessageBar">MessageBar</a>, NoneType] = None, textbox: Union[<a title="h2o_q.types.Textbox" href="#h2o_q.types.Textbox">Textbox</a>, NoneType] = None, checkbox: Union[<a title="h2o_q.types.Checkbox" href="#h2o_q.types.Checkbox">Checkbox</a>, NoneType] = None, toggle: Union[<a title="h2o_q.types.Toggle" href="#h2o_q.types.Toggle">Toggle</a>, NoneType] = None, choice_group: Union[<a title="h2o_q.types.ChoiceGroup" href="#h2o_q.types.ChoiceGroup">ChoiceGroup</a>, NoneType] = None, checklist: Union[<a title="h2o_q.types.Checklist" href="#h2o_q.types.Checklist">Checklist</a>, NoneType] = None, dropdown: Union[<a title="h2o_q.types.Dropdown" href="#h2o_q.types.Dropdown">Dropdown</a>, NoneType] = None, combobox: Union[<a title="h2o_q.types.Combobox" href="#h2o_q.types.Combobox">Combobox</a>, NoneType] = None, slider: Union[<a title="h2o_q.types.Slider" href="#h2o_q.types.Slider">Slider</a>, NoneType] = None, spinbox: Union[<a title="h2o_q.types.Spinbox" href="#h2o_q.types.Spinbox">Spinbox</a>, NoneType] = None, date_picker: Union[<a title="h2o_q.types.DatePicker" href="#h2o_q.types.DatePicker">DatePicker</a>, NoneType] = None, color_picker: Union[<a title="h2o_q.types.ColorPicker" href="#h2o_q.types.ColorPicker">ColorPicker</a>, NoneType] = None, button: Union[<a title="h2o_q.types.Button" href="#h2o_q.types.Button">Button</a>, NoneType] = None, buttons: Union[<a title="h2o_q.types.Buttons" href="#h2o_q.types.Buttons">Buttons</a>, NoneType] = None, file_upload: Union[<a title="h2o_q.types.FileUpload" href="#h2o_q.types.FileUpload">FileUpload</a>, NoneType] = None, table: Union[<a title="h2o_q.types.Table" href="#h2o_q.types.Table">Table</a>, NoneType] = None, link: Union[<a title="h2o_q.types.Link" href="#h2o_q.types.Link">Link</a>, NoneType] = None, tabs: Union[<a title="h2o_q.types.Tabs" href="#h2o_q.types.Tabs">Tabs</a>, NoneType] = None, expander: Union[<a title="h2o_q.types.Expander" href="#h2o_q.types.Expander">Expander</a>, NoneType] = None, frame: Union[<a title="h2o_q.types.Frame" href="#h2o_q.types.Frame">Frame</a>, NoneType] = None, markup: Union[<a title="h2o_q.types.Markup" href="#h2o_q.types.Markup">Markup</a>, NoneType] = None, template: Union[<a title="h2o_q.types.Template" href="#h2o_q.types.Template">Template</a>, NoneType] = None, picker: Union[<a title="h2o_q.types.Picker" href="#h2o_q.types.Picker">Picker</a>, NoneType] = None, range_slider: Union[<a title="h2o_q.types.RangeSlider" href="#h2o_q.types.RangeSlider">RangeSlider</a>, NoneType] = None, stepper: Union[<a title="h2o_q.types.Stepper" href="#h2o_q.types.Stepper">Stepper</a>, NoneType] = None, visualization: Union[<a title="h2o_q.types.Visualization" href="#h2o_q.types.Visualization">Visualization</a>, NoneType] = None, vega_visualization: Union[<a title="h2o_q.types.VegaVisualization" href="#h2o_q.types.VegaVisualization">VegaVisualization</a>, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a component.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Component:
    &#34;&#34;&#34;Create a component.
    &#34;&#34;&#34;
    def __init__(
            self,
            text: Optional[Text] = None,
            text_xl: Optional[TextXl] = None,
            text_l: Optional[TextL] = None,
            text_m: Optional[TextM] = None,
            text_s: Optional[TextS] = None,
            text_xs: Optional[TextXs] = None,
            label: Optional[Label] = None,
            separator: Optional[Separator] = None,
            progress: Optional[Progress] = None,
            message_bar: Optional[MessageBar] = None,
            textbox: Optional[Textbox] = None,
            checkbox: Optional[Checkbox] = None,
            toggle: Optional[Toggle] = None,
            choice_group: Optional[ChoiceGroup] = None,
            checklist: Optional[Checklist] = None,
            dropdown: Optional[Dropdown] = None,
            combobox: Optional[Combobox] = None,
            slider: Optional[Slider] = None,
            spinbox: Optional[Spinbox] = None,
            date_picker: Optional[DatePicker] = None,
            color_picker: Optional[ColorPicker] = None,
            button: Optional[Button] = None,
            buttons: Optional[Buttons] = None,
            file_upload: Optional[FileUpload] = None,
            table: Optional[Table] = None,
            link: Optional[Link] = None,
            tabs: Optional[Tabs] = None,
            expander: Optional[Expander] = None,
            frame: Optional[Frame] = None,
            markup: Optional[Markup] = None,
            template: Optional[Template] = None,
            picker: Optional[Picker] = None,
            range_slider: Optional[RangeSlider] = None,
            stepper: Optional[Stepper] = None,
            visualization: Optional[Visualization] = None,
            vega_visualization: Optional[VegaVisualization] = None,
    ):
        self.text = text
        &#34;&#34;&#34;Text block.&#34;&#34;&#34;
        self.text_xl = text_xl
        &#34;&#34;&#34;Extra-large sized text block.&#34;&#34;&#34;
        self.text_l = text_l
        &#34;&#34;&#34;Large sized text block.&#34;&#34;&#34;
        self.text_m = text_m
        &#34;&#34;&#34;Medium sized text block.&#34;&#34;&#34;
        self.text_s = text_s
        &#34;&#34;&#34;Small sized text block.&#34;&#34;&#34;
        self.text_xs = text_xs
        &#34;&#34;&#34;Extra-small sized text block.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Label.&#34;&#34;&#34;
        self.separator = separator
        &#34;&#34;&#34;Separator.&#34;&#34;&#34;
        self.progress = progress
        &#34;&#34;&#34;Progress bar.&#34;&#34;&#34;
        self.message_bar = message_bar
        &#34;&#34;&#34;Message bar.&#34;&#34;&#34;
        self.textbox = textbox
        &#34;&#34;&#34;Textbox.&#34;&#34;&#34;
        self.checkbox = checkbox
        &#34;&#34;&#34;Checkbox.&#34;&#34;&#34;
        self.toggle = toggle
        &#34;&#34;&#34;Toggle.&#34;&#34;&#34;
        self.choice_group = choice_group
        &#34;&#34;&#34;Choice group.&#34;&#34;&#34;
        self.checklist = checklist
        &#34;&#34;&#34;Checklist.&#34;&#34;&#34;
        self.dropdown = dropdown
        &#34;&#34;&#34;Dropdown.&#34;&#34;&#34;
        self.combobox = combobox
        &#34;&#34;&#34;Combobox.&#34;&#34;&#34;
        self.slider = slider
        &#34;&#34;&#34;Slider.&#34;&#34;&#34;
        self.spinbox = spinbox
        &#34;&#34;&#34;Spinbox.&#34;&#34;&#34;
        self.date_picker = date_picker
        &#34;&#34;&#34;Date picker.&#34;&#34;&#34;
        self.color_picker = color_picker
        &#34;&#34;&#34;Color picker.&#34;&#34;&#34;
        self.button = button
        &#34;&#34;&#34;Button.&#34;&#34;&#34;
        self.buttons = buttons
        &#34;&#34;&#34;Button set.&#34;&#34;&#34;
        self.file_upload = file_upload
        &#34;&#34;&#34;File upload.&#34;&#34;&#34;
        self.table = table
        &#34;&#34;&#34;Table.&#34;&#34;&#34;
        self.link = link
        &#34;&#34;&#34;Link.&#34;&#34;&#34;
        self.tabs = tabs
        &#34;&#34;&#34;Tabs.&#34;&#34;&#34;
        self.expander = expander
        &#34;&#34;&#34;Expander.&#34;&#34;&#34;
        self.frame = frame
        &#34;&#34;&#34;Frame.&#34;&#34;&#34;
        self.markup = markup
        &#34;&#34;&#34;Markup&#34;&#34;&#34;
        self.template = template
        &#34;&#34;&#34;Template&#34;&#34;&#34;
        self.picker = picker
        &#34;&#34;&#34;Picker.&#34;&#34;&#34;
        self.range_slider = range_slider
        &#34;&#34;&#34;Range Slider.&#34;&#34;&#34;
        self.stepper = stepper
        &#34;&#34;&#34;Stepper.&#34;&#34;&#34;
        self.visualization = visualization
        &#34;&#34;&#34;Visualization.&#34;&#34;&#34;
        self.vega_visualization = vega_visualization
        &#34;&#34;&#34;Vega-lite Visualization.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        return _dump(
            text=None if self.text is None else self.text.dump(),
            text_xl=None if self.text_xl is None else self.text_xl.dump(),
            text_l=None if self.text_l is None else self.text_l.dump(),
            text_m=None if self.text_m is None else self.text_m.dump(),
            text_s=None if self.text_s is None else self.text_s.dump(),
            text_xs=None if self.text_xs is None else self.text_xs.dump(),
            label=None if self.label is None else self.label.dump(),
            separator=None if self.separator is None else self.separator.dump(),
            progress=None if self.progress is None else self.progress.dump(),
            message_bar=None if self.message_bar is None else self.message_bar.dump(),
            textbox=None if self.textbox is None else self.textbox.dump(),
            checkbox=None if self.checkbox is None else self.checkbox.dump(),
            toggle=None if self.toggle is None else self.toggle.dump(),
            choice_group=None if self.choice_group is None else self.choice_group.dump(),
            checklist=None if self.checklist is None else self.checklist.dump(),
            dropdown=None if self.dropdown is None else self.dropdown.dump(),
            combobox=None if self.combobox is None else self.combobox.dump(),
            slider=None if self.slider is None else self.slider.dump(),
            spinbox=None if self.spinbox is None else self.spinbox.dump(),
            date_picker=None if self.date_picker is None else self.date_picker.dump(),
            color_picker=None if self.color_picker is None else self.color_picker.dump(),
            button=None if self.button is None else self.button.dump(),
            buttons=None if self.buttons is None else self.buttons.dump(),
            file_upload=None if self.file_upload is None else self.file_upload.dump(),
            table=None if self.table is None else self.table.dump(),
            link=None if self.link is None else self.link.dump(),
            tabs=None if self.tabs is None else self.tabs.dump(),
            expander=None if self.expander is None else self.expander.dump(),
            frame=None if self.frame is None else self.frame.dump(),
            markup=None if self.markup is None else self.markup.dump(),
            template=None if self.template is None else self.template.dump(),
            picker=None if self.picker is None else self.picker.dump(),
            range_slider=None if self.range_slider is None else self.range_slider.dump(),
            stepper=None if self.stepper is None else self.stepper.dump(),
            visualization=None if self.visualization is None else self.visualization.dump(),
            vega_visualization=None if self.vega_visualization is None else self.vega_visualization.dump(),
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Component&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_text: Any = __d.get(&#39;text&#39;)
        __d_text_xl: Any = __d.get(&#39;text_xl&#39;)
        __d_text_l: Any = __d.get(&#39;text_l&#39;)
        __d_text_m: Any = __d.get(&#39;text_m&#39;)
        __d_text_s: Any = __d.get(&#39;text_s&#39;)
        __d_text_xs: Any = __d.get(&#39;text_xs&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_separator: Any = __d.get(&#39;separator&#39;)
        __d_progress: Any = __d.get(&#39;progress&#39;)
        __d_message_bar: Any = __d.get(&#39;message_bar&#39;)
        __d_textbox: Any = __d.get(&#39;textbox&#39;)
        __d_checkbox: Any = __d.get(&#39;checkbox&#39;)
        __d_toggle: Any = __d.get(&#39;toggle&#39;)
        __d_choice_group: Any = __d.get(&#39;choice_group&#39;)
        __d_checklist: Any = __d.get(&#39;checklist&#39;)
        __d_dropdown: Any = __d.get(&#39;dropdown&#39;)
        __d_combobox: Any = __d.get(&#39;combobox&#39;)
        __d_slider: Any = __d.get(&#39;slider&#39;)
        __d_spinbox: Any = __d.get(&#39;spinbox&#39;)
        __d_date_picker: Any = __d.get(&#39;date_picker&#39;)
        __d_color_picker: Any = __d.get(&#39;color_picker&#39;)
        __d_button: Any = __d.get(&#39;button&#39;)
        __d_buttons: Any = __d.get(&#39;buttons&#39;)
        __d_file_upload: Any = __d.get(&#39;file_upload&#39;)
        __d_table: Any = __d.get(&#39;table&#39;)
        __d_link: Any = __d.get(&#39;link&#39;)
        __d_tabs: Any = __d.get(&#39;tabs&#39;)
        __d_expander: Any = __d.get(&#39;expander&#39;)
        __d_frame: Any = __d.get(&#39;frame&#39;)
        __d_markup: Any = __d.get(&#39;markup&#39;)
        __d_template: Any = __d.get(&#39;template&#39;)
        __d_picker: Any = __d.get(&#39;picker&#39;)
        __d_range_slider: Any = __d.get(&#39;range_slider&#39;)
        __d_stepper: Any = __d.get(&#39;stepper&#39;)
        __d_visualization: Any = __d.get(&#39;visualization&#39;)
        __d_vega_visualization: Any = __d.get(&#39;vega_visualization&#39;)
        text: Optional[Text] = None if __d_text is None else Text.load(__d_text)
        text_xl: Optional[TextXl] = None if __d_text_xl is None else TextXl.load(__d_text_xl)
        text_l: Optional[TextL] = None if __d_text_l is None else TextL.load(__d_text_l)
        text_m: Optional[TextM] = None if __d_text_m is None else TextM.load(__d_text_m)
        text_s: Optional[TextS] = None if __d_text_s is None else TextS.load(__d_text_s)
        text_xs: Optional[TextXs] = None if __d_text_xs is None else TextXs.load(__d_text_xs)
        label: Optional[Label] = None if __d_label is None else Label.load(__d_label)
        separator: Optional[Separator] = None if __d_separator is None else Separator.load(__d_separator)
        progress: Optional[Progress] = None if __d_progress is None else Progress.load(__d_progress)
        message_bar: Optional[MessageBar] = None if __d_message_bar is None else MessageBar.load(__d_message_bar)
        textbox: Optional[Textbox] = None if __d_textbox is None else Textbox.load(__d_textbox)
        checkbox: Optional[Checkbox] = None if __d_checkbox is None else Checkbox.load(__d_checkbox)
        toggle: Optional[Toggle] = None if __d_toggle is None else Toggle.load(__d_toggle)
        choice_group: Optional[ChoiceGroup] = None if __d_choice_group is None else ChoiceGroup.load(__d_choice_group)
        checklist: Optional[Checklist] = None if __d_checklist is None else Checklist.load(__d_checklist)
        dropdown: Optional[Dropdown] = None if __d_dropdown is None else Dropdown.load(__d_dropdown)
        combobox: Optional[Combobox] = None if __d_combobox is None else Combobox.load(__d_combobox)
        slider: Optional[Slider] = None if __d_slider is None else Slider.load(__d_slider)
        spinbox: Optional[Spinbox] = None if __d_spinbox is None else Spinbox.load(__d_spinbox)
        date_picker: Optional[DatePicker] = None if __d_date_picker is None else DatePicker.load(__d_date_picker)
        color_picker: Optional[ColorPicker] = None if __d_color_picker is None else ColorPicker.load(__d_color_picker)
        button: Optional[Button] = None if __d_button is None else Button.load(__d_button)
        buttons: Optional[Buttons] = None if __d_buttons is None else Buttons.load(__d_buttons)
        file_upload: Optional[FileUpload] = None if __d_file_upload is None else FileUpload.load(__d_file_upload)
        table: Optional[Table] = None if __d_table is None else Table.load(__d_table)
        link: Optional[Link] = None if __d_link is None else Link.load(__d_link)
        tabs: Optional[Tabs] = None if __d_tabs is None else Tabs.load(__d_tabs)
        expander: Optional[Expander] = None if __d_expander is None else Expander.load(__d_expander)
        frame: Optional[Frame] = None if __d_frame is None else Frame.load(__d_frame)
        markup: Optional[Markup] = None if __d_markup is None else Markup.load(__d_markup)
        template: Optional[Template] = None if __d_template is None else Template.load(__d_template)
        picker: Optional[Picker] = None if __d_picker is None else Picker.load(__d_picker)
        range_slider: Optional[RangeSlider] = None if __d_range_slider is None else RangeSlider.load(__d_range_slider)
        stepper: Optional[Stepper] = None if __d_stepper is None else Stepper.load(__d_stepper)
        visualization: Optional[Visualization] = None if __d_visualization is None else Visualization.load(__d_visualization)
        vega_visualization: Optional[VegaVisualization] = None if __d_vega_visualization is None else VegaVisualization.load(__d_vega_visualization)
        return Component(
            text,
            text_xl,
            text_l,
            text_m,
            text_s,
            text_xs,
            label,
            separator,
            progress,
            message_bar,
            textbox,
            checkbox,
            toggle,
            choice_group,
            checklist,
            dropdown,
            combobox,
            slider,
            spinbox,
            date_picker,
            color_picker,
            button,
            buttons,
            file_upload,
            table,
            link,
            tabs,
            expander,
            frame,
            markup,
            template,
            picker,
            range_slider,
            stepper,
            visualization,
            vega_visualization,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Component.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Component__d: Dict) ‑> <a title="h2o_q.types.Component" href="#h2o_q.types.Component">Component</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Component&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_text: Any = __d.get(&#39;text&#39;)
    __d_text_xl: Any = __d.get(&#39;text_xl&#39;)
    __d_text_l: Any = __d.get(&#39;text_l&#39;)
    __d_text_m: Any = __d.get(&#39;text_m&#39;)
    __d_text_s: Any = __d.get(&#39;text_s&#39;)
    __d_text_xs: Any = __d.get(&#39;text_xs&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    __d_separator: Any = __d.get(&#39;separator&#39;)
    __d_progress: Any = __d.get(&#39;progress&#39;)
    __d_message_bar: Any = __d.get(&#39;message_bar&#39;)
    __d_textbox: Any = __d.get(&#39;textbox&#39;)
    __d_checkbox: Any = __d.get(&#39;checkbox&#39;)
    __d_toggle: Any = __d.get(&#39;toggle&#39;)
    __d_choice_group: Any = __d.get(&#39;choice_group&#39;)
    __d_checklist: Any = __d.get(&#39;checklist&#39;)
    __d_dropdown: Any = __d.get(&#39;dropdown&#39;)
    __d_combobox: Any = __d.get(&#39;combobox&#39;)
    __d_slider: Any = __d.get(&#39;slider&#39;)
    __d_spinbox: Any = __d.get(&#39;spinbox&#39;)
    __d_date_picker: Any = __d.get(&#39;date_picker&#39;)
    __d_color_picker: Any = __d.get(&#39;color_picker&#39;)
    __d_button: Any = __d.get(&#39;button&#39;)
    __d_buttons: Any = __d.get(&#39;buttons&#39;)
    __d_file_upload: Any = __d.get(&#39;file_upload&#39;)
    __d_table: Any = __d.get(&#39;table&#39;)
    __d_link: Any = __d.get(&#39;link&#39;)
    __d_tabs: Any = __d.get(&#39;tabs&#39;)
    __d_expander: Any = __d.get(&#39;expander&#39;)
    __d_frame: Any = __d.get(&#39;frame&#39;)
    __d_markup: Any = __d.get(&#39;markup&#39;)
    __d_template: Any = __d.get(&#39;template&#39;)
    __d_picker: Any = __d.get(&#39;picker&#39;)
    __d_range_slider: Any = __d.get(&#39;range_slider&#39;)
    __d_stepper: Any = __d.get(&#39;stepper&#39;)
    __d_visualization: Any = __d.get(&#39;visualization&#39;)
    __d_vega_visualization: Any = __d.get(&#39;vega_visualization&#39;)
    text: Optional[Text] = None if __d_text is None else Text.load(__d_text)
    text_xl: Optional[TextXl] = None if __d_text_xl is None else TextXl.load(__d_text_xl)
    text_l: Optional[TextL] = None if __d_text_l is None else TextL.load(__d_text_l)
    text_m: Optional[TextM] = None if __d_text_m is None else TextM.load(__d_text_m)
    text_s: Optional[TextS] = None if __d_text_s is None else TextS.load(__d_text_s)
    text_xs: Optional[TextXs] = None if __d_text_xs is None else TextXs.load(__d_text_xs)
    label: Optional[Label] = None if __d_label is None else Label.load(__d_label)
    separator: Optional[Separator] = None if __d_separator is None else Separator.load(__d_separator)
    progress: Optional[Progress] = None if __d_progress is None else Progress.load(__d_progress)
    message_bar: Optional[MessageBar] = None if __d_message_bar is None else MessageBar.load(__d_message_bar)
    textbox: Optional[Textbox] = None if __d_textbox is None else Textbox.load(__d_textbox)
    checkbox: Optional[Checkbox] = None if __d_checkbox is None else Checkbox.load(__d_checkbox)
    toggle: Optional[Toggle] = None if __d_toggle is None else Toggle.load(__d_toggle)
    choice_group: Optional[ChoiceGroup] = None if __d_choice_group is None else ChoiceGroup.load(__d_choice_group)
    checklist: Optional[Checklist] = None if __d_checklist is None else Checklist.load(__d_checklist)
    dropdown: Optional[Dropdown] = None if __d_dropdown is None else Dropdown.load(__d_dropdown)
    combobox: Optional[Combobox] = None if __d_combobox is None else Combobox.load(__d_combobox)
    slider: Optional[Slider] = None if __d_slider is None else Slider.load(__d_slider)
    spinbox: Optional[Spinbox] = None if __d_spinbox is None else Spinbox.load(__d_spinbox)
    date_picker: Optional[DatePicker] = None if __d_date_picker is None else DatePicker.load(__d_date_picker)
    color_picker: Optional[ColorPicker] = None if __d_color_picker is None else ColorPicker.load(__d_color_picker)
    button: Optional[Button] = None if __d_button is None else Button.load(__d_button)
    buttons: Optional[Buttons] = None if __d_buttons is None else Buttons.load(__d_buttons)
    file_upload: Optional[FileUpload] = None if __d_file_upload is None else FileUpload.load(__d_file_upload)
    table: Optional[Table] = None if __d_table is None else Table.load(__d_table)
    link: Optional[Link] = None if __d_link is None else Link.load(__d_link)
    tabs: Optional[Tabs] = None if __d_tabs is None else Tabs.load(__d_tabs)
    expander: Optional[Expander] = None if __d_expander is None else Expander.load(__d_expander)
    frame: Optional[Frame] = None if __d_frame is None else Frame.load(__d_frame)
    markup: Optional[Markup] = None if __d_markup is None else Markup.load(__d_markup)
    template: Optional[Template] = None if __d_template is None else Template.load(__d_template)
    picker: Optional[Picker] = None if __d_picker is None else Picker.load(__d_picker)
    range_slider: Optional[RangeSlider] = None if __d_range_slider is None else RangeSlider.load(__d_range_slider)
    stepper: Optional[Stepper] = None if __d_stepper is None else Stepper.load(__d_stepper)
    visualization: Optional[Visualization] = None if __d_visualization is None else Visualization.load(__d_visualization)
    vega_visualization: Optional[VegaVisualization] = None if __d_vega_visualization is None else VegaVisualization.load(__d_vega_visualization)
    return Component(
        text,
        text_xl,
        text_l,
        text_m,
        text_s,
        text_xs,
        label,
        separator,
        progress,
        message_bar,
        textbox,
        checkbox,
        toggle,
        choice_group,
        checklist,
        dropdown,
        combobox,
        slider,
        spinbox,
        date_picker,
        color_picker,
        button,
        buttons,
        file_upload,
        table,
        link,
        tabs,
        expander,
        frame,
        markup,
        template,
        picker,
        range_slider,
        stepper,
        visualization,
        vega_visualization,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Component.button"><code class="name">var <span class="ident">button</span></code></dt>
<dd>
<div class="desc"><p>Button.</p></div>
</dd>
<dt id="h2o_q.types.Component.buttons"><code class="name">var <span class="ident">buttons</span></code></dt>
<dd>
<div class="desc"><p>Button set.</p></div>
</dd>
<dt id="h2o_q.types.Component.checkbox"><code class="name">var <span class="ident">checkbox</span></code></dt>
<dd>
<div class="desc"><p>Checkbox.</p></div>
</dd>
<dt id="h2o_q.types.Component.checklist"><code class="name">var <span class="ident">checklist</span></code></dt>
<dd>
<div class="desc"><p>Checklist.</p></div>
</dd>
<dt id="h2o_q.types.Component.choice_group"><code class="name">var <span class="ident">choice_group</span></code></dt>
<dd>
<div class="desc"><p>Choice group.</p></div>
</dd>
<dt id="h2o_q.types.Component.color_picker"><code class="name">var <span class="ident">color_picker</span></code></dt>
<dd>
<div class="desc"><p>Color picker.</p></div>
</dd>
<dt id="h2o_q.types.Component.combobox"><code class="name">var <span class="ident">combobox</span></code></dt>
<dd>
<div class="desc"><p>Combobox.</p></div>
</dd>
<dt id="h2o_q.types.Component.date_picker"><code class="name">var <span class="ident">date_picker</span></code></dt>
<dd>
<div class="desc"><p>Date picker.</p></div>
</dd>
<dt id="h2o_q.types.Component.dropdown"><code class="name">var <span class="ident">dropdown</span></code></dt>
<dd>
<div class="desc"><p>Dropdown.</p></div>
</dd>
<dt id="h2o_q.types.Component.expander"><code class="name">var <span class="ident">expander</span></code></dt>
<dd>
<div class="desc"><p>Expander.</p></div>
</dd>
<dt id="h2o_q.types.Component.file_upload"><code class="name">var <span class="ident">file_upload</span></code></dt>
<dd>
<div class="desc"><p>File upload.</p></div>
</dd>
<dt id="h2o_q.types.Component.frame"><code class="name">var <span class="ident">frame</span></code></dt>
<dd>
<div class="desc"><p>Frame.</p></div>
</dd>
<dt id="h2o_q.types.Component.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>Label.</p></div>
</dd>
<dt id="h2o_q.types.Component.link"><code class="name">var <span class="ident">link</span></code></dt>
<dd>
<div class="desc"><p>Link.</p></div>
</dd>
<dt id="h2o_q.types.Component.markup"><code class="name">var <span class="ident">markup</span></code></dt>
<dd>
<div class="desc"><p>Markup</p></div>
</dd>
<dt id="h2o_q.types.Component.message_bar"><code class="name">var <span class="ident">message_bar</span></code></dt>
<dd>
<div class="desc"><p>Message bar.</p></div>
</dd>
<dt id="h2o_q.types.Component.picker"><code class="name">var <span class="ident">picker</span></code></dt>
<dd>
<div class="desc"><p>Picker.</p></div>
</dd>
<dt id="h2o_q.types.Component.progress"><code class="name">var <span class="ident">progress</span></code></dt>
<dd>
<div class="desc"><p>Progress bar.</p></div>
</dd>
<dt id="h2o_q.types.Component.range_slider"><code class="name">var <span class="ident">range_slider</span></code></dt>
<dd>
<div class="desc"><p>Range Slider.</p></div>
</dd>
<dt id="h2o_q.types.Component.separator"><code class="name">var <span class="ident">separator</span></code></dt>
<dd>
<div class="desc"><p>Separator.</p></div>
</dd>
<dt id="h2o_q.types.Component.slider"><code class="name">var <span class="ident">slider</span></code></dt>
<dd>
<div class="desc"><p>Slider.</p></div>
</dd>
<dt id="h2o_q.types.Component.spinbox"><code class="name">var <span class="ident">spinbox</span></code></dt>
<dd>
<div class="desc"><p>Spinbox.</p></div>
</dd>
<dt id="h2o_q.types.Component.stepper"><code class="name">var <span class="ident">stepper</span></code></dt>
<dd>
<div class="desc"><p>Stepper.</p></div>
</dd>
<dt id="h2o_q.types.Component.table"><code class="name">var <span class="ident">table</span></code></dt>
<dd>
<div class="desc"><p>Table.</p></div>
</dd>
<dt id="h2o_q.types.Component.tabs"><code class="name">var <span class="ident">tabs</span></code></dt>
<dd>
<div class="desc"><p>Tabs.</p></div>
</dd>
<dt id="h2o_q.types.Component.template"><code class="name">var <span class="ident">template</span></code></dt>
<dd>
<div class="desc"><p>Template</p></div>
</dd>
<dt id="h2o_q.types.Component.text"><code class="name">var <span class="ident">text</span></code></dt>
<dd>
<div class="desc"><p>Text block.</p></div>
</dd>
<dt id="h2o_q.types.Component.text_l"><code class="name">var <span class="ident">text_l</span></code></dt>
<dd>
<div class="desc"><p>Large sized text block.</p></div>
</dd>
<dt id="h2o_q.types.Component.text_m"><code class="name">var <span class="ident">text_m</span></code></dt>
<dd>
<div class="desc"><p>Medium sized text block.</p></div>
</dd>
<dt id="h2o_q.types.Component.text_s"><code class="name">var <span class="ident">text_s</span></code></dt>
<dd>
<div class="desc"><p>Small sized text block.</p></div>
</dd>
<dt id="h2o_q.types.Component.text_xl"><code class="name">var <span class="ident">text_xl</span></code></dt>
<dd>
<div class="desc"><p>Extra-large sized text block.</p></div>
</dd>
<dt id="h2o_q.types.Component.text_xs"><code class="name">var <span class="ident">text_xs</span></code></dt>
<dd>
<div class="desc"><p>Extra-small sized text block.</p></div>
</dd>
<dt id="h2o_q.types.Component.textbox"><code class="name">var <span class="ident">textbox</span></code></dt>
<dd>
<div class="desc"><p>Textbox.</p></div>
</dd>
<dt id="h2o_q.types.Component.toggle"><code class="name">var <span class="ident">toggle</span></code></dt>
<dd>
<div class="desc"><p>Toggle.</p></div>
</dd>
<dt id="h2o_q.types.Component.vega_visualization"><code class="name">var <span class="ident">vega_visualization</span></code></dt>
<dd>
<div class="desc"><p>Vega-lite Visualization.</p></div>
</dd>
<dt id="h2o_q.types.Component.visualization"><code class="name">var <span class="ident">visualization</span></code></dt>
<dd>
<div class="desc"><p>Visualization.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Component.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    return _dump(
        text=None if self.text is None else self.text.dump(),
        text_xl=None if self.text_xl is None else self.text_xl.dump(),
        text_l=None if self.text_l is None else self.text_l.dump(),
        text_m=None if self.text_m is None else self.text_m.dump(),
        text_s=None if self.text_s is None else self.text_s.dump(),
        text_xs=None if self.text_xs is None else self.text_xs.dump(),
        label=None if self.label is None else self.label.dump(),
        separator=None if self.separator is None else self.separator.dump(),
        progress=None if self.progress is None else self.progress.dump(),
        message_bar=None if self.message_bar is None else self.message_bar.dump(),
        textbox=None if self.textbox is None else self.textbox.dump(),
        checkbox=None if self.checkbox is None else self.checkbox.dump(),
        toggle=None if self.toggle is None else self.toggle.dump(),
        choice_group=None if self.choice_group is None else self.choice_group.dump(),
        checklist=None if self.checklist is None else self.checklist.dump(),
        dropdown=None if self.dropdown is None else self.dropdown.dump(),
        combobox=None if self.combobox is None else self.combobox.dump(),
        slider=None if self.slider is None else self.slider.dump(),
        spinbox=None if self.spinbox is None else self.spinbox.dump(),
        date_picker=None if self.date_picker is None else self.date_picker.dump(),
        color_picker=None if self.color_picker is None else self.color_picker.dump(),
        button=None if self.button is None else self.button.dump(),
        buttons=None if self.buttons is None else self.buttons.dump(),
        file_upload=None if self.file_upload is None else self.file_upload.dump(),
        table=None if self.table is None else self.table.dump(),
        link=None if self.link is None else self.link.dump(),
        tabs=None if self.tabs is None else self.tabs.dump(),
        expander=None if self.expander is None else self.expander.dump(),
        frame=None if self.frame is None else self.frame.dump(),
        markup=None if self.markup is None else self.markup.dump(),
        template=None if self.template is None else self.template.dump(),
        picker=None if self.picker is None else self.picker.dump(),
        range_slider=None if self.range_slider is None else self.range_slider.dump(),
        stepper=None if self.stepper is None else self.stepper.dump(),
        visualization=None if self.visualization is None else self.visualization.dump(),
        vega_visualization=None if self.vega_visualization is None else self.vega_visualization.dump(),
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.DatePicker"><code class="flex name class">
<span>class <span class="ident">DatePicker</span></span>
<span>(</span><span>name: str, label: Union[str, NoneType] = None, placeholder: Union[str, NoneType] = None, value: Union[str, NoneType] = None, disabled: Union[bool, NoneType] = None, tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a date picker.</p>
<p>A date picker allows a user to pick a date value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DatePicker:
    &#34;&#34;&#34;Create a date picker.

    A date picker allows a user to pick a date value.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            placeholder: Optional[str] = None,
            value: Optional[str] = None,
            disabled: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the component.&#34;&#34;&#34;
        self.placeholder = placeholder
        &#34;&#34;&#34;A string that provides a brief hint to the user as to what kind of information is expected in the field.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The date value in YYYY-MM-DD format.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if this field is disabled.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;DatePicker.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            placeholder=self.placeholder,
            value=self.value,
            disabled=self.disabled,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;DatePicker&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;DatePicker.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_placeholder: Any = __d.get(&#39;placeholder&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        placeholder: Optional[str] = __d_placeholder
        value: Optional[str] = __d_value
        disabled: Optional[bool] = __d_disabled
        tooltip: Optional[str] = __d_tooltip
        return DatePicker(
            name,
            label,
            placeholder,
            value,
            disabled,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.DatePicker.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_DatePicker__d: Dict) ‑> <a title="h2o_q.types.DatePicker" href="#h2o_q.types.DatePicker">DatePicker</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;DatePicker&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;DatePicker.name is required.&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    __d_placeholder: Any = __d.get(&#39;placeholder&#39;)
    __d_value: Any = __d.get(&#39;value&#39;)
    __d_disabled: Any = __d.get(&#39;disabled&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    name: str = __d_name
    label: Optional[str] = __d_label
    placeholder: Optional[str] = __d_placeholder
    value: Optional[str] = __d_value
    disabled: Optional[bool] = __d_disabled
    tooltip: Optional[str] = __d_tooltip
    return DatePicker(
        name,
        label,
        placeholder,
        value,
        disabled,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.DatePicker.disabled"><code class="name">var <span class="ident">disabled</span></code></dt>
<dd>
<div class="desc"><p>True if this field is disabled.</p></div>
</dd>
<dt id="h2o_q.types.DatePicker.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>Text to be displayed alongside the component.</p></div>
</dd>
<dt id="h2o_q.types.DatePicker.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this component.</p></div>
</dd>
<dt id="h2o_q.types.DatePicker.placeholder"><code class="name">var <span class="ident">placeholder</span></code></dt>
<dd>
<div class="desc"><p>A string that provides a brief hint to the user as to what kind of information is expected in the field.</p></div>
</dd>
<dt id="h2o_q.types.DatePicker.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>An optional tooltip message displayed when a user clicks the help icon to the right of the component.</p></div>
</dd>
<dt id="h2o_q.types.DatePicker.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>The date value in YYYY-MM-DD format.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.DatePicker.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;DatePicker.name is required.&#39;)
    return _dump(
        name=self.name,
        label=self.label,
        placeholder=self.placeholder,
        value=self.value,
        disabled=self.disabled,
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Dropdown"><code class="flex name class">
<span>class <span class="ident">Dropdown</span></span>
<span>(</span><span>name: str, label: Union[str, NoneType] = None, placeholder: Union[str, NoneType] = None, value: Union[str, NoneType] = None, values: Union[List[str], NoneType] = None, choices: Union[List[<a title="h2o_q.types.Choice" href="#h2o_q.types.Choice">Choice</a>], NoneType] = None, required: Union[bool, NoneType] = None, disabled: Union[bool, NoneType] = None, trigger: Union[bool, NoneType] = None, tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a dropdown.</p>
<p>A dropdown is a list in which the selected item is always visible, and the others are visible on demand by clicking
a drop-down button. They are used to simplify the design and make a choice within the UI. When closed, only the
selected item is visible. When users click the drop-down button, all the options become visible.</p>
<p>To change the value, users open the list and click another value or use the arrow keys (up and down) to
select a new value.</p>
<p>Note: Use either the 'value' parameter or the 'values' parameter. Setting the 'values' parameter renders a
multi-select dropdown.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Dropdown:
    &#34;&#34;&#34;Create a dropdown.

    A dropdown is a list in which the selected item is always visible, and the others are visible on demand by clicking
    a drop-down button. They are used to simplify the design and make a choice within the UI. When closed, only the
    selected item is visible. When users click the drop-down button, all the options become visible.

    To change the value, users open the list and click another value or use the arrow keys (up and down) to
    select a new value.

    Note: Use either the &#39;value&#39; parameter or the &#39;values&#39; parameter. Setting the &#39;values&#39; parameter renders a
    multi-select dropdown.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            placeholder: Optional[str] = None,
            value: Optional[str] = None,
            values: Optional[List[str]] = None,
            choices: Optional[List[Choice]] = None,
            required: Optional[bool] = None,
            disabled: Optional[bool] = None,
            trigger: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the component.&#34;&#34;&#34;
        self.placeholder = placeholder
        &#34;&#34;&#34;A string that provides a brief hint to the user as to what kind of information is expected in the field.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The name of the selected choice.&#34;&#34;&#34;
        self.values = values
        &#34;&#34;&#34;The names of the selected choices. If this parameter is set, multiple selections will be allowed.&#34;&#34;&#34;
        self.choices = choices
        &#34;&#34;&#34;The choices to be presented.&#34;&#34;&#34;
        self.required = required
        &#34;&#34;&#34;True if this is a required field.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if this field is disabled.&#34;&#34;&#34;
        self.trigger = trigger
        &#34;&#34;&#34;True if the form should be submitted when the dropdown value changes.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Dropdown.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            placeholder=self.placeholder,
            value=self.value,
            values=self.values,
            choices=None if self.choices is None else [__e.dump() for __e in self.choices],
            required=self.required,
            disabled=self.disabled,
            trigger=self.trigger,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Dropdown&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Dropdown.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_placeholder: Any = __d.get(&#39;placeholder&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_values: Any = __d.get(&#39;values&#39;)
        __d_choices: Any = __d.get(&#39;choices&#39;)
        __d_required: Any = __d.get(&#39;required&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_trigger: Any = __d.get(&#39;trigger&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        placeholder: Optional[str] = __d_placeholder
        value: Optional[str] = __d_value
        values: Optional[List[str]] = __d_values
        choices: Optional[List[Choice]] = None if __d_choices is None else [Choice.load(__e) for __e in __d_choices]
        required: Optional[bool] = __d_required
        disabled: Optional[bool] = __d_disabled
        trigger: Optional[bool] = __d_trigger
        tooltip: Optional[str] = __d_tooltip
        return Dropdown(
            name,
            label,
            placeholder,
            value,
            values,
            choices,
            required,
            disabled,
            trigger,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Dropdown.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Dropdown__d: Dict) ‑> <a title="h2o_q.types.Dropdown" href="#h2o_q.types.Dropdown">Dropdown</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Dropdown&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;Dropdown.name is required.&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    __d_placeholder: Any = __d.get(&#39;placeholder&#39;)
    __d_value: Any = __d.get(&#39;value&#39;)
    __d_values: Any = __d.get(&#39;values&#39;)
    __d_choices: Any = __d.get(&#39;choices&#39;)
    __d_required: Any = __d.get(&#39;required&#39;)
    __d_disabled: Any = __d.get(&#39;disabled&#39;)
    __d_trigger: Any = __d.get(&#39;trigger&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    name: str = __d_name
    label: Optional[str] = __d_label
    placeholder: Optional[str] = __d_placeholder
    value: Optional[str] = __d_value
    values: Optional[List[str]] = __d_values
    choices: Optional[List[Choice]] = None if __d_choices is None else [Choice.load(__e) for __e in __d_choices]
    required: Optional[bool] = __d_required
    disabled: Optional[bool] = __d_disabled
    trigger: Optional[bool] = __d_trigger
    tooltip: Optional[str] = __d_tooltip
    return Dropdown(
        name,
        label,
        placeholder,
        value,
        values,
        choices,
        required,
        disabled,
        trigger,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Dropdown.choices"><code class="name">var <span class="ident">choices</span></code></dt>
<dd>
<div class="desc"><p>The choices to be presented.</p></div>
</dd>
<dt id="h2o_q.types.Dropdown.disabled"><code class="name">var <span class="ident">disabled</span></code></dt>
<dd>
<div class="desc"><p>True if this field is disabled.</p></div>
</dd>
<dt id="h2o_q.types.Dropdown.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>Text to be displayed alongside the component.</p></div>
</dd>
<dt id="h2o_q.types.Dropdown.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this component.</p></div>
</dd>
<dt id="h2o_q.types.Dropdown.placeholder"><code class="name">var <span class="ident">placeholder</span></code></dt>
<dd>
<div class="desc"><p>A string that provides a brief hint to the user as to what kind of information is expected in the field.</p></div>
</dd>
<dt id="h2o_q.types.Dropdown.required"><code class="name">var <span class="ident">required</span></code></dt>
<dd>
<div class="desc"><p>True if this is a required field.</p></div>
</dd>
<dt id="h2o_q.types.Dropdown.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>An optional tooltip message displayed when a user clicks the help icon to the right of the component.</p></div>
</dd>
<dt id="h2o_q.types.Dropdown.trigger"><code class="name">var <span class="ident">trigger</span></code></dt>
<dd>
<div class="desc"><p>True if the form should be submitted when the dropdown value changes.</p></div>
</dd>
<dt id="h2o_q.types.Dropdown.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>The name of the selected choice.</p></div>
</dd>
<dt id="h2o_q.types.Dropdown.values"><code class="name">var <span class="ident">values</span></code></dt>
<dd>
<div class="desc"><p>The names of the selected choices. If this parameter is set, multiple selections will be allowed.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Dropdown.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;Dropdown.name is required.&#39;)
    return _dump(
        name=self.name,
        label=self.label,
        placeholder=self.placeholder,
        value=self.value,
        values=self.values,
        choices=None if self.choices is None else [__e.dump() for __e in self.choices],
        required=self.required,
        disabled=self.disabled,
        trigger=self.trigger,
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Expander"><code class="flex name class">
<span>class <span class="ident">Expander</span></span>
<span>(</span><span>name: str, label: Union[str, NoneType] = None, expanded: Union[bool, NoneType] = None, items: Union[List[ForwardRef('<a title="h2o_q.types.Component" href="#h2o_q.types.Component">Component</a>')], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new expander.</p>
<p>Expanders can be used to show or hide a group of related components.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Expander:
    &#34;&#34;&#34;Creates a new expander.

    Expanders can be used to show or hide a group of related components.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            expanded: Optional[bool] = None,
            items: Optional[List[&#39;Component&#39;]] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;The text displayed on the expander.&#34;&#34;&#34;
        self.expanded = expanded
        &#34;&#34;&#34;True if expanded, False if collapsed.&#34;&#34;&#34;
        self.items = items
        &#34;&#34;&#34;List of components to be hideable by the expander.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Expander.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            expanded=self.expanded,
            items=None if self.items is None else [__e.dump() for __e in self.items],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Expander&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Expander.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_expanded: Any = __d.get(&#39;expanded&#39;)
        __d_items: Any = __d.get(&#39;items&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        expanded: Optional[bool] = __d_expanded
        items: Optional[List[&#39;Component&#39;]] = None if __d_items is None else [Component.load(__e) for __e in __d_items]
        return Expander(
            name,
            label,
            expanded,
            items,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Expander.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Expander__d: Dict) ‑> <a title="h2o_q.types.Expander" href="#h2o_q.types.Expander">Expander</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Expander&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;Expander.name is required.&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    __d_expanded: Any = __d.get(&#39;expanded&#39;)
    __d_items: Any = __d.get(&#39;items&#39;)
    name: str = __d_name
    label: Optional[str] = __d_label
    expanded: Optional[bool] = __d_expanded
    items: Optional[List[&#39;Component&#39;]] = None if __d_items is None else [Component.load(__e) for __e in __d_items]
    return Expander(
        name,
        label,
        expanded,
        items,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Expander.expanded"><code class="name">var <span class="ident">expanded</span></code></dt>
<dd>
<div class="desc"><p>True if expanded, False if collapsed.</p></div>
</dd>
<dt id="h2o_q.types.Expander.items"><code class="name">var <span class="ident">items</span></code></dt>
<dd>
<div class="desc"><p>List of components to be hideable by the expander.</p></div>
</dd>
<dt id="h2o_q.types.Expander.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>The text displayed on the expander.</p></div>
</dd>
<dt id="h2o_q.types.Expander.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this component.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Expander.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;Expander.name is required.&#39;)
    return _dump(
        name=self.name,
        label=self.label,
        expanded=self.expanded,
        items=None if self.items is None else [__e.dump() for __e in self.items],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.FileUpload"><code class="flex name class">
<span>class <span class="ident">FileUpload</span></span>
<span>(</span><span>name: str, label: Union[str, NoneType] = None, multiple: Union[bool, NoneType] = None, file_extensions: Union[List[str], NoneType] = None, max_file_size: Union[float, NoneType] = None, max_size: Union[float, NoneType] = None, tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a file upload component.
A file upload component allows a user to browse, select and upload one or more files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileUpload:
    &#34;&#34;&#34;Create a file upload component.
    A file upload component allows a user to browse, select and upload one or more files.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            multiple: Optional[bool] = None,
            file_extensions: Optional[List[str]] = None,
            max_file_size: Optional[float] = None,
            max_size: Optional[float] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the component.&#34;&#34;&#34;
        self.multiple = multiple
        &#34;&#34;&#34;True if the component should allow multiple files to be uploaded.&#34;&#34;&#34;
        self.file_extensions = file_extensions
        &#34;&#34;&#34;List of allowed file extensions, e.g. `pdf`, `docx`, etc.&#34;&#34;&#34;
        self.max_file_size = max_file_size
        &#34;&#34;&#34;Maximum allowed size (Mb) per file. Defaults to no limit.&#34;&#34;&#34;
        self.max_size = max_size
        &#34;&#34;&#34;Maximum allowed size (Mb) for all files combined. Defaults to no limit.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;FileUpload.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            multiple=self.multiple,
            file_extensions=self.file_extensions,
            max_file_size=self.max_file_size,
            max_size=self.max_size,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;FileUpload&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;FileUpload.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_multiple: Any = __d.get(&#39;multiple&#39;)
        __d_file_extensions: Any = __d.get(&#39;file_extensions&#39;)
        __d_max_file_size: Any = __d.get(&#39;max_file_size&#39;)
        __d_max_size: Any = __d.get(&#39;max_size&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        multiple: Optional[bool] = __d_multiple
        file_extensions: Optional[List[str]] = __d_file_extensions
        max_file_size: Optional[float] = __d_max_file_size
        max_size: Optional[float] = __d_max_size
        tooltip: Optional[str] = __d_tooltip
        return FileUpload(
            name,
            label,
            multiple,
            file_extensions,
            max_file_size,
            max_size,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.FileUpload.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_FileUpload__d: Dict) ‑> <a title="h2o_q.types.FileUpload" href="#h2o_q.types.FileUpload">FileUpload</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;FileUpload&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;FileUpload.name is required.&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    __d_multiple: Any = __d.get(&#39;multiple&#39;)
    __d_file_extensions: Any = __d.get(&#39;file_extensions&#39;)
    __d_max_file_size: Any = __d.get(&#39;max_file_size&#39;)
    __d_max_size: Any = __d.get(&#39;max_size&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    name: str = __d_name
    label: Optional[str] = __d_label
    multiple: Optional[bool] = __d_multiple
    file_extensions: Optional[List[str]] = __d_file_extensions
    max_file_size: Optional[float] = __d_max_file_size
    max_size: Optional[float] = __d_max_size
    tooltip: Optional[str] = __d_tooltip
    return FileUpload(
        name,
        label,
        multiple,
        file_extensions,
        max_file_size,
        max_size,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.FileUpload.file_extensions"><code class="name">var <span class="ident">file_extensions</span></code></dt>
<dd>
<div class="desc"><p>List of allowed file extensions, e.g. <code>pdf</code>, <code>docx</code>, etc.</p></div>
</dd>
<dt id="h2o_q.types.FileUpload.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>Text to be displayed alongside the component.</p></div>
</dd>
<dt id="h2o_q.types.FileUpload.max_file_size"><code class="name">var <span class="ident">max_file_size</span></code></dt>
<dd>
<div class="desc"><p>Maximum allowed size (Mb) per file. Defaults to no limit.</p></div>
</dd>
<dt id="h2o_q.types.FileUpload.max_size"><code class="name">var <span class="ident">max_size</span></code></dt>
<dd>
<div class="desc"><p>Maximum allowed size (Mb) for all files combined. Defaults to no limit.</p></div>
</dd>
<dt id="h2o_q.types.FileUpload.multiple"><code class="name">var <span class="ident">multiple</span></code></dt>
<dd>
<div class="desc"><p>True if the component should allow multiple files to be uploaded.</p></div>
</dd>
<dt id="h2o_q.types.FileUpload.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this component.</p></div>
</dd>
<dt id="h2o_q.types.FileUpload.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>An optional tooltip message displayed when a user clicks the help icon to the right of the component.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.FileUpload.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;FileUpload.name is required.&#39;)
    return _dump(
        name=self.name,
        label=self.label,
        multiple=self.multiple,
        file_extensions=self.file_extensions,
        max_file_size=self.max_file_size,
        max_size=self.max_size,
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.FlexCard"><code class="flex name class">
<span>class <span class="ident">FlexCard</span></span>
<span>(</span><span>box: str, item_view: str, item_props: Union[dict, str], data: Union[<a title="h2o_q.core.Data" href="core.html#h2o_q.core.Data">Data</a>, str], direction: Union[str, NoneType] = None, justify: Union[str, NoneType] = None, align: Union[str, NoneType] = None, wrap: Union[str, NoneType] = None, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>EXPERIMENTAL. DO NOT USE.
Create a card containing other cards laid out using a one-dimensional model with flexible alignemnt and wrapping capabilities.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FlexCard:
    &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.
    Create a card containing other cards laid out using a one-dimensional model with flexible alignemnt and wrapping capabilities.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            item_view: str,
            item_props: PackedRecord,
            data: PackedData,
            direction: Optional[str] = None,
            justify: Optional[str] = None,
            align: Optional[str] = None,
            wrap: Optional[str] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.item_view = item_view
        &#34;&#34;&#34;The child card type.&#34;&#34;&#34;
        self.item_props = item_props
        &#34;&#34;&#34;The child card properties.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.direction = direction
        &#34;&#34;&#34;Layout direction. One of &#39;horizontal&#39;, &#39;vertical&#39;.&#34;&#34;&#34;
        self.justify = justify
        &#34;&#34;&#34;Layout strategy for main axis. One of &#39;start&#39;, &#39;end&#39;, &#39;center&#39;, &#39;between&#39;, &#39;around&#39;.&#34;&#34;&#34;
        self.align = align
        &#34;&#34;&#34;Layout strategy for cross axis. One of &#39;start&#39;, &#39;end&#39;, &#39;center&#39;, &#39;baseline&#39;, &#39;stretch&#39;.&#34;&#34;&#34;
        self.wrap = wrap
        &#34;&#34;&#34;Wrapping strategy. One of &#39;start&#39;, &#39;end&#39;, &#39;center&#39;, &#39;between&#39;, &#39;around&#39;, &#39;stretch&#39;.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;FlexCard.box is required.&#39;)
        if self.item_view is None:
            raise ValueError(&#39;FlexCard.item_view is required.&#39;)
        if self.item_props is None:
            raise ValueError(&#39;FlexCard.item_props is required.&#39;)
        if self.data is None:
            raise ValueError(&#39;FlexCard.data is required.&#39;)
        return _dump(
            view=&#39;flex&#39;,
            box=self.box,
            item_view=self.item_view,
            item_props=self.item_props,
            data=self.data,
            direction=self.direction,
            justify=self.justify,
            align=self.align,
            wrap=self.wrap,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;FlexCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;FlexCard.box is required.&#39;)
        __d_item_view: Any = __d.get(&#39;item_view&#39;)
        if __d_item_view is None:
            raise ValueError(&#39;FlexCard.item_view is required.&#39;)
        __d_item_props: Any = __d.get(&#39;item_props&#39;)
        if __d_item_props is None:
            raise ValueError(&#39;FlexCard.item_props is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        if __d_data is None:
            raise ValueError(&#39;FlexCard.data is required.&#39;)
        __d_direction: Any = __d.get(&#39;direction&#39;)
        __d_justify: Any = __d.get(&#39;justify&#39;)
        __d_align: Any = __d.get(&#39;align&#39;)
        __d_wrap: Any = __d.get(&#39;wrap&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        item_view: str = __d_item_view
        item_props: PackedRecord = __d_item_props
        data: PackedData = __d_data
        direction: Optional[str] = __d_direction
        justify: Optional[str] = __d_justify
        align: Optional[str] = __d_align
        wrap: Optional[str] = __d_wrap
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return FlexCard(
            box,
            item_view,
            item_props,
            data,
            direction,
            justify,
            align,
            wrap,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.FlexCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_FlexCard__d: Dict) ‑> <a title="h2o_q.types.FlexCard" href="#h2o_q.types.FlexCard">FlexCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;FlexCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;FlexCard.box is required.&#39;)
    __d_item_view: Any = __d.get(&#39;item_view&#39;)
    if __d_item_view is None:
        raise ValueError(&#39;FlexCard.item_view is required.&#39;)
    __d_item_props: Any = __d.get(&#39;item_props&#39;)
    if __d_item_props is None:
        raise ValueError(&#39;FlexCard.item_props is required.&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    if __d_data is None:
        raise ValueError(&#39;FlexCard.data is required.&#39;)
    __d_direction: Any = __d.get(&#39;direction&#39;)
    __d_justify: Any = __d.get(&#39;justify&#39;)
    __d_align: Any = __d.get(&#39;align&#39;)
    __d_wrap: Any = __d.get(&#39;wrap&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    item_view: str = __d_item_view
    item_props: PackedRecord = __d_item_props
    data: PackedData = __d_data
    direction: Optional[str] = __d_direction
    justify: Optional[str] = __d_justify
    align: Optional[str] = __d_align
    wrap: Optional[str] = __d_wrap
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return FlexCard(
        box,
        item_view,
        item_props,
        data,
        direction,
        justify,
        align,
        wrap,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.FlexCard.align"><code class="name">var <span class="ident">align</span></code></dt>
<dd>
<div class="desc"><p>Layout strategy for cross axis. One of 'start', 'end', 'center', 'baseline', 'stretch'.</p></div>
</dd>
<dt id="h2o_q.types.FlexCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.FlexCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.FlexCard.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Data for this card.</p></div>
</dd>
<dt id="h2o_q.types.FlexCard.direction"><code class="name">var <span class="ident">direction</span></code></dt>
<dd>
<div class="desc"><p>Layout direction. One of 'horizontal', 'vertical'.</p></div>
</dd>
<dt id="h2o_q.types.FlexCard.item_props"><code class="name">var <span class="ident">item_props</span></code></dt>
<dd>
<div class="desc"><p>The child card properties.</p></div>
</dd>
<dt id="h2o_q.types.FlexCard.item_view"><code class="name">var <span class="ident">item_view</span></code></dt>
<dd>
<div class="desc"><p>The child card type.</p></div>
</dd>
<dt id="h2o_q.types.FlexCard.justify"><code class="name">var <span class="ident">justify</span></code></dt>
<dd>
<div class="desc"><p>Layout strategy for main axis. One of 'start', 'end', 'center', 'between', 'around'.</p></div>
</dd>
<dt id="h2o_q.types.FlexCard.wrap"><code class="name">var <span class="ident">wrap</span></code></dt>
<dd>
<div class="desc"><p>Wrapping strategy. One of 'start', 'end', 'center', 'between', 'around', 'stretch'.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.FlexCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;FlexCard.box is required.&#39;)
    if self.item_view is None:
        raise ValueError(&#39;FlexCard.item_view is required.&#39;)
    if self.item_props is None:
        raise ValueError(&#39;FlexCard.item_props is required.&#39;)
    if self.data is None:
        raise ValueError(&#39;FlexCard.data is required.&#39;)
    return _dump(
        view=&#39;flex&#39;,
        box=self.box,
        item_view=self.item_view,
        item_props=self.item_props,
        data=self.data,
        direction=self.direction,
        justify=self.justify,
        align=self.align,
        wrap=self.wrap,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.FormCard"><code class="flex name class">
<span>class <span class="ident">FormCard</span></span>
<span>(</span><span>box: str, items: Union[List[<a title="h2o_q.types.Component" href="#h2o_q.types.Component">Component</a>], str], commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a form.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FormCard:
    &#34;&#34;&#34;Create a form.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            items: Union[List[Component], str],
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.items = items
        &#34;&#34;&#34;The components in this form.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;FormCard.box is required.&#39;)
        if self.items is None:
            raise ValueError(&#39;FormCard.items is required.&#39;)
        return _dump(
            view=&#39;form&#39;,
            box=self.box,
            items=self.items if isinstance(self.items, str) else [__e.dump() for __e in self.items],
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;FormCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;FormCard.box is required.&#39;)
        __d_items: Any = __d.get(&#39;items&#39;)
        if __d_items is None:
            raise ValueError(&#39;FormCard.items is required.&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        items: Union[List[Component], str] = __d_items if isinstance(__d_items, str) else [Component.load(__e) for __e in __d_items]
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return FormCard(
            box,
            items,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.FormCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_FormCard__d: Dict) ‑> <a title="h2o_q.types.FormCard" href="#h2o_q.types.FormCard">FormCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;FormCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;FormCard.box is required.&#39;)
    __d_items: Any = __d.get(&#39;items&#39;)
    if __d_items is None:
        raise ValueError(&#39;FormCard.items is required.&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    items: Union[List[Component], str] = __d_items if isinstance(__d_items, str) else [Component.load(__e) for __e in __d_items]
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return FormCard(
        box,
        items,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.FormCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.FormCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.FormCard.items"><code class="name">var <span class="ident">items</span></code></dt>
<dd>
<div class="desc"><p>The components in this form.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.FormCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;FormCard.box is required.&#39;)
    if self.items is None:
        raise ValueError(&#39;FormCard.items is required.&#39;)
    return _dump(
        view=&#39;form&#39;,
        box=self.box,
        items=self.items if isinstance(self.items, str) else [__e.dump() for __e in self.items],
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Frame"><code class="flex name class">
<span>class <span class="ident">Frame</span></span>
<span>(</span><span>path: Union[str, NoneType] = None, content: Union[str, NoneType] = None, width: Union[str, NoneType] = None, height: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new inline frame (an <code>iframe</code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Frame:
    &#34;&#34;&#34;Create a new inline frame (an `iframe`).
    &#34;&#34;&#34;
    def __init__(
            self,
            path: Optional[str] = None,
            content: Optional[str] = None,
            width: Optional[str] = None,
            height: Optional[str] = None,
    ):
        self.path = path
        &#34;&#34;&#34;The path or URL of the web page, e.g. `/foo.html` or `http://example.com/foo.html`&#34;&#34;&#34;
        self.content = content
        &#34;&#34;&#34;The HTML content of the page. A string containing `&lt;html&gt;...&lt;/html&gt;`.&#34;&#34;&#34;
        self.width = width
        &#34;&#34;&#34;The width of the frame, e.g. `200px`, `50%`, etc. Defaults to `100%`.&#34;&#34;&#34;
        self.height = height
        &#34;&#34;&#34;The height of the frame, e.g. `200px`, `50%`, etc. Defaults to `150px`.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        return _dump(
            path=self.path,
            content=self.content,
            width=self.width,
            height=self.height,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Frame&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_path: Any = __d.get(&#39;path&#39;)
        __d_content: Any = __d.get(&#39;content&#39;)
        __d_width: Any = __d.get(&#39;width&#39;)
        __d_height: Any = __d.get(&#39;height&#39;)
        path: Optional[str] = __d_path
        content: Optional[str] = __d_content
        width: Optional[str] = __d_width
        height: Optional[str] = __d_height
        return Frame(
            path,
            content,
            width,
            height,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Frame.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Frame__d: Dict) ‑> <a title="h2o_q.types.Frame" href="#h2o_q.types.Frame">Frame</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Frame&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_path: Any = __d.get(&#39;path&#39;)
    __d_content: Any = __d.get(&#39;content&#39;)
    __d_width: Any = __d.get(&#39;width&#39;)
    __d_height: Any = __d.get(&#39;height&#39;)
    path: Optional[str] = __d_path
    content: Optional[str] = __d_content
    width: Optional[str] = __d_width
    height: Optional[str] = __d_height
    return Frame(
        path,
        content,
        width,
        height,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Frame.content"><code class="name">var <span class="ident">content</span></code></dt>
<dd>
<div class="desc"><p>The HTML content of the page. A string containing <code>&lt;html&gt;...&lt;/html&gt;</code>.</p></div>
</dd>
<dt id="h2o_q.types.Frame.height"><code class="name">var <span class="ident">height</span></code></dt>
<dd>
<div class="desc"><p>The height of the frame, e.g. <code>200px</code>, <code>50%</code>, etc. Defaults to <code>150px</code>.</p></div>
</dd>
<dt id="h2o_q.types.Frame.path"><code class="name">var <span class="ident">path</span></code></dt>
<dd>
<div class="desc"><p>The path or URL of the web page, e.g. <code>/foo.html</code> or <code>http://example.com/foo.html</code></p></div>
</dd>
<dt id="h2o_q.types.Frame.width"><code class="name">var <span class="ident">width</span></code></dt>
<dd>
<div class="desc"><p>The width of the frame, e.g. <code>200px</code>, <code>50%</code>, etc. Defaults to <code>100%</code>.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Frame.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    return _dump(
        path=self.path,
        content=self.content,
        width=self.width,
        height=self.height,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.FrameCard"><code class="flex name class">
<span>class <span class="ident">FrameCard</span></span>
<span>(</span><span>box: str, title: str, path: Union[str, NoneType] = None, content: Union[str, NoneType] = None, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Render a card containing a HTML page inside an inline frame (an <code>iframe</code>).</p>
<p>Either a path or content can be provided as arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FrameCard:
    &#34;&#34;&#34;Render a card containing a HTML page inside an inline frame (an `iframe`).

    Either a path or content can be provided as arguments.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            path: Optional[str] = None,
            content: Optional[str] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The title for this card.&#34;&#34;&#34;
        self.path = path
        &#34;&#34;&#34;The path or URL of the web page, e.g. `/foo.html` or `http://example.com/foo.html`&#34;&#34;&#34;
        self.content = content
        &#34;&#34;&#34;The HTML content of the page. A string containing `&lt;html&gt;...&lt;/html&gt;`&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;FrameCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;FrameCard.title is required.&#39;)
        return _dump(
            view=&#39;frame&#39;,
            box=self.box,
            title=self.title,
            path=self.path,
            content=self.content,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;FrameCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;FrameCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;FrameCard.title is required.&#39;)
        __d_path: Any = __d.get(&#39;path&#39;)
        __d_content: Any = __d.get(&#39;content&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        path: Optional[str] = __d_path
        content: Optional[str] = __d_content
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return FrameCard(
            box,
            title,
            path,
            content,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.FrameCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_FrameCard__d: Dict) ‑> <a title="h2o_q.types.FrameCard" href="#h2o_q.types.FrameCard">FrameCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;FrameCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;FrameCard.box is required.&#39;)
    __d_title: Any = __d.get(&#39;title&#39;)
    if __d_title is None:
        raise ValueError(&#39;FrameCard.title is required.&#39;)
    __d_path: Any = __d.get(&#39;path&#39;)
    __d_content: Any = __d.get(&#39;content&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    title: str = __d_title
    path: Optional[str] = __d_path
    content: Optional[str] = __d_content
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return FrameCard(
        box,
        title,
        path,
        content,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.FrameCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.FrameCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.FrameCard.content"><code class="name">var <span class="ident">content</span></code></dt>
<dd>
<div class="desc"><p>The HTML content of the page. A string containing <code>&lt;html&gt;...&lt;/html&gt;</code></p></div>
</dd>
<dt id="h2o_q.types.FrameCard.path"><code class="name">var <span class="ident">path</span></code></dt>
<dd>
<div class="desc"><p>The path or URL of the web page, e.g. <code>/foo.html</code> or <code>http://example.com/foo.html</code></p></div>
</dd>
<dt id="h2o_q.types.FrameCard.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>The title for this card.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.FrameCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;FrameCard.box is required.&#39;)
    if self.title is None:
        raise ValueError(&#39;FrameCard.title is required.&#39;)
    return _dump(
        view=&#39;frame&#39;,
        box=self.box,
        title=self.title,
        path=self.path,
        content=self.content,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.GraphicsCard"><code class="flex name class">
<span>class <span class="ident">GraphicsCard</span></span>
<span>(</span><span>box: str, view_box: str, stage: Union[List[dict], str, NoneType] = None, scene: Union[<a title="h2o_q.core.Data" href="core.html#h2o_q.core.Data">Data</a>, str, NoneType] = None, width: Union[str, NoneType] = None, height: Union[str, NoneType] = None, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a card for displaying vector graphics.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphicsCard:
    &#34;&#34;&#34;Create a card for displaying vector graphics.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            view_box: str,
            stage: Optional[PackedRecords] = None,
            scene: Optional[PackedData] = None,
            width: Optional[str] = None,
            height: Optional[str] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.view_box = view_box
        &#34;&#34;&#34;The position and dimension of the SVG viewport, in user space. A space-separated list of four numbers: min-x, min-y, width and height. For example, &#39;0 0 400 300&#39;. See: https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/viewBox&#34;&#34;&#34;
        self.stage = stage
        &#34;&#34;&#34;Background layer for rendering static SVG elements. Must be packed to conserve memory.&#34;&#34;&#34;
        self.scene = scene
        &#34;&#34;&#34;Foreground layer for rendering dynamic SVG elements.&#34;&#34;&#34;
        self.width = width
        &#34;&#34;&#34;The displayed width of the rectangular viewport. (Not the width of its coordinate system.)&#34;&#34;&#34;
        self.height = height
        &#34;&#34;&#34;The displayed height of the rectangular viewport. (Not the height of its coordinate system.)&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;GraphicsCard.box is required.&#39;)
        if self.view_box is None:
            raise ValueError(&#39;GraphicsCard.view_box is required.&#39;)
        return _dump(
            view=&#39;graphics&#39;,
            box=self.box,
            view_box=self.view_box,
            stage=self.stage,
            scene=self.scene,
            width=self.width,
            height=self.height,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;GraphicsCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;GraphicsCard.box is required.&#39;)
        __d_view_box: Any = __d.get(&#39;view_box&#39;)
        if __d_view_box is None:
            raise ValueError(&#39;GraphicsCard.view_box is required.&#39;)
        __d_stage: Any = __d.get(&#39;stage&#39;)
        __d_scene: Any = __d.get(&#39;scene&#39;)
        __d_width: Any = __d.get(&#39;width&#39;)
        __d_height: Any = __d.get(&#39;height&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        view_box: str = __d_view_box
        stage: Optional[PackedRecords] = __d_stage
        scene: Optional[PackedData] = __d_scene
        width: Optional[str] = __d_width
        height: Optional[str] = __d_height
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return GraphicsCard(
            box,
            view_box,
            stage,
            scene,
            width,
            height,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.GraphicsCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_GraphicsCard__d: Dict) ‑> <a title="h2o_q.types.GraphicsCard" href="#h2o_q.types.GraphicsCard">GraphicsCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;GraphicsCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;GraphicsCard.box is required.&#39;)
    __d_view_box: Any = __d.get(&#39;view_box&#39;)
    if __d_view_box is None:
        raise ValueError(&#39;GraphicsCard.view_box is required.&#39;)
    __d_stage: Any = __d.get(&#39;stage&#39;)
    __d_scene: Any = __d.get(&#39;scene&#39;)
    __d_width: Any = __d.get(&#39;width&#39;)
    __d_height: Any = __d.get(&#39;height&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    view_box: str = __d_view_box
    stage: Optional[PackedRecords] = __d_stage
    scene: Optional[PackedData] = __d_scene
    width: Optional[str] = __d_width
    height: Optional[str] = __d_height
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return GraphicsCard(
        box,
        view_box,
        stage,
        scene,
        width,
        height,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.GraphicsCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.GraphicsCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.GraphicsCard.height"><code class="name">var <span class="ident">height</span></code></dt>
<dd>
<div class="desc"><p>The displayed height of the rectangular viewport. (Not the height of its coordinate system.)</p></div>
</dd>
<dt id="h2o_q.types.GraphicsCard.scene"><code class="name">var <span class="ident">scene</span></code></dt>
<dd>
<div class="desc"><p>Foreground layer for rendering dynamic SVG elements.</p></div>
</dd>
<dt id="h2o_q.types.GraphicsCard.stage"><code class="name">var <span class="ident">stage</span></code></dt>
<dd>
<div class="desc"><p>Background layer for rendering static SVG elements. Must be packed to conserve memory.</p></div>
</dd>
<dt id="h2o_q.types.GraphicsCard.view_box"><code class="name">var <span class="ident">view_box</span></code></dt>
<dd>
<div class="desc"><p>The position and dimension of the SVG viewport, in user space. A space-separated list of four numbers: min-x, min-y, width and height. For example, '0 0 400 300'. See: <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/viewBox">https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/viewBox</a></p></div>
</dd>
<dt id="h2o_q.types.GraphicsCard.width"><code class="name">var <span class="ident">width</span></code></dt>
<dd>
<div class="desc"><p>The displayed width of the rectangular viewport. (Not the width of its coordinate system.)</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.GraphicsCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;GraphicsCard.box is required.&#39;)
    if self.view_box is None:
        raise ValueError(&#39;GraphicsCard.view_box is required.&#39;)
    return _dump(
        view=&#39;graphics&#39;,
        box=self.box,
        view_box=self.view_box,
        stage=self.stage,
        scene=self.scene,
        width=self.width,
        height=self.height,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.GridCard"><code class="flex name class">
<span>class <span class="ident">GridCard</span></span>
<span>(</span><span>box: str, title: str, cells: Union[<a title="h2o_q.core.Data" href="core.html#h2o_q.core.Data">Data</a>, str], data: Union[<a title="h2o_q.core.Data" href="core.html#h2o_q.core.Data">Data</a>, str], commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>EXPERIMENTAL. DO NOT USE.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GridCard:
    &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            cells: PackedData,
            data: PackedData,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.&#34;&#34;&#34;
        self.cells = cells
        &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;GridCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;GridCard.title is required.&#39;)
        if self.cells is None:
            raise ValueError(&#39;GridCard.cells is required.&#39;)
        if self.data is None:
            raise ValueError(&#39;GridCard.data is required.&#39;)
        return _dump(
            view=&#39;grid&#39;,
            box=self.box,
            title=self.title,
            cells=self.cells,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;GridCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;GridCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;GridCard.title is required.&#39;)
        __d_cells: Any = __d.get(&#39;cells&#39;)
        if __d_cells is None:
            raise ValueError(&#39;GridCard.cells is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        if __d_data is None:
            raise ValueError(&#39;GridCard.data is required.&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        cells: PackedData = __d_cells
        data: PackedData = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return GridCard(
            box,
            title,
            cells,
            data,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.GridCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_GridCard__d: Dict) ‑> <a title="h2o_q.types.GridCard" href="#h2o_q.types.GridCard">GridCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;GridCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;GridCard.box is required.&#39;)
    __d_title: Any = __d.get(&#39;title&#39;)
    if __d_title is None:
        raise ValueError(&#39;GridCard.title is required.&#39;)
    __d_cells: Any = __d.get(&#39;cells&#39;)
    if __d_cells is None:
        raise ValueError(&#39;GridCard.cells is required.&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    if __d_data is None:
        raise ValueError(&#39;GridCard.data is required.&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    title: str = __d_title
    cells: PackedData = __d_cells
    data: PackedData = __d_data
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return GridCard(
        box,
        title,
        cells,
        data,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.GridCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.GridCard.cells"><code class="name">var <span class="ident">cells</span></code></dt>
<dd>
<div class="desc"><p>EXPERIMENTAL. DO NOT USE.</p></div>
</dd>
<dt id="h2o_q.types.GridCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.GridCard.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>EXPERIMENTAL. DO NOT USE.</p></div>
</dd>
<dt id="h2o_q.types.GridCard.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>EXPERIMENTAL. DO NOT USE.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.GridCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;GridCard.box is required.&#39;)
    if self.title is None:
        raise ValueError(&#39;GridCard.title is required.&#39;)
    if self.cells is None:
        raise ValueError(&#39;GridCard.cells is required.&#39;)
    if self.data is None:
        raise ValueError(&#39;GridCard.data is required.&#39;)
    return _dump(
        view=&#39;grid&#39;,
        box=self.box,
        title=self.title,
        cells=self.cells,
        data=self.data,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.HeaderCard"><code class="flex name class">
<span>class <span class="ident">HeaderCard</span></span>
<span>(</span><span>box: str, title: str, subtitle: str, icon: Union[str, NoneType] = None, icon_color: Union[str, NoneType] = None, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Render a card containing a HTML page inside an inline frame (iframe).</p>
<p>Either a path or content can be provided as arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HeaderCard:
    &#34;&#34;&#34;Render a card containing a HTML page inside an inline frame (iframe).

    Either a path or content can be provided as arguments.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            subtitle: str,
            icon: Optional[str] = None,
            icon_color: Optional[str] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The title.&#34;&#34;&#34;
        self.subtitle = subtitle
        &#34;&#34;&#34;The subtitle, displayed below the title.&#34;&#34;&#34;
        self.icon = icon
        &#34;&#34;&#34;The icon type, displayed to the left.&#34;&#34;&#34;
        self.icon_color = icon_color
        &#34;&#34;&#34;The icon&#39;s color.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;HeaderCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;HeaderCard.title is required.&#39;)
        if self.subtitle is None:
            raise ValueError(&#39;HeaderCard.subtitle is required.&#39;)
        return _dump(
            view=&#39;header&#39;,
            box=self.box,
            title=self.title,
            subtitle=self.subtitle,
            icon=self.icon,
            icon_color=self.icon_color,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;HeaderCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;HeaderCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;HeaderCard.title is required.&#39;)
        __d_subtitle: Any = __d.get(&#39;subtitle&#39;)
        if __d_subtitle is None:
            raise ValueError(&#39;HeaderCard.subtitle is required.&#39;)
        __d_icon: Any = __d.get(&#39;icon&#39;)
        __d_icon_color: Any = __d.get(&#39;icon_color&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        subtitle: str = __d_subtitle
        icon: Optional[str] = __d_icon
        icon_color: Optional[str] = __d_icon_color
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return HeaderCard(
            box,
            title,
            subtitle,
            icon,
            icon_color,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.HeaderCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_HeaderCard__d: Dict) ‑> <a title="h2o_q.types.HeaderCard" href="#h2o_q.types.HeaderCard">HeaderCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;HeaderCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;HeaderCard.box is required.&#39;)
    __d_title: Any = __d.get(&#39;title&#39;)
    if __d_title is None:
        raise ValueError(&#39;HeaderCard.title is required.&#39;)
    __d_subtitle: Any = __d.get(&#39;subtitle&#39;)
    if __d_subtitle is None:
        raise ValueError(&#39;HeaderCard.subtitle is required.&#39;)
    __d_icon: Any = __d.get(&#39;icon&#39;)
    __d_icon_color: Any = __d.get(&#39;icon_color&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    title: str = __d_title
    subtitle: str = __d_subtitle
    icon: Optional[str] = __d_icon
    icon_color: Optional[str] = __d_icon_color
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return HeaderCard(
        box,
        title,
        subtitle,
        icon,
        icon_color,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.HeaderCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.HeaderCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.HeaderCard.icon"><code class="name">var <span class="ident">icon</span></code></dt>
<dd>
<div class="desc"><p>The icon type, displayed to the left.</p></div>
</dd>
<dt id="h2o_q.types.HeaderCard.icon_color"><code class="name">var <span class="ident">icon_color</span></code></dt>
<dd>
<div class="desc"><p>The icon's color.</p></div>
</dd>
<dt id="h2o_q.types.HeaderCard.subtitle"><code class="name">var <span class="ident">subtitle</span></code></dt>
<dd>
<div class="desc"><p>The subtitle, displayed below the title.</p></div>
</dd>
<dt id="h2o_q.types.HeaderCard.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>The title.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.HeaderCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;HeaderCard.box is required.&#39;)
    if self.title is None:
        raise ValueError(&#39;HeaderCard.title is required.&#39;)
    if self.subtitle is None:
        raise ValueError(&#39;HeaderCard.subtitle is required.&#39;)
    return _dump(
        view=&#39;header&#39;,
        box=self.box,
        title=self.title,
        subtitle=self.subtitle,
        icon=self.icon,
        icon_color=self.icon_color,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.IconTableCellType"><code class="flex name class">
<span>class <span class="ident">IconTableCellType</span></span>
<span>(</span><span>color: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a cell type that renders a column's cells as icons instead of plain text.
If set on a column, the cell value is interpreted as the name of the icon to be displayed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IconTableCellType:
    &#34;&#34;&#34;Create a cell type that renders a column&#39;s cells as icons instead of plain text.
    If set on a column, the cell value is interpreted as the name of the icon to be displayed.
    &#34;&#34;&#34;
    def __init__(
            self,
            color: Optional[str] = None,
    ):
        self.color = color
        &#34;&#34;&#34;Icon color.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        return _dump(
            color=self.color,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;IconTableCellType&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_color: Any = __d.get(&#39;color&#39;)
        color: Optional[str] = __d_color
        return IconTableCellType(
            color,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.IconTableCellType.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_IconTableCellType__d: Dict) ‑> <a title="h2o_q.types.IconTableCellType" href="#h2o_q.types.IconTableCellType">IconTableCellType</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;IconTableCellType&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_color: Any = __d.get(&#39;color&#39;)
    color: Optional[str] = __d_color
    return IconTableCellType(
        color,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.IconTableCellType.color"><code class="name">var <span class="ident">color</span></code></dt>
<dd>
<div class="desc"><p>Icon color.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.IconTableCellType.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    return _dump(
        color=self.color,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.ImageCard"><code class="flex name class">
<span>class <span class="ident">ImageCard</span></span>
<span>(</span><span>box: str, title: str, type: str, image: str, data: Union[dict, str, NoneType] = None, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a card that displays a base64-encoded image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImageCard:
    &#34;&#34;&#34;Create a card that displays a base64-encoded image.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            type: str,
            image: str,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The card&#39;s title.&#34;&#34;&#34;
        self.type = type
        &#34;&#34;&#34;The image MIME subtype. One of `apng`, `bmp`, `gif`, `x-icon`, `jpeg`, `png`, `webp`.&#34;&#34;&#34;
        self.image = image
        &#34;&#34;&#34;Image data, base64-encoded.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;ImageCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;ImageCard.title is required.&#39;)
        if self.type is None:
            raise ValueError(&#39;ImageCard.type is required.&#39;)
        if self.image is None:
            raise ValueError(&#39;ImageCard.image is required.&#39;)
        return _dump(
            view=&#39;image&#39;,
            box=self.box,
            title=self.title,
            type=self.type,
            image=self.image,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;ImageCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;ImageCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;ImageCard.title is required.&#39;)
        __d_type: Any = __d.get(&#39;type&#39;)
        if __d_type is None:
            raise ValueError(&#39;ImageCard.type is required.&#39;)
        __d_image: Any = __d.get(&#39;image&#39;)
        if __d_image is None:
            raise ValueError(&#39;ImageCard.image is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        type: str = __d_type
        image: str = __d_image
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return ImageCard(
            box,
            title,
            type,
            image,
            data,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.ImageCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_ImageCard__d: Dict) ‑> <a title="h2o_q.types.ImageCard" href="#h2o_q.types.ImageCard">ImageCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;ImageCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;ImageCard.box is required.&#39;)
    __d_title: Any = __d.get(&#39;title&#39;)
    if __d_title is None:
        raise ValueError(&#39;ImageCard.title is required.&#39;)
    __d_type: Any = __d.get(&#39;type&#39;)
    if __d_type is None:
        raise ValueError(&#39;ImageCard.type is required.&#39;)
    __d_image: Any = __d.get(&#39;image&#39;)
    if __d_image is None:
        raise ValueError(&#39;ImageCard.image is required.&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    title: str = __d_title
    type: str = __d_type
    image: str = __d_image
    data: Optional[PackedRecord] = __d_data
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return ImageCard(
        box,
        title,
        type,
        image,
        data,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.ImageCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.ImageCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.ImageCard.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Data for this card.</p></div>
</dd>
<dt id="h2o_q.types.ImageCard.image"><code class="name">var <span class="ident">image</span></code></dt>
<dd>
<div class="desc"><p>Image data, base64-encoded.</p></div>
</dd>
<dt id="h2o_q.types.ImageCard.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>The card's title.</p></div>
</dd>
<dt id="h2o_q.types.ImageCard.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><p>The image MIME subtype. One of <code>apng</code>, <code>bmp</code>, <code>gif</code>, <code>x-icon</code>, <code>jpeg</code>, <code>png</code>, <code>webp</code>.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.ImageCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;ImageCard.box is required.&#39;)
    if self.title is None:
        raise ValueError(&#39;ImageCard.title is required.&#39;)
    if self.type is None:
        raise ValueError(&#39;ImageCard.type is required.&#39;)
    if self.image is None:
        raise ValueError(&#39;ImageCard.image is required.&#39;)
    return _dump(
        view=&#39;image&#39;,
        box=self.box,
        title=self.title,
        type=self.type,
        image=self.image,
        data=self.data,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Label"><code class="flex name class">
<span>class <span class="ident">Label</span></span>
<span>(</span><span>label: str, required: Union[bool, NoneType] = None, disabled: Union[bool, NoneType] = None, tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a label.</p>
<p>Labels give a name or title to a component or group of components.
Labels should be in close proximity to the component or group they are paired with.
Some components, such as textboxes, dropdowns, or toggles, already have labels
incorporated, but other components may optionally add a Label if it helps inform
the user of the component’s purpose.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Label:
    &#34;&#34;&#34;Create a label.

    Labels give a name or title to a component or group of components.
    Labels should be in close proximity to the component or group they are paired with.
    Some components, such as textboxes, dropdowns, or toggles, already have labels
    incorporated, but other components may optionally add a Label if it helps inform
    the user of the component’s purpose.
    &#34;&#34;&#34;
    def __init__(
            self,
            label: str,
            required: Optional[bool] = None,
            disabled: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.label = label
        &#34;&#34;&#34;The text displayed on the label.&#34;&#34;&#34;
        self.required = required
        &#34;&#34;&#34;True if the field is required.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if the label should be disabled.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.label is None:
            raise ValueError(&#39;Label.label is required.&#39;)
        return _dump(
            label=self.label,
            required=self.required,
            disabled=self.disabled,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Label&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_label: Any = __d.get(&#39;label&#39;)
        if __d_label is None:
            raise ValueError(&#39;Label.label is required.&#39;)
        __d_required: Any = __d.get(&#39;required&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        label: str = __d_label
        required: Optional[bool] = __d_required
        disabled: Optional[bool] = __d_disabled
        tooltip: Optional[str] = __d_tooltip
        return Label(
            label,
            required,
            disabled,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Label.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Label__d: Dict) ‑> <a title="h2o_q.types.Label" href="#h2o_q.types.Label">Label</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Label&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_label: Any = __d.get(&#39;label&#39;)
    if __d_label is None:
        raise ValueError(&#39;Label.label is required.&#39;)
    __d_required: Any = __d.get(&#39;required&#39;)
    __d_disabled: Any = __d.get(&#39;disabled&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    label: str = __d_label
    required: Optional[bool] = __d_required
    disabled: Optional[bool] = __d_disabled
    tooltip: Optional[str] = __d_tooltip
    return Label(
        label,
        required,
        disabled,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Label.disabled"><code class="name">var <span class="ident">disabled</span></code></dt>
<dd>
<div class="desc"><p>True if the label should be disabled.</p></div>
</dd>
<dt id="h2o_q.types.Label.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>The text displayed on the label.</p></div>
</dd>
<dt id="h2o_q.types.Label.required"><code class="name">var <span class="ident">required</span></code></dt>
<dd>
<div class="desc"><p>True if the field is required.</p></div>
</dd>
<dt id="h2o_q.types.Label.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>An optional tooltip message displayed when a user clicks the help icon to the right of the component.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Label.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.label is None:
        raise ValueError(&#39;Label.label is required.&#39;)
    return _dump(
        label=self.label,
        required=self.required,
        disabled=self.disabled,
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.LargeBarStatCard"><code class="flex name class">
<span>class <span class="ident">LargeBarStatCard</span></span>
<span>(</span><span>box: str, title: str, caption: str, value: str, aux_value: str, value_caption: str, aux_value_caption: str, progress: float, plot_color: Union[str, NoneType] = None, data: Union[dict, str, NoneType] = None, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a large captioned card displaying a primary value, an auxiliary value and a progress bar, with captions for each value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LargeBarStatCard:
    &#34;&#34;&#34;Create a large captioned card displaying a primary value, an auxiliary value and a progress bar, with captions for each value.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            caption: str,
            value: str,
            aux_value: str,
            value_caption: str,
            aux_value_caption: str,
            progress: float,
            plot_color: Optional[str] = None,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The card&#39;s title.&#34;&#34;&#34;
        self.caption = caption
        &#34;&#34;&#34;The card&#39;s caption.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The primary value displayed.&#34;&#34;&#34;
        self.aux_value = aux_value
        &#34;&#34;&#34;The auxiliary value, typically a target value.&#34;&#34;&#34;
        self.value_caption = value_caption
        &#34;&#34;&#34;The caption displayed below the primary value.&#34;&#34;&#34;
        self.aux_value_caption = aux_value_caption
        &#34;&#34;&#34;The caption displayed below the auxiliary value.&#34;&#34;&#34;
        self.progress = progress
        &#34;&#34;&#34;The value of the progress bar, between 0 and 1.&#34;&#34;&#34;
        self.plot_color = plot_color
        &#34;&#34;&#34;The color of the progress bar.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;LargeBarStatCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;LargeBarStatCard.title is required.&#39;)
        if self.caption is None:
            raise ValueError(&#39;LargeBarStatCard.caption is required.&#39;)
        if self.value is None:
            raise ValueError(&#39;LargeBarStatCard.value is required.&#39;)
        if self.aux_value is None:
            raise ValueError(&#39;LargeBarStatCard.aux_value is required.&#39;)
        if self.value_caption is None:
            raise ValueError(&#39;LargeBarStatCard.value_caption is required.&#39;)
        if self.aux_value_caption is None:
            raise ValueError(&#39;LargeBarStatCard.aux_value_caption is required.&#39;)
        if self.progress is None:
            raise ValueError(&#39;LargeBarStatCard.progress is required.&#39;)
        return _dump(
            view=&#39;large_bar_stat&#39;,
            box=self.box,
            title=self.title,
            caption=self.caption,
            value=self.value,
            aux_value=self.aux_value,
            value_caption=self.value_caption,
            aux_value_caption=self.aux_value_caption,
            progress=self.progress,
            plot_color=self.plot_color,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;LargeBarStatCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;LargeBarStatCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;LargeBarStatCard.title is required.&#39;)
        __d_caption: Any = __d.get(&#39;caption&#39;)
        if __d_caption is None:
            raise ValueError(&#39;LargeBarStatCard.caption is required.&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        if __d_value is None:
            raise ValueError(&#39;LargeBarStatCard.value is required.&#39;)
        __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
        if __d_aux_value is None:
            raise ValueError(&#39;LargeBarStatCard.aux_value is required.&#39;)
        __d_value_caption: Any = __d.get(&#39;value_caption&#39;)
        if __d_value_caption is None:
            raise ValueError(&#39;LargeBarStatCard.value_caption is required.&#39;)
        __d_aux_value_caption: Any = __d.get(&#39;aux_value_caption&#39;)
        if __d_aux_value_caption is None:
            raise ValueError(&#39;LargeBarStatCard.aux_value_caption is required.&#39;)
        __d_progress: Any = __d.get(&#39;progress&#39;)
        if __d_progress is None:
            raise ValueError(&#39;LargeBarStatCard.progress is required.&#39;)
        __d_plot_color: Any = __d.get(&#39;plot_color&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        caption: str = __d_caption
        value: str = __d_value
        aux_value: str = __d_aux_value
        value_caption: str = __d_value_caption
        aux_value_caption: str = __d_aux_value_caption
        progress: float = __d_progress
        plot_color: Optional[str] = __d_plot_color
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return LargeBarStatCard(
            box,
            title,
            caption,
            value,
            aux_value,
            value_caption,
            aux_value_caption,
            progress,
            plot_color,
            data,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.LargeBarStatCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_LargeBarStatCard__d: Dict) ‑> <a title="h2o_q.types.LargeBarStatCard" href="#h2o_q.types.LargeBarStatCard">LargeBarStatCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;LargeBarStatCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;LargeBarStatCard.box is required.&#39;)
    __d_title: Any = __d.get(&#39;title&#39;)
    if __d_title is None:
        raise ValueError(&#39;LargeBarStatCard.title is required.&#39;)
    __d_caption: Any = __d.get(&#39;caption&#39;)
    if __d_caption is None:
        raise ValueError(&#39;LargeBarStatCard.caption is required.&#39;)
    __d_value: Any = __d.get(&#39;value&#39;)
    if __d_value is None:
        raise ValueError(&#39;LargeBarStatCard.value is required.&#39;)
    __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
    if __d_aux_value is None:
        raise ValueError(&#39;LargeBarStatCard.aux_value is required.&#39;)
    __d_value_caption: Any = __d.get(&#39;value_caption&#39;)
    if __d_value_caption is None:
        raise ValueError(&#39;LargeBarStatCard.value_caption is required.&#39;)
    __d_aux_value_caption: Any = __d.get(&#39;aux_value_caption&#39;)
    if __d_aux_value_caption is None:
        raise ValueError(&#39;LargeBarStatCard.aux_value_caption is required.&#39;)
    __d_progress: Any = __d.get(&#39;progress&#39;)
    if __d_progress is None:
        raise ValueError(&#39;LargeBarStatCard.progress is required.&#39;)
    __d_plot_color: Any = __d.get(&#39;plot_color&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    title: str = __d_title
    caption: str = __d_caption
    value: str = __d_value
    aux_value: str = __d_aux_value
    value_caption: str = __d_value_caption
    aux_value_caption: str = __d_aux_value_caption
    progress: float = __d_progress
    plot_color: Optional[str] = __d_plot_color
    data: Optional[PackedRecord] = __d_data
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return LargeBarStatCard(
        box,
        title,
        caption,
        value,
        aux_value,
        value_caption,
        aux_value_caption,
        progress,
        plot_color,
        data,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.LargeBarStatCard.aux_value"><code class="name">var <span class="ident">aux_value</span></code></dt>
<dd>
<div class="desc"><p>The auxiliary value, typically a target value.</p></div>
</dd>
<dt id="h2o_q.types.LargeBarStatCard.aux_value_caption"><code class="name">var <span class="ident">aux_value_caption</span></code></dt>
<dd>
<div class="desc"><p>The caption displayed below the auxiliary value.</p></div>
</dd>
<dt id="h2o_q.types.LargeBarStatCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.LargeBarStatCard.caption"><code class="name">var <span class="ident">caption</span></code></dt>
<dd>
<div class="desc"><p>The card's caption.</p></div>
</dd>
<dt id="h2o_q.types.LargeBarStatCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.LargeBarStatCard.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Data for this card.</p></div>
</dd>
<dt id="h2o_q.types.LargeBarStatCard.plot_color"><code class="name">var <span class="ident">plot_color</span></code></dt>
<dd>
<div class="desc"><p>The color of the progress bar.</p></div>
</dd>
<dt id="h2o_q.types.LargeBarStatCard.progress"><code class="name">var <span class="ident">progress</span></code></dt>
<dd>
<div class="desc"><p>The value of the progress bar, between 0 and 1.</p></div>
</dd>
<dt id="h2o_q.types.LargeBarStatCard.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>The card's title.</p></div>
</dd>
<dt id="h2o_q.types.LargeBarStatCard.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>The primary value displayed.</p></div>
</dd>
<dt id="h2o_q.types.LargeBarStatCard.value_caption"><code class="name">var <span class="ident">value_caption</span></code></dt>
<dd>
<div class="desc"><p>The caption displayed below the primary value.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.LargeBarStatCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;LargeBarStatCard.box is required.&#39;)
    if self.title is None:
        raise ValueError(&#39;LargeBarStatCard.title is required.&#39;)
    if self.caption is None:
        raise ValueError(&#39;LargeBarStatCard.caption is required.&#39;)
    if self.value is None:
        raise ValueError(&#39;LargeBarStatCard.value is required.&#39;)
    if self.aux_value is None:
        raise ValueError(&#39;LargeBarStatCard.aux_value is required.&#39;)
    if self.value_caption is None:
        raise ValueError(&#39;LargeBarStatCard.value_caption is required.&#39;)
    if self.aux_value_caption is None:
        raise ValueError(&#39;LargeBarStatCard.aux_value_caption is required.&#39;)
    if self.progress is None:
        raise ValueError(&#39;LargeBarStatCard.progress is required.&#39;)
    return _dump(
        view=&#39;large_bar_stat&#39;,
        box=self.box,
        title=self.title,
        caption=self.caption,
        value=self.value,
        aux_value=self.aux_value,
        value_caption=self.value_caption,
        aux_value_caption=self.aux_value_caption,
        progress=self.progress,
        plot_color=self.plot_color,
        data=self.data,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.LargeStatCard"><code class="flex name class">
<span>class <span class="ident">LargeStatCard</span></span>
<span>(</span><span>box: str, title: str, value: str, aux_value: str, caption: str, data: Union[dict, str, NoneType] = None, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a stat card displaying a primary value, an auxiliary value and a caption.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LargeStatCard:
    &#34;&#34;&#34;Create a stat card displaying a primary value, an auxiliary value and a caption.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            value: str,
            aux_value: str,
            caption: str,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The card&#39;s title.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The primary value displayed.&#34;&#34;&#34;
        self.aux_value = aux_value
        &#34;&#34;&#34;The auxiliary value displayed next to the primary value.&#34;&#34;&#34;
        self.caption = caption
        &#34;&#34;&#34;The caption displayed below the primary value.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;LargeStatCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;LargeStatCard.title is required.&#39;)
        if self.value is None:
            raise ValueError(&#39;LargeStatCard.value is required.&#39;)
        if self.aux_value is None:
            raise ValueError(&#39;LargeStatCard.aux_value is required.&#39;)
        if self.caption is None:
            raise ValueError(&#39;LargeStatCard.caption is required.&#39;)
        return _dump(
            view=&#39;large_stat&#39;,
            box=self.box,
            title=self.title,
            value=self.value,
            aux_value=self.aux_value,
            caption=self.caption,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;LargeStatCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;LargeStatCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;LargeStatCard.title is required.&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        if __d_value is None:
            raise ValueError(&#39;LargeStatCard.value is required.&#39;)
        __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
        if __d_aux_value is None:
            raise ValueError(&#39;LargeStatCard.aux_value is required.&#39;)
        __d_caption: Any = __d.get(&#39;caption&#39;)
        if __d_caption is None:
            raise ValueError(&#39;LargeStatCard.caption is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        value: str = __d_value
        aux_value: str = __d_aux_value
        caption: str = __d_caption
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return LargeStatCard(
            box,
            title,
            value,
            aux_value,
            caption,
            data,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.LargeStatCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_LargeStatCard__d: Dict) ‑> <a title="h2o_q.types.LargeStatCard" href="#h2o_q.types.LargeStatCard">LargeStatCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;LargeStatCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;LargeStatCard.box is required.&#39;)
    __d_title: Any = __d.get(&#39;title&#39;)
    if __d_title is None:
        raise ValueError(&#39;LargeStatCard.title is required.&#39;)
    __d_value: Any = __d.get(&#39;value&#39;)
    if __d_value is None:
        raise ValueError(&#39;LargeStatCard.value is required.&#39;)
    __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
    if __d_aux_value is None:
        raise ValueError(&#39;LargeStatCard.aux_value is required.&#39;)
    __d_caption: Any = __d.get(&#39;caption&#39;)
    if __d_caption is None:
        raise ValueError(&#39;LargeStatCard.caption is required.&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    title: str = __d_title
    value: str = __d_value
    aux_value: str = __d_aux_value
    caption: str = __d_caption
    data: Optional[PackedRecord] = __d_data
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return LargeStatCard(
        box,
        title,
        value,
        aux_value,
        caption,
        data,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.LargeStatCard.aux_value"><code class="name">var <span class="ident">aux_value</span></code></dt>
<dd>
<div class="desc"><p>The auxiliary value displayed next to the primary value.</p></div>
</dd>
<dt id="h2o_q.types.LargeStatCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.LargeStatCard.caption"><code class="name">var <span class="ident">caption</span></code></dt>
<dd>
<div class="desc"><p>The caption displayed below the primary value.</p></div>
</dd>
<dt id="h2o_q.types.LargeStatCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.LargeStatCard.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Data for this card.</p></div>
</dd>
<dt id="h2o_q.types.LargeStatCard.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>The card's title.</p></div>
</dd>
<dt id="h2o_q.types.LargeStatCard.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>The primary value displayed.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.LargeStatCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;LargeStatCard.box is required.&#39;)
    if self.title is None:
        raise ValueError(&#39;LargeStatCard.title is required.&#39;)
    if self.value is None:
        raise ValueError(&#39;LargeStatCard.value is required.&#39;)
    if self.aux_value is None:
        raise ValueError(&#39;LargeStatCard.aux_value is required.&#39;)
    if self.caption is None:
        raise ValueError(&#39;LargeStatCard.caption is required.&#39;)
    return _dump(
        view=&#39;large_stat&#39;,
        box=self.box,
        title=self.title,
        value=self.value,
        aux_value=self.aux_value,
        caption=self.caption,
        data=self.data,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Link"><code class="flex name class">
<span>class <span class="ident">Link</span></span>
<span>(</span><span>label: Union[str, NoneType] = None, path: Union[str, NoneType] = None, disabled: Union[bool, NoneType] = None, download: Union[bool, NoneType] = None, button: Union[bool, NoneType] = None, tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a hyperlink.</p>
<p>Hyperlinks can be internal or external.
Internal hyperlinks have paths that begin with a <code>/</code> and point to URLs within the Q UI.
All other kinds of paths are treated as external hyperlinks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Link:
    &#34;&#34;&#34;Create a hyperlink.

    Hyperlinks can be internal or external.
    Internal hyperlinks have paths that begin with a `/` and point to URLs within the Q UI.
    All other kinds of paths are treated as external hyperlinks.
    &#34;&#34;&#34;
    def __init__(
            self,
            label: Optional[str] = None,
            path: Optional[str] = None,
            disabled: Optional[bool] = None,
            download: Optional[bool] = None,
            button: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.label = label
        &#34;&#34;&#34;The text to be displayed. If blank, the `path` is used as the label.&#34;&#34;&#34;
        self.path = path
        &#34;&#34;&#34;The path or URL to link to.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if the link should be disabled.&#34;&#34;&#34;
        self.download = download
        &#34;&#34;&#34;True if the link should be used for file download.&#34;&#34;&#34;
        self.button = button
        &#34;&#34;&#34;True if the link should be rendered as a button.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        return _dump(
            label=self.label,
            path=self.path,
            disabled=self.disabled,
            download=self.download,
            button=self.button,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Link&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_path: Any = __d.get(&#39;path&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_download: Any = __d.get(&#39;download&#39;)
        __d_button: Any = __d.get(&#39;button&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        label: Optional[str] = __d_label
        path: Optional[str] = __d_path
        disabled: Optional[bool] = __d_disabled
        download: Optional[bool] = __d_download
        button: Optional[bool] = __d_button
        tooltip: Optional[str] = __d_tooltip
        return Link(
            label,
            path,
            disabled,
            download,
            button,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Link.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Link__d: Dict) ‑> <a title="h2o_q.types.Link" href="#h2o_q.types.Link">Link</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Link&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_label: Any = __d.get(&#39;label&#39;)
    __d_path: Any = __d.get(&#39;path&#39;)
    __d_disabled: Any = __d.get(&#39;disabled&#39;)
    __d_download: Any = __d.get(&#39;download&#39;)
    __d_button: Any = __d.get(&#39;button&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    label: Optional[str] = __d_label
    path: Optional[str] = __d_path
    disabled: Optional[bool] = __d_disabled
    download: Optional[bool] = __d_download
    button: Optional[bool] = __d_button
    tooltip: Optional[str] = __d_tooltip
    return Link(
        label,
        path,
        disabled,
        download,
        button,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Link.button"><code class="name">var <span class="ident">button</span></code></dt>
<dd>
<div class="desc"><p>True if the link should be rendered as a button.</p></div>
</dd>
<dt id="h2o_q.types.Link.disabled"><code class="name">var <span class="ident">disabled</span></code></dt>
<dd>
<div class="desc"><p>True if the link should be disabled.</p></div>
</dd>
<dt id="h2o_q.types.Link.download"><code class="name">var <span class="ident">download</span></code></dt>
<dd>
<div class="desc"><p>True if the link should be used for file download.</p></div>
</dd>
<dt id="h2o_q.types.Link.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>The text to be displayed. If blank, the <code>path</code> is used as the label.</p></div>
</dd>
<dt id="h2o_q.types.Link.path"><code class="name">var <span class="ident">path</span></code></dt>
<dd>
<div class="desc"><p>The path or URL to link to.</p></div>
</dd>
<dt id="h2o_q.types.Link.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>An optional tooltip message displayed when a user clicks the help icon to the right of the component.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Link.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    return _dump(
        label=self.label,
        path=self.path,
        disabled=self.disabled,
        download=self.download,
        button=self.button,
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.ListCard"><code class="flex name class">
<span>class <span class="ident">ListCard</span></span>
<span>(</span><span>box: str, title: str, item_view: str, item_props: Union[dict, str], data: Union[<a title="h2o_q.core.Data" href="core.html#h2o_q.core.Data">Data</a>, str], commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>EXPERIMENTAL. DO NOT USE.
Create a card containing other cards laid out in the form of a list (vertically, top-to-bottom).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ListCard:
    &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.
    Create a card containing other cards laid out in the form of a list (vertically, top-to-bottom).
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            item_view: str,
            item_props: PackedRecord,
            data: PackedData,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The title for this card.&#34;&#34;&#34;
        self.item_view = item_view
        &#34;&#34;&#34;The child card type.&#34;&#34;&#34;
        self.item_props = item_props
        &#34;&#34;&#34;The child card properties.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;ListCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;ListCard.title is required.&#39;)
        if self.item_view is None:
            raise ValueError(&#39;ListCard.item_view is required.&#39;)
        if self.item_props is None:
            raise ValueError(&#39;ListCard.item_props is required.&#39;)
        if self.data is None:
            raise ValueError(&#39;ListCard.data is required.&#39;)
        return _dump(
            view=&#39;list&#39;,
            box=self.box,
            title=self.title,
            item_view=self.item_view,
            item_props=self.item_props,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;ListCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;ListCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;ListCard.title is required.&#39;)
        __d_item_view: Any = __d.get(&#39;item_view&#39;)
        if __d_item_view is None:
            raise ValueError(&#39;ListCard.item_view is required.&#39;)
        __d_item_props: Any = __d.get(&#39;item_props&#39;)
        if __d_item_props is None:
            raise ValueError(&#39;ListCard.item_props is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        if __d_data is None:
            raise ValueError(&#39;ListCard.data is required.&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        item_view: str = __d_item_view
        item_props: PackedRecord = __d_item_props
        data: PackedData = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return ListCard(
            box,
            title,
            item_view,
            item_props,
            data,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.ListCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_ListCard__d: Dict) ‑> <a title="h2o_q.types.ListCard" href="#h2o_q.types.ListCard">ListCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;ListCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;ListCard.box is required.&#39;)
    __d_title: Any = __d.get(&#39;title&#39;)
    if __d_title is None:
        raise ValueError(&#39;ListCard.title is required.&#39;)
    __d_item_view: Any = __d.get(&#39;item_view&#39;)
    if __d_item_view is None:
        raise ValueError(&#39;ListCard.item_view is required.&#39;)
    __d_item_props: Any = __d.get(&#39;item_props&#39;)
    if __d_item_props is None:
        raise ValueError(&#39;ListCard.item_props is required.&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    if __d_data is None:
        raise ValueError(&#39;ListCard.data is required.&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    title: str = __d_title
    item_view: str = __d_item_view
    item_props: PackedRecord = __d_item_props
    data: PackedData = __d_data
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return ListCard(
        box,
        title,
        item_view,
        item_props,
        data,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.ListCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.ListCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.ListCard.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Data for this card.</p></div>
</dd>
<dt id="h2o_q.types.ListCard.item_props"><code class="name">var <span class="ident">item_props</span></code></dt>
<dd>
<div class="desc"><p>The child card properties.</p></div>
</dd>
<dt id="h2o_q.types.ListCard.item_view"><code class="name">var <span class="ident">item_view</span></code></dt>
<dd>
<div class="desc"><p>The child card type.</p></div>
</dd>
<dt id="h2o_q.types.ListCard.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>The title for this card.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.ListCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;ListCard.box is required.&#39;)
    if self.title is None:
        raise ValueError(&#39;ListCard.title is required.&#39;)
    if self.item_view is None:
        raise ValueError(&#39;ListCard.item_view is required.&#39;)
    if self.item_props is None:
        raise ValueError(&#39;ListCard.item_props is required.&#39;)
    if self.data is None:
        raise ValueError(&#39;ListCard.data is required.&#39;)
    return _dump(
        view=&#39;list&#39;,
        box=self.box,
        title=self.title,
        item_view=self.item_view,
        item_props=self.item_props,
        data=self.data,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.ListItem1Card"><code class="flex name class">
<span>class <span class="ident">ListItem1Card</span></span>
<span>(</span><span>box: str, title: str, caption: str, value: str, aux_value: str, data: Union[dict, str], commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>EXPERIMENTAL. DO NOT USE.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ListItem1Card:
    &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            caption: str,
            value: str,
            aux_value: str,
            data: PackedRecord,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.&#34;&#34;&#34;
        self.caption = caption
        &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.&#34;&#34;&#34;
        self.aux_value = aux_value
        &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;ListItem1Card.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;ListItem1Card.title is required.&#39;)
        if self.caption is None:
            raise ValueError(&#39;ListItem1Card.caption is required.&#39;)
        if self.value is None:
            raise ValueError(&#39;ListItem1Card.value is required.&#39;)
        if self.aux_value is None:
            raise ValueError(&#39;ListItem1Card.aux_value is required.&#39;)
        if self.data is None:
            raise ValueError(&#39;ListItem1Card.data is required.&#39;)
        return _dump(
            view=&#39;list_item1&#39;,
            box=self.box,
            title=self.title,
            caption=self.caption,
            value=self.value,
            aux_value=self.aux_value,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;ListItem1Card&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;ListItem1Card.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;ListItem1Card.title is required.&#39;)
        __d_caption: Any = __d.get(&#39;caption&#39;)
        if __d_caption is None:
            raise ValueError(&#39;ListItem1Card.caption is required.&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        if __d_value is None:
            raise ValueError(&#39;ListItem1Card.value is required.&#39;)
        __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
        if __d_aux_value is None:
            raise ValueError(&#39;ListItem1Card.aux_value is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        if __d_data is None:
            raise ValueError(&#39;ListItem1Card.data is required.&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        caption: str = __d_caption
        value: str = __d_value
        aux_value: str = __d_aux_value
        data: PackedRecord = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return ListItem1Card(
            box,
            title,
            caption,
            value,
            aux_value,
            data,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.ListItem1Card.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_ListItem1Card__d: Dict) ‑> <a title="h2o_q.types.ListItem1Card" href="#h2o_q.types.ListItem1Card">ListItem1Card</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;ListItem1Card&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;ListItem1Card.box is required.&#39;)
    __d_title: Any = __d.get(&#39;title&#39;)
    if __d_title is None:
        raise ValueError(&#39;ListItem1Card.title is required.&#39;)
    __d_caption: Any = __d.get(&#39;caption&#39;)
    if __d_caption is None:
        raise ValueError(&#39;ListItem1Card.caption is required.&#39;)
    __d_value: Any = __d.get(&#39;value&#39;)
    if __d_value is None:
        raise ValueError(&#39;ListItem1Card.value is required.&#39;)
    __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
    if __d_aux_value is None:
        raise ValueError(&#39;ListItem1Card.aux_value is required.&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    if __d_data is None:
        raise ValueError(&#39;ListItem1Card.data is required.&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    title: str = __d_title
    caption: str = __d_caption
    value: str = __d_value
    aux_value: str = __d_aux_value
    data: PackedRecord = __d_data
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return ListItem1Card(
        box,
        title,
        caption,
        value,
        aux_value,
        data,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.ListItem1Card.aux_value"><code class="name">var <span class="ident">aux_value</span></code></dt>
<dd>
<div class="desc"><p>EXPERIMENTAL. DO NOT USE.</p></div>
</dd>
<dt id="h2o_q.types.ListItem1Card.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.ListItem1Card.caption"><code class="name">var <span class="ident">caption</span></code></dt>
<dd>
<div class="desc"><p>EXPERIMENTAL. DO NOT USE.</p></div>
</dd>
<dt id="h2o_q.types.ListItem1Card.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.ListItem1Card.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>EXPERIMENTAL. DO NOT USE.</p></div>
</dd>
<dt id="h2o_q.types.ListItem1Card.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>EXPERIMENTAL. DO NOT USE.</p></div>
</dd>
<dt id="h2o_q.types.ListItem1Card.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>EXPERIMENTAL. DO NOT USE.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.ListItem1Card.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;ListItem1Card.box is required.&#39;)
    if self.title is None:
        raise ValueError(&#39;ListItem1Card.title is required.&#39;)
    if self.caption is None:
        raise ValueError(&#39;ListItem1Card.caption is required.&#39;)
    if self.value is None:
        raise ValueError(&#39;ListItem1Card.value is required.&#39;)
    if self.aux_value is None:
        raise ValueError(&#39;ListItem1Card.aux_value is required.&#39;)
    if self.data is None:
        raise ValueError(&#39;ListItem1Card.data is required.&#39;)
    return _dump(
        view=&#39;list_item1&#39;,
        box=self.box,
        title=self.title,
        caption=self.caption,
        value=self.value,
        aux_value=self.aux_value,
        data=self.data,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Mark"><code class="flex name class">
<span>class <span class="ident">Mark</span></span>
<span>(</span><span>coord: Union[str, NoneType] = None, type: Union[str, NoneType] = None, x: Union[str, float, int, NoneType] = None, x0: Union[str, float, int, NoneType] = None, x1: Union[str, float, int, NoneType] = None, x2: Union[str, float, int, NoneType] = None, x_min: Union[float, NoneType] = None, x_max: Union[float, NoneType] = None, x_nice: Union[bool, NoneType] = None, x_scale: Union[str, NoneType] = None, x_title: Union[str, NoneType] = None, y: Union[str, float, int, NoneType] = None, y0: Union[str, float, int, NoneType] = None, y1: Union[str, float, int, NoneType] = None, y2: Union[str, float, int, NoneType] = None, y_min: Union[float, NoneType] = None, y_max: Union[float, NoneType] = None, y_nice: Union[bool, NoneType] = None, y_scale: Union[str, NoneType] = None, y_title: Union[str, NoneType] = None, color: Union[str, NoneType] = None, color_range: Union[str, NoneType] = None, color_domain: Union[List[str], NoneType] = None, shape: Union[str, NoneType] = None, shape_range: Union[str, NoneType] = None, size: Union[str, float, int, NoneType] = None, size_range: Union[str, NoneType] = None, stack: Union[str, NoneType] = None, dodge: Union[str, NoneType] = None, curve: Union[str, NoneType] = None, fill_color: Union[str, NoneType] = None, fill_opacity: Union[float, NoneType] = None, stroke_color: Union[str, NoneType] = None, stroke_opacity: Union[float, NoneType] = None, stroke_size: Union[float, NoneType] = None, stroke_dash: Union[str, NoneType] = None, label: Union[str, NoneType] = None, label_offset: Union[float, NoneType] = None, label_offset_x: Union[float, NoneType] = None, label_offset_y: Union[float, NoneType] = None, label_rotation: Union[str, NoneType] = None, label_position: Union[str, NoneType] = None, label_overlap: Union[str, NoneType] = None, label_fill_color: Union[str, NoneType] = None, label_fill_opacity: Union[float, NoneType] = None, label_stroke_color: Union[str, NoneType] = None, label_stroke_opacity: Union[float, NoneType] = None, label_stroke_size: Union[float, NoneType] = None, label_font_size: Union[float, NoneType] = None, label_font_weight: Union[str, NoneType] = None, label_line_height: Union[float, NoneType] = None, label_align: Union[str, NoneType] = None, ref_stroke_color: Union[str, NoneType] = None, ref_stroke_opacity: Union[float, NoneType] = None, ref_stroke_size: Union[float, NoneType] = None, ref_stroke_dash: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a specification for a layer of graphical marks such as bars, lines, points for a plot.
A plot can contain multiple such layers of marks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mark:
    &#34;&#34;&#34;Create a specification for a layer of graphical marks such as bars, lines, points for a plot.
    A plot can contain multiple such layers of marks.
    &#34;&#34;&#34;
    def __init__(
            self,
            coord: Optional[str] = None,
            type: Optional[str] = None,
            x: Optional[Value] = None,
            x0: Optional[Value] = None,
            x1: Optional[Value] = None,
            x2: Optional[Value] = None,
            x_min: Optional[float] = None,
            x_max: Optional[float] = None,
            x_nice: Optional[bool] = None,
            x_scale: Optional[str] = None,
            x_title: Optional[str] = None,
            y: Optional[Value] = None,
            y0: Optional[Value] = None,
            y1: Optional[Value] = None,
            y2: Optional[Value] = None,
            y_min: Optional[float] = None,
            y_max: Optional[float] = None,
            y_nice: Optional[bool] = None,
            y_scale: Optional[str] = None,
            y_title: Optional[str] = None,
            color: Optional[str] = None,
            color_range: Optional[str] = None,
            color_domain: Optional[List[str]] = None,
            shape: Optional[str] = None,
            shape_range: Optional[str] = None,
            size: Optional[Value] = None,
            size_range: Optional[str] = None,
            stack: Optional[str] = None,
            dodge: Optional[str] = None,
            curve: Optional[str] = None,
            fill_color: Optional[str] = None,
            fill_opacity: Optional[float] = None,
            stroke_color: Optional[str] = None,
            stroke_opacity: Optional[float] = None,
            stroke_size: Optional[float] = None,
            stroke_dash: Optional[str] = None,
            label: Optional[str] = None,
            label_offset: Optional[float] = None,
            label_offset_x: Optional[float] = None,
            label_offset_y: Optional[float] = None,
            label_rotation: Optional[str] = None,
            label_position: Optional[str] = None,
            label_overlap: Optional[str] = None,
            label_fill_color: Optional[str] = None,
            label_fill_opacity: Optional[float] = None,
            label_stroke_color: Optional[str] = None,
            label_stroke_opacity: Optional[float] = None,
            label_stroke_size: Optional[float] = None,
            label_font_size: Optional[float] = None,
            label_font_weight: Optional[str] = None,
            label_line_height: Optional[float] = None,
            label_align: Optional[str] = None,
            ref_stroke_color: Optional[str] = None,
            ref_stroke_opacity: Optional[float] = None,
            ref_stroke_size: Optional[float] = None,
            ref_stroke_dash: Optional[str] = None,
    ):
        self.coord = coord
        &#34;&#34;&#34;Coordinate system. `rect` is synonymous to `cartesian`. `theta` is transposed `polar`. One of &#39;rect&#39;, &#39;cartesian&#39;, &#39;polar&#39;, &#39;theta&#39;, &#39;helix&#39;.&#34;&#34;&#34;
        self.type = type
        &#34;&#34;&#34;Graphical geometry. One of &#39;interval&#39;, &#39;line&#39;, &#39;path&#39;, &#39;point&#39;, &#39;area&#39;, &#39;polygon&#39;, &#39;schema&#39;, &#39;edge&#39;, &#39;heatmap&#39;.&#34;&#34;&#34;
        self.x = x
        &#34;&#34;&#34;X field or value.&#34;&#34;&#34;
        self.x0 = x0
        &#34;&#34;&#34;X base field or value.&#34;&#34;&#34;
        self.x1 = x1
        &#34;&#34;&#34;X bin lower bound field or value. For histograms.&#34;&#34;&#34;
        self.x2 = x2
        &#34;&#34;&#34;X bin upper bound field or value. For histograms.&#34;&#34;&#34;
        self.x_min = x_min
        &#34;&#34;&#34;X axis scale minimum.&#34;&#34;&#34;
        self.x_max = x_max
        &#34;&#34;&#34;X axis scale maximum.&#34;&#34;&#34;
        self.x_nice = x_nice
        &#34;&#34;&#34;Whether to nice X axis scale ticks.&#34;&#34;&#34;
        self.x_scale = x_scale
        &#34;&#34;&#34;X axis scale type. One of &#39;linear&#39;, &#39;cat&#39;, &#39;category&#39;, &#39;identity&#39;, &#39;log&#39;, &#39;pow&#39;, &#39;time&#39;, &#39;timeCat&#39;, &#39;quantize&#39;, &#39;quantile&#39;.&#34;&#34;&#34;
        self.x_title = x_title
        &#34;&#34;&#34;X axis title.&#34;&#34;&#34;
        self.y = y
        &#34;&#34;&#34;Y field or value.&#34;&#34;&#34;
        self.y0 = y0
        &#34;&#34;&#34;Y base field or value.&#34;&#34;&#34;
        self.y1 = y1
        &#34;&#34;&#34;Y bin lower bound field or value. For histograms.&#34;&#34;&#34;
        self.y2 = y2
        &#34;&#34;&#34;Y bin upper bound field or value. For histograms.&#34;&#34;&#34;
        self.y_min = y_min
        &#34;&#34;&#34;Y axis scale minimum.&#34;&#34;&#34;
        self.y_max = y_max
        &#34;&#34;&#34;Y axis scale maximum.&#34;&#34;&#34;
        self.y_nice = y_nice
        &#34;&#34;&#34;Whether to nice Y axis scale ticks.&#34;&#34;&#34;
        self.y_scale = y_scale
        &#34;&#34;&#34;Y axis scale type. One of &#39;linear&#39;, &#39;cat&#39;, &#39;category&#39;, &#39;identity&#39;, &#39;log&#39;, &#39;pow&#39;, &#39;time&#39;, &#39;timeCat&#39;, &#39;quantize&#39;, &#39;quantile&#39;.&#34;&#34;&#34;
        self.y_title = y_title
        &#34;&#34;&#34;Y axis title.&#34;&#34;&#34;
        self.color = color
        &#34;&#34;&#34;Mark color field or value.&#34;&#34;&#34;
        self.color_range = color_range
        &#34;&#34;&#34;Mark color range for multi-series plots. A string containing space-separated colors, e.g. `&#39;#fee8c8 #fdbb84 #e34a33&#39;`&#34;&#34;&#34;
        self.color_domain = color_domain
        &#34;&#34;&#34;The unique values in the data (labels or categories or classes) to map colors to, e.g. `[&#39;high&#39;, &#39;medium&#39;, &#39;low&#39;]`. If this is not provided, the unique values are automatically inferred from the `color` attribute.&#34;&#34;&#34;
        self.shape = shape
        &#34;&#34;&#34;Mark shape field or value for `point` mark types. Possible values are &#39;circle&#39;, &#39;square&#39;, &#39;bowtie&#39;, &#39;diamond&#39;, &#39;hexagon&#39;, &#39;triangle&#39;, &#39;triangle-down&#39;, &#39;cross&#39;, &#39;tick&#39;, &#39;plus&#39;, &#39;hyphen&#39;, &#39;line&#39;.&#34;&#34;&#34;
        self.shape_range = shape_range
        &#34;&#34;&#34;Mark shape range for multi-series plots using `point` mark types. A string containing space-separated shapes, e.g. `&#39;circle square diamond&#39;`&#34;&#34;&#34;
        self.size = size
        &#34;&#34;&#34;Mark size field or value.&#34;&#34;&#34;
        self.size_range = size_range
        &#34;&#34;&#34;Mark size range. A string containing space-separated integers, e.g. `&#39;4 30&#39;`&#34;&#34;&#34;
        self.stack = stack
        &#34;&#34;&#34;Field to stack marks by, or &#39;auto&#39; to infer.&#34;&#34;&#34;
        self.dodge = dodge
        &#34;&#34;&#34;Field to dodge marks by, or &#39;auto&#39; to infer.&#34;&#34;&#34;
        self.curve = curve
        &#34;&#34;&#34;Curve type for `line` and `area` mark types. One of &#39;none&#39;, &#39;smooth&#39;, &#39;step-before&#39;, &#39;step&#39;, &#39;step-after&#39;.&#34;&#34;&#34;
        self.fill_color = fill_color
        &#34;&#34;&#34;Mark fill color.&#34;&#34;&#34;
        self.fill_opacity = fill_opacity
        &#34;&#34;&#34;Mark fill opacity.&#34;&#34;&#34;
        self.stroke_color = stroke_color
        &#34;&#34;&#34;Mark stroke color.&#34;&#34;&#34;
        self.stroke_opacity = stroke_opacity
        &#34;&#34;&#34;Mark stroke opacity.&#34;&#34;&#34;
        self.stroke_size = stroke_size
        &#34;&#34;&#34;Mark stroke size.&#34;&#34;&#34;
        self.stroke_dash = stroke_dash
        &#34;&#34;&#34;Mark stroke dash style. A string containing space-separated integers that specify distances to alternately draw a line and a gap (in coordinate space units). If the number of elements in the array is odd, the elements of the array get copied and concatenated. For example, [5, 15, 25] will become [5, 15, 25, 5, 15, 25].&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Label field or value.&#34;&#34;&#34;
        self.label_offset = label_offset
        &#34;&#34;&#34;Distance between label and mark.&#34;&#34;&#34;
        self.label_offset_x = label_offset_x
        &#34;&#34;&#34;Horizontal distance between label and mark.&#34;&#34;&#34;
        self.label_offset_y = label_offset_y
        &#34;&#34;&#34;Vertical distance between label and mark.&#34;&#34;&#34;
        self.label_rotation = label_rotation
        &#34;&#34;&#34;Label rotation angle, in degrees, or &#39;none&#39; to disable automatic rotation. The default behavior is &#39;auto&#39; for automatic rotation.&#34;&#34;&#34;
        self.label_position = label_position
        &#34;&#34;&#34;Label position relative to the mark. One of &#39;top&#39;, &#39;bottom&#39;, &#39;middle&#39;, &#39;left&#39;, &#39;right&#39;.&#34;&#34;&#34;
        self.label_overlap = label_overlap
        &#34;&#34;&#34;Strategy to use if labels overlap. One of &#39;hide&#39;, &#39;overlap&#39;, &#39;constrain&#39;.&#34;&#34;&#34;
        self.label_fill_color = label_fill_color
        &#34;&#34;&#34;Label fill color.&#34;&#34;&#34;
        self.label_fill_opacity = label_fill_opacity
        &#34;&#34;&#34;Label fill opacity.&#34;&#34;&#34;
        self.label_stroke_color = label_stroke_color
        &#34;&#34;&#34;Label stroke color.&#34;&#34;&#34;
        self.label_stroke_opacity = label_stroke_opacity
        &#34;&#34;&#34;Label stroke opacity.&#34;&#34;&#34;
        self.label_stroke_size = label_stroke_size
        &#34;&#34;&#34;Label stroke size (line width or pen thickness).&#34;&#34;&#34;
        self.label_font_size = label_font_size
        &#34;&#34;&#34;Label font size.&#34;&#34;&#34;
        self.label_font_weight = label_font_weight
        &#34;&#34;&#34;Label font weight.&#34;&#34;&#34;
        self.label_line_height = label_line_height
        &#34;&#34;&#34;Label line height.&#34;&#34;&#34;
        self.label_align = label_align
        &#34;&#34;&#34;Label text alignment. One of &#39;left&#39;, &#39;right&#39;, &#39;center&#39;, &#39;start&#39;, &#39;end&#39;.&#34;&#34;&#34;
        self.ref_stroke_color = ref_stroke_color
        &#34;&#34;&#34;Reference line stroke color.&#34;&#34;&#34;
        self.ref_stroke_opacity = ref_stroke_opacity
        &#34;&#34;&#34;Reference line stroke opacity.&#34;&#34;&#34;
        self.ref_stroke_size = ref_stroke_size
        &#34;&#34;&#34;Reference line stroke size (line width or pen thickness).&#34;&#34;&#34;
        self.ref_stroke_dash = ref_stroke_dash
        &#34;&#34;&#34;Reference line stroke dash style. A string containing space-separated integers that specify distances to alternately draw a line and a gap (in coordinate space units). If the number of elements in the array is odd, the elements of the array get copied and concatenated. For example, [5, 15, 25] will become [5, 15, 25, 5, 15, 25].&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        return _dump(
            coord=self.coord,
            type=self.type,
            x=self.x,
            x0=self.x0,
            x1=self.x1,
            x2=self.x2,
            x_min=self.x_min,
            x_max=self.x_max,
            x_nice=self.x_nice,
            x_scale=self.x_scale,
            x_title=self.x_title,
            y=self.y,
            y0=self.y0,
            y1=self.y1,
            y2=self.y2,
            y_min=self.y_min,
            y_max=self.y_max,
            y_nice=self.y_nice,
            y_scale=self.y_scale,
            y_title=self.y_title,
            color=self.color,
            color_range=self.color_range,
            color_domain=self.color_domain,
            shape=self.shape,
            shape_range=self.shape_range,
            size=self.size,
            size_range=self.size_range,
            stack=self.stack,
            dodge=self.dodge,
            curve=self.curve,
            fill_color=self.fill_color,
            fill_opacity=self.fill_opacity,
            stroke_color=self.stroke_color,
            stroke_opacity=self.stroke_opacity,
            stroke_size=self.stroke_size,
            stroke_dash=self.stroke_dash,
            label=self.label,
            label_offset=self.label_offset,
            label_offset_x=self.label_offset_x,
            label_offset_y=self.label_offset_y,
            label_rotation=self.label_rotation,
            label_position=self.label_position,
            label_overlap=self.label_overlap,
            label_fill_color=self.label_fill_color,
            label_fill_opacity=self.label_fill_opacity,
            label_stroke_color=self.label_stroke_color,
            label_stroke_opacity=self.label_stroke_opacity,
            label_stroke_size=self.label_stroke_size,
            label_font_size=self.label_font_size,
            label_font_weight=self.label_font_weight,
            label_line_height=self.label_line_height,
            label_align=self.label_align,
            ref_stroke_color=self.ref_stroke_color,
            ref_stroke_opacity=self.ref_stroke_opacity,
            ref_stroke_size=self.ref_stroke_size,
            ref_stroke_dash=self.ref_stroke_dash,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Mark&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_coord: Any = __d.get(&#39;coord&#39;)
        __d_type: Any = __d.get(&#39;type&#39;)
        __d_x: Any = __d.get(&#39;x&#39;)
        __d_x0: Any = __d.get(&#39;x0&#39;)
        __d_x1: Any = __d.get(&#39;x1&#39;)
        __d_x2: Any = __d.get(&#39;x2&#39;)
        __d_x_min: Any = __d.get(&#39;x_min&#39;)
        __d_x_max: Any = __d.get(&#39;x_max&#39;)
        __d_x_nice: Any = __d.get(&#39;x_nice&#39;)
        __d_x_scale: Any = __d.get(&#39;x_scale&#39;)
        __d_x_title: Any = __d.get(&#39;x_title&#39;)
        __d_y: Any = __d.get(&#39;y&#39;)
        __d_y0: Any = __d.get(&#39;y0&#39;)
        __d_y1: Any = __d.get(&#39;y1&#39;)
        __d_y2: Any = __d.get(&#39;y2&#39;)
        __d_y_min: Any = __d.get(&#39;y_min&#39;)
        __d_y_max: Any = __d.get(&#39;y_max&#39;)
        __d_y_nice: Any = __d.get(&#39;y_nice&#39;)
        __d_y_scale: Any = __d.get(&#39;y_scale&#39;)
        __d_y_title: Any = __d.get(&#39;y_title&#39;)
        __d_color: Any = __d.get(&#39;color&#39;)
        __d_color_range: Any = __d.get(&#39;color_range&#39;)
        __d_color_domain: Any = __d.get(&#39;color_domain&#39;)
        __d_shape: Any = __d.get(&#39;shape&#39;)
        __d_shape_range: Any = __d.get(&#39;shape_range&#39;)
        __d_size: Any = __d.get(&#39;size&#39;)
        __d_size_range: Any = __d.get(&#39;size_range&#39;)
        __d_stack: Any = __d.get(&#39;stack&#39;)
        __d_dodge: Any = __d.get(&#39;dodge&#39;)
        __d_curve: Any = __d.get(&#39;curve&#39;)
        __d_fill_color: Any = __d.get(&#39;fill_color&#39;)
        __d_fill_opacity: Any = __d.get(&#39;fill_opacity&#39;)
        __d_stroke_color: Any = __d.get(&#39;stroke_color&#39;)
        __d_stroke_opacity: Any = __d.get(&#39;stroke_opacity&#39;)
        __d_stroke_size: Any = __d.get(&#39;stroke_size&#39;)
        __d_stroke_dash: Any = __d.get(&#39;stroke_dash&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_label_offset: Any = __d.get(&#39;label_offset&#39;)
        __d_label_offset_x: Any = __d.get(&#39;label_offset_x&#39;)
        __d_label_offset_y: Any = __d.get(&#39;label_offset_y&#39;)
        __d_label_rotation: Any = __d.get(&#39;label_rotation&#39;)
        __d_label_position: Any = __d.get(&#39;label_position&#39;)
        __d_label_overlap: Any = __d.get(&#39;label_overlap&#39;)
        __d_label_fill_color: Any = __d.get(&#39;label_fill_color&#39;)
        __d_label_fill_opacity: Any = __d.get(&#39;label_fill_opacity&#39;)
        __d_label_stroke_color: Any = __d.get(&#39;label_stroke_color&#39;)
        __d_label_stroke_opacity: Any = __d.get(&#39;label_stroke_opacity&#39;)
        __d_label_stroke_size: Any = __d.get(&#39;label_stroke_size&#39;)
        __d_label_font_size: Any = __d.get(&#39;label_font_size&#39;)
        __d_label_font_weight: Any = __d.get(&#39;label_font_weight&#39;)
        __d_label_line_height: Any = __d.get(&#39;label_line_height&#39;)
        __d_label_align: Any = __d.get(&#39;label_align&#39;)
        __d_ref_stroke_color: Any = __d.get(&#39;ref_stroke_color&#39;)
        __d_ref_stroke_opacity: Any = __d.get(&#39;ref_stroke_opacity&#39;)
        __d_ref_stroke_size: Any = __d.get(&#39;ref_stroke_size&#39;)
        __d_ref_stroke_dash: Any = __d.get(&#39;ref_stroke_dash&#39;)
        coord: Optional[str] = __d_coord
        type: Optional[str] = __d_type
        x: Optional[Value] = __d_x
        x0: Optional[Value] = __d_x0
        x1: Optional[Value] = __d_x1
        x2: Optional[Value] = __d_x2
        x_min: Optional[float] = __d_x_min
        x_max: Optional[float] = __d_x_max
        x_nice: Optional[bool] = __d_x_nice
        x_scale: Optional[str] = __d_x_scale
        x_title: Optional[str] = __d_x_title
        y: Optional[Value] = __d_y
        y0: Optional[Value] = __d_y0
        y1: Optional[Value] = __d_y1
        y2: Optional[Value] = __d_y2
        y_min: Optional[float] = __d_y_min
        y_max: Optional[float] = __d_y_max
        y_nice: Optional[bool] = __d_y_nice
        y_scale: Optional[str] = __d_y_scale
        y_title: Optional[str] = __d_y_title
        color: Optional[str] = __d_color
        color_range: Optional[str] = __d_color_range
        color_domain: Optional[List[str]] = __d_color_domain
        shape: Optional[str] = __d_shape
        shape_range: Optional[str] = __d_shape_range
        size: Optional[Value] = __d_size
        size_range: Optional[str] = __d_size_range
        stack: Optional[str] = __d_stack
        dodge: Optional[str] = __d_dodge
        curve: Optional[str] = __d_curve
        fill_color: Optional[str] = __d_fill_color
        fill_opacity: Optional[float] = __d_fill_opacity
        stroke_color: Optional[str] = __d_stroke_color
        stroke_opacity: Optional[float] = __d_stroke_opacity
        stroke_size: Optional[float] = __d_stroke_size
        stroke_dash: Optional[str] = __d_stroke_dash
        label: Optional[str] = __d_label
        label_offset: Optional[float] = __d_label_offset
        label_offset_x: Optional[float] = __d_label_offset_x
        label_offset_y: Optional[float] = __d_label_offset_y
        label_rotation: Optional[str] = __d_label_rotation
        label_position: Optional[str] = __d_label_position
        label_overlap: Optional[str] = __d_label_overlap
        label_fill_color: Optional[str] = __d_label_fill_color
        label_fill_opacity: Optional[float] = __d_label_fill_opacity
        label_stroke_color: Optional[str] = __d_label_stroke_color
        label_stroke_opacity: Optional[float] = __d_label_stroke_opacity
        label_stroke_size: Optional[float] = __d_label_stroke_size
        label_font_size: Optional[float] = __d_label_font_size
        label_font_weight: Optional[str] = __d_label_font_weight
        label_line_height: Optional[float] = __d_label_line_height
        label_align: Optional[str] = __d_label_align
        ref_stroke_color: Optional[str] = __d_ref_stroke_color
        ref_stroke_opacity: Optional[float] = __d_ref_stroke_opacity
        ref_stroke_size: Optional[float] = __d_ref_stroke_size
        ref_stroke_dash: Optional[str] = __d_ref_stroke_dash
        return Mark(
            coord,
            type,
            x,
            x0,
            x1,
            x2,
            x_min,
            x_max,
            x_nice,
            x_scale,
            x_title,
            y,
            y0,
            y1,
            y2,
            y_min,
            y_max,
            y_nice,
            y_scale,
            y_title,
            color,
            color_range,
            color_domain,
            shape,
            shape_range,
            size,
            size_range,
            stack,
            dodge,
            curve,
            fill_color,
            fill_opacity,
            stroke_color,
            stroke_opacity,
            stroke_size,
            stroke_dash,
            label,
            label_offset,
            label_offset_x,
            label_offset_y,
            label_rotation,
            label_position,
            label_overlap,
            label_fill_color,
            label_fill_opacity,
            label_stroke_color,
            label_stroke_opacity,
            label_stroke_size,
            label_font_size,
            label_font_weight,
            label_line_height,
            label_align,
            ref_stroke_color,
            ref_stroke_opacity,
            ref_stroke_size,
            ref_stroke_dash,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Mark.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Mark__d: Dict) ‑> <a title="h2o_q.types.Mark" href="#h2o_q.types.Mark">Mark</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Mark&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_coord: Any = __d.get(&#39;coord&#39;)
    __d_type: Any = __d.get(&#39;type&#39;)
    __d_x: Any = __d.get(&#39;x&#39;)
    __d_x0: Any = __d.get(&#39;x0&#39;)
    __d_x1: Any = __d.get(&#39;x1&#39;)
    __d_x2: Any = __d.get(&#39;x2&#39;)
    __d_x_min: Any = __d.get(&#39;x_min&#39;)
    __d_x_max: Any = __d.get(&#39;x_max&#39;)
    __d_x_nice: Any = __d.get(&#39;x_nice&#39;)
    __d_x_scale: Any = __d.get(&#39;x_scale&#39;)
    __d_x_title: Any = __d.get(&#39;x_title&#39;)
    __d_y: Any = __d.get(&#39;y&#39;)
    __d_y0: Any = __d.get(&#39;y0&#39;)
    __d_y1: Any = __d.get(&#39;y1&#39;)
    __d_y2: Any = __d.get(&#39;y2&#39;)
    __d_y_min: Any = __d.get(&#39;y_min&#39;)
    __d_y_max: Any = __d.get(&#39;y_max&#39;)
    __d_y_nice: Any = __d.get(&#39;y_nice&#39;)
    __d_y_scale: Any = __d.get(&#39;y_scale&#39;)
    __d_y_title: Any = __d.get(&#39;y_title&#39;)
    __d_color: Any = __d.get(&#39;color&#39;)
    __d_color_range: Any = __d.get(&#39;color_range&#39;)
    __d_color_domain: Any = __d.get(&#39;color_domain&#39;)
    __d_shape: Any = __d.get(&#39;shape&#39;)
    __d_shape_range: Any = __d.get(&#39;shape_range&#39;)
    __d_size: Any = __d.get(&#39;size&#39;)
    __d_size_range: Any = __d.get(&#39;size_range&#39;)
    __d_stack: Any = __d.get(&#39;stack&#39;)
    __d_dodge: Any = __d.get(&#39;dodge&#39;)
    __d_curve: Any = __d.get(&#39;curve&#39;)
    __d_fill_color: Any = __d.get(&#39;fill_color&#39;)
    __d_fill_opacity: Any = __d.get(&#39;fill_opacity&#39;)
    __d_stroke_color: Any = __d.get(&#39;stroke_color&#39;)
    __d_stroke_opacity: Any = __d.get(&#39;stroke_opacity&#39;)
    __d_stroke_size: Any = __d.get(&#39;stroke_size&#39;)
    __d_stroke_dash: Any = __d.get(&#39;stroke_dash&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    __d_label_offset: Any = __d.get(&#39;label_offset&#39;)
    __d_label_offset_x: Any = __d.get(&#39;label_offset_x&#39;)
    __d_label_offset_y: Any = __d.get(&#39;label_offset_y&#39;)
    __d_label_rotation: Any = __d.get(&#39;label_rotation&#39;)
    __d_label_position: Any = __d.get(&#39;label_position&#39;)
    __d_label_overlap: Any = __d.get(&#39;label_overlap&#39;)
    __d_label_fill_color: Any = __d.get(&#39;label_fill_color&#39;)
    __d_label_fill_opacity: Any = __d.get(&#39;label_fill_opacity&#39;)
    __d_label_stroke_color: Any = __d.get(&#39;label_stroke_color&#39;)
    __d_label_stroke_opacity: Any = __d.get(&#39;label_stroke_opacity&#39;)
    __d_label_stroke_size: Any = __d.get(&#39;label_stroke_size&#39;)
    __d_label_font_size: Any = __d.get(&#39;label_font_size&#39;)
    __d_label_font_weight: Any = __d.get(&#39;label_font_weight&#39;)
    __d_label_line_height: Any = __d.get(&#39;label_line_height&#39;)
    __d_label_align: Any = __d.get(&#39;label_align&#39;)
    __d_ref_stroke_color: Any = __d.get(&#39;ref_stroke_color&#39;)
    __d_ref_stroke_opacity: Any = __d.get(&#39;ref_stroke_opacity&#39;)
    __d_ref_stroke_size: Any = __d.get(&#39;ref_stroke_size&#39;)
    __d_ref_stroke_dash: Any = __d.get(&#39;ref_stroke_dash&#39;)
    coord: Optional[str] = __d_coord
    type: Optional[str] = __d_type
    x: Optional[Value] = __d_x
    x0: Optional[Value] = __d_x0
    x1: Optional[Value] = __d_x1
    x2: Optional[Value] = __d_x2
    x_min: Optional[float] = __d_x_min
    x_max: Optional[float] = __d_x_max
    x_nice: Optional[bool] = __d_x_nice
    x_scale: Optional[str] = __d_x_scale
    x_title: Optional[str] = __d_x_title
    y: Optional[Value] = __d_y
    y0: Optional[Value] = __d_y0
    y1: Optional[Value] = __d_y1
    y2: Optional[Value] = __d_y2
    y_min: Optional[float] = __d_y_min
    y_max: Optional[float] = __d_y_max
    y_nice: Optional[bool] = __d_y_nice
    y_scale: Optional[str] = __d_y_scale
    y_title: Optional[str] = __d_y_title
    color: Optional[str] = __d_color
    color_range: Optional[str] = __d_color_range
    color_domain: Optional[List[str]] = __d_color_domain
    shape: Optional[str] = __d_shape
    shape_range: Optional[str] = __d_shape_range
    size: Optional[Value] = __d_size
    size_range: Optional[str] = __d_size_range
    stack: Optional[str] = __d_stack
    dodge: Optional[str] = __d_dodge
    curve: Optional[str] = __d_curve
    fill_color: Optional[str] = __d_fill_color
    fill_opacity: Optional[float] = __d_fill_opacity
    stroke_color: Optional[str] = __d_stroke_color
    stroke_opacity: Optional[float] = __d_stroke_opacity
    stroke_size: Optional[float] = __d_stroke_size
    stroke_dash: Optional[str] = __d_stroke_dash
    label: Optional[str] = __d_label
    label_offset: Optional[float] = __d_label_offset
    label_offset_x: Optional[float] = __d_label_offset_x
    label_offset_y: Optional[float] = __d_label_offset_y
    label_rotation: Optional[str] = __d_label_rotation
    label_position: Optional[str] = __d_label_position
    label_overlap: Optional[str] = __d_label_overlap
    label_fill_color: Optional[str] = __d_label_fill_color
    label_fill_opacity: Optional[float] = __d_label_fill_opacity
    label_stroke_color: Optional[str] = __d_label_stroke_color
    label_stroke_opacity: Optional[float] = __d_label_stroke_opacity
    label_stroke_size: Optional[float] = __d_label_stroke_size
    label_font_size: Optional[float] = __d_label_font_size
    label_font_weight: Optional[str] = __d_label_font_weight
    label_line_height: Optional[float] = __d_label_line_height
    label_align: Optional[str] = __d_label_align
    ref_stroke_color: Optional[str] = __d_ref_stroke_color
    ref_stroke_opacity: Optional[float] = __d_ref_stroke_opacity
    ref_stroke_size: Optional[float] = __d_ref_stroke_size
    ref_stroke_dash: Optional[str] = __d_ref_stroke_dash
    return Mark(
        coord,
        type,
        x,
        x0,
        x1,
        x2,
        x_min,
        x_max,
        x_nice,
        x_scale,
        x_title,
        y,
        y0,
        y1,
        y2,
        y_min,
        y_max,
        y_nice,
        y_scale,
        y_title,
        color,
        color_range,
        color_domain,
        shape,
        shape_range,
        size,
        size_range,
        stack,
        dodge,
        curve,
        fill_color,
        fill_opacity,
        stroke_color,
        stroke_opacity,
        stroke_size,
        stroke_dash,
        label,
        label_offset,
        label_offset_x,
        label_offset_y,
        label_rotation,
        label_position,
        label_overlap,
        label_fill_color,
        label_fill_opacity,
        label_stroke_color,
        label_stroke_opacity,
        label_stroke_size,
        label_font_size,
        label_font_weight,
        label_line_height,
        label_align,
        ref_stroke_color,
        ref_stroke_opacity,
        ref_stroke_size,
        ref_stroke_dash,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Mark.color"><code class="name">var <span class="ident">color</span></code></dt>
<dd>
<div class="desc"><p>Mark color field or value.</p></div>
</dd>
<dt id="h2o_q.types.Mark.color_domain"><code class="name">var <span class="ident">color_domain</span></code></dt>
<dd>
<div class="desc"><p>The unique values in the data (labels or categories or classes) to map colors to, e.g. <code>['high', 'medium', 'low']</code>. If this is not provided, the unique values are automatically inferred from the <code>color</code> attribute.</p></div>
</dd>
<dt id="h2o_q.types.Mark.color_range"><code class="name">var <span class="ident">color_range</span></code></dt>
<dd>
<div class="desc"><p>Mark color range for multi-series plots. A string containing space-separated colors, e.g. <code>'#fee8c8 #fdbb84 #e34a33'</code></p></div>
</dd>
<dt id="h2o_q.types.Mark.coord"><code class="name">var <span class="ident">coord</span></code></dt>
<dd>
<div class="desc"><p>Coordinate system. <code>rect</code> is synonymous to <code>cartesian</code>. <code>theta</code> is transposed <code>polar</code>. One of 'rect', 'cartesian', 'polar', 'theta', 'helix'.</p></div>
</dd>
<dt id="h2o_q.types.Mark.curve"><code class="name">var <span class="ident">curve</span></code></dt>
<dd>
<div class="desc"><p>Curve type for <code>line</code> and <code>area</code> mark types. One of 'none', 'smooth', 'step-before', 'step', 'step-after'.</p></div>
</dd>
<dt id="h2o_q.types.Mark.dodge"><code class="name">var <span class="ident">dodge</span></code></dt>
<dd>
<div class="desc"><p>Field to dodge marks by, or 'auto' to infer.</p></div>
</dd>
<dt id="h2o_q.types.Mark.fill_color"><code class="name">var <span class="ident">fill_color</span></code></dt>
<dd>
<div class="desc"><p>Mark fill color.</p></div>
</dd>
<dt id="h2o_q.types.Mark.fill_opacity"><code class="name">var <span class="ident">fill_opacity</span></code></dt>
<dd>
<div class="desc"><p>Mark fill opacity.</p></div>
</dd>
<dt id="h2o_q.types.Mark.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>Label field or value.</p></div>
</dd>
<dt id="h2o_q.types.Mark.label_align"><code class="name">var <span class="ident">label_align</span></code></dt>
<dd>
<div class="desc"><p>Label text alignment. One of 'left', 'right', 'center', 'start', 'end'.</p></div>
</dd>
<dt id="h2o_q.types.Mark.label_fill_color"><code class="name">var <span class="ident">label_fill_color</span></code></dt>
<dd>
<div class="desc"><p>Label fill color.</p></div>
</dd>
<dt id="h2o_q.types.Mark.label_fill_opacity"><code class="name">var <span class="ident">label_fill_opacity</span></code></dt>
<dd>
<div class="desc"><p>Label fill opacity.</p></div>
</dd>
<dt id="h2o_q.types.Mark.label_font_size"><code class="name">var <span class="ident">label_font_size</span></code></dt>
<dd>
<div class="desc"><p>Label font size.</p></div>
</dd>
<dt id="h2o_q.types.Mark.label_font_weight"><code class="name">var <span class="ident">label_font_weight</span></code></dt>
<dd>
<div class="desc"><p>Label font weight.</p></div>
</dd>
<dt id="h2o_q.types.Mark.label_line_height"><code class="name">var <span class="ident">label_line_height</span></code></dt>
<dd>
<div class="desc"><p>Label line height.</p></div>
</dd>
<dt id="h2o_q.types.Mark.label_offset"><code class="name">var <span class="ident">label_offset</span></code></dt>
<dd>
<div class="desc"><p>Distance between label and mark.</p></div>
</dd>
<dt id="h2o_q.types.Mark.label_offset_x"><code class="name">var <span class="ident">label_offset_x</span></code></dt>
<dd>
<div class="desc"><p>Horizontal distance between label and mark.</p></div>
</dd>
<dt id="h2o_q.types.Mark.label_offset_y"><code class="name">var <span class="ident">label_offset_y</span></code></dt>
<dd>
<div class="desc"><p>Vertical distance between label and mark.</p></div>
</dd>
<dt id="h2o_q.types.Mark.label_overlap"><code class="name">var <span class="ident">label_overlap</span></code></dt>
<dd>
<div class="desc"><p>Strategy to use if labels overlap. One of 'hide', 'overlap', 'constrain'.</p></div>
</dd>
<dt id="h2o_q.types.Mark.label_position"><code class="name">var <span class="ident">label_position</span></code></dt>
<dd>
<div class="desc"><p>Label position relative to the mark. One of 'top', 'bottom', 'middle', 'left', 'right'.</p></div>
</dd>
<dt id="h2o_q.types.Mark.label_rotation"><code class="name">var <span class="ident">label_rotation</span></code></dt>
<dd>
<div class="desc"><p>Label rotation angle, in degrees, or 'none' to disable automatic rotation. The default behavior is 'auto' for automatic rotation.</p></div>
</dd>
<dt id="h2o_q.types.Mark.label_stroke_color"><code class="name">var <span class="ident">label_stroke_color</span></code></dt>
<dd>
<div class="desc"><p>Label stroke color.</p></div>
</dd>
<dt id="h2o_q.types.Mark.label_stroke_opacity"><code class="name">var <span class="ident">label_stroke_opacity</span></code></dt>
<dd>
<div class="desc"><p>Label stroke opacity.</p></div>
</dd>
<dt id="h2o_q.types.Mark.label_stroke_size"><code class="name">var <span class="ident">label_stroke_size</span></code></dt>
<dd>
<div class="desc"><p>Label stroke size (line width or pen thickness).</p></div>
</dd>
<dt id="h2o_q.types.Mark.ref_stroke_color"><code class="name">var <span class="ident">ref_stroke_color</span></code></dt>
<dd>
<div class="desc"><p>Reference line stroke color.</p></div>
</dd>
<dt id="h2o_q.types.Mark.ref_stroke_dash"><code class="name">var <span class="ident">ref_stroke_dash</span></code></dt>
<dd>
<div class="desc"><p>Reference line stroke dash style. A string containing space-separated integers that specify distances to alternately draw a line and a gap (in coordinate space units). If the number of elements in the array is odd, the elements of the array get copied and concatenated. For example, [5, 15, 25] will become [5, 15, 25, 5, 15, 25].</p></div>
</dd>
<dt id="h2o_q.types.Mark.ref_stroke_opacity"><code class="name">var <span class="ident">ref_stroke_opacity</span></code></dt>
<dd>
<div class="desc"><p>Reference line stroke opacity.</p></div>
</dd>
<dt id="h2o_q.types.Mark.ref_stroke_size"><code class="name">var <span class="ident">ref_stroke_size</span></code></dt>
<dd>
<div class="desc"><p>Reference line stroke size (line width or pen thickness).</p></div>
</dd>
<dt id="h2o_q.types.Mark.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>Mark shape field or value for <code>point</code> mark types. Possible values are 'circle', 'square', 'bowtie', 'diamond', 'hexagon', 'triangle', 'triangle-down', 'cross', 'tick', 'plus', 'hyphen', 'line'.</p></div>
</dd>
<dt id="h2o_q.types.Mark.shape_range"><code class="name">var <span class="ident">shape_range</span></code></dt>
<dd>
<div class="desc"><p>Mark shape range for multi-series plots using <code>point</code> mark types. A string containing space-separated shapes, e.g. <code>'circle square diamond'</code></p></div>
</dd>
<dt id="h2o_q.types.Mark.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"><p>Mark size field or value.</p></div>
</dd>
<dt id="h2o_q.types.Mark.size_range"><code class="name">var <span class="ident">size_range</span></code></dt>
<dd>
<div class="desc"><p>Mark size range. A string containing space-separated integers, e.g. <code>'4 30'</code></p></div>
</dd>
<dt id="h2o_q.types.Mark.stack"><code class="name">var <span class="ident">stack</span></code></dt>
<dd>
<div class="desc"><p>Field to stack marks by, or 'auto' to infer.</p></div>
</dd>
<dt id="h2o_q.types.Mark.stroke_color"><code class="name">var <span class="ident">stroke_color</span></code></dt>
<dd>
<div class="desc"><p>Mark stroke color.</p></div>
</dd>
<dt id="h2o_q.types.Mark.stroke_dash"><code class="name">var <span class="ident">stroke_dash</span></code></dt>
<dd>
<div class="desc"><p>Mark stroke dash style. A string containing space-separated integers that specify distances to alternately draw a line and a gap (in coordinate space units). If the number of elements in the array is odd, the elements of the array get copied and concatenated. For example, [5, 15, 25] will become [5, 15, 25, 5, 15, 25].</p></div>
</dd>
<dt id="h2o_q.types.Mark.stroke_opacity"><code class="name">var <span class="ident">stroke_opacity</span></code></dt>
<dd>
<div class="desc"><p>Mark stroke opacity.</p></div>
</dd>
<dt id="h2o_q.types.Mark.stroke_size"><code class="name">var <span class="ident">stroke_size</span></code></dt>
<dd>
<div class="desc"><p>Mark stroke size.</p></div>
</dd>
<dt id="h2o_q.types.Mark.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><p>Graphical geometry. One of 'interval', 'line', 'path', 'point', 'area', 'polygon', 'schema', 'edge', 'heatmap'.</p></div>
</dd>
<dt id="h2o_q.types.Mark.x"><code class="name">var <span class="ident">x</span></code></dt>
<dd>
<div class="desc"><p>X field or value.</p></div>
</dd>
<dt id="h2o_q.types.Mark.x0"><code class="name">var <span class="ident">x0</span></code></dt>
<dd>
<div class="desc"><p>X base field or value.</p></div>
</dd>
<dt id="h2o_q.types.Mark.x1"><code class="name">var <span class="ident">x1</span></code></dt>
<dd>
<div class="desc"><p>X bin lower bound field or value. For histograms.</p></div>
</dd>
<dt id="h2o_q.types.Mark.x2"><code class="name">var <span class="ident">x2</span></code></dt>
<dd>
<div class="desc"><p>X bin upper bound field or value. For histograms.</p></div>
</dd>
<dt id="h2o_q.types.Mark.x_max"><code class="name">var <span class="ident">x_max</span></code></dt>
<dd>
<div class="desc"><p>X axis scale maximum.</p></div>
</dd>
<dt id="h2o_q.types.Mark.x_min"><code class="name">var <span class="ident">x_min</span></code></dt>
<dd>
<div class="desc"><p>X axis scale minimum.</p></div>
</dd>
<dt id="h2o_q.types.Mark.x_nice"><code class="name">var <span class="ident">x_nice</span></code></dt>
<dd>
<div class="desc"><p>Whether to nice X axis scale ticks.</p></div>
</dd>
<dt id="h2o_q.types.Mark.x_scale"><code class="name">var <span class="ident">x_scale</span></code></dt>
<dd>
<div class="desc"><p>X axis scale type. One of 'linear', 'cat', 'category', 'identity', 'log', 'pow', 'time', 'timeCat', 'quantize', 'quantile'.</p></div>
</dd>
<dt id="h2o_q.types.Mark.x_title"><code class="name">var <span class="ident">x_title</span></code></dt>
<dd>
<div class="desc"><p>X axis title.</p></div>
</dd>
<dt id="h2o_q.types.Mark.y"><code class="name">var <span class="ident">y</span></code></dt>
<dd>
<div class="desc"><p>Y field or value.</p></div>
</dd>
<dt id="h2o_q.types.Mark.y0"><code class="name">var <span class="ident">y0</span></code></dt>
<dd>
<div class="desc"><p>Y base field or value.</p></div>
</dd>
<dt id="h2o_q.types.Mark.y1"><code class="name">var <span class="ident">y1</span></code></dt>
<dd>
<div class="desc"><p>Y bin lower bound field or value. For histograms.</p></div>
</dd>
<dt id="h2o_q.types.Mark.y2"><code class="name">var <span class="ident">y2</span></code></dt>
<dd>
<div class="desc"><p>Y bin upper bound field or value. For histograms.</p></div>
</dd>
<dt id="h2o_q.types.Mark.y_max"><code class="name">var <span class="ident">y_max</span></code></dt>
<dd>
<div class="desc"><p>Y axis scale maximum.</p></div>
</dd>
<dt id="h2o_q.types.Mark.y_min"><code class="name">var <span class="ident">y_min</span></code></dt>
<dd>
<div class="desc"><p>Y axis scale minimum.</p></div>
</dd>
<dt id="h2o_q.types.Mark.y_nice"><code class="name">var <span class="ident">y_nice</span></code></dt>
<dd>
<div class="desc"><p>Whether to nice Y axis scale ticks.</p></div>
</dd>
<dt id="h2o_q.types.Mark.y_scale"><code class="name">var <span class="ident">y_scale</span></code></dt>
<dd>
<div class="desc"><p>Y axis scale type. One of 'linear', 'cat', 'category', 'identity', 'log', 'pow', 'time', 'timeCat', 'quantize', 'quantile'.</p></div>
</dd>
<dt id="h2o_q.types.Mark.y_title"><code class="name">var <span class="ident">y_title</span></code></dt>
<dd>
<div class="desc"><p>Y axis title.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Mark.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    return _dump(
        coord=self.coord,
        type=self.type,
        x=self.x,
        x0=self.x0,
        x1=self.x1,
        x2=self.x2,
        x_min=self.x_min,
        x_max=self.x_max,
        x_nice=self.x_nice,
        x_scale=self.x_scale,
        x_title=self.x_title,
        y=self.y,
        y0=self.y0,
        y1=self.y1,
        y2=self.y2,
        y_min=self.y_min,
        y_max=self.y_max,
        y_nice=self.y_nice,
        y_scale=self.y_scale,
        y_title=self.y_title,
        color=self.color,
        color_range=self.color_range,
        color_domain=self.color_domain,
        shape=self.shape,
        shape_range=self.shape_range,
        size=self.size,
        size_range=self.size_range,
        stack=self.stack,
        dodge=self.dodge,
        curve=self.curve,
        fill_color=self.fill_color,
        fill_opacity=self.fill_opacity,
        stroke_color=self.stroke_color,
        stroke_opacity=self.stroke_opacity,
        stroke_size=self.stroke_size,
        stroke_dash=self.stroke_dash,
        label=self.label,
        label_offset=self.label_offset,
        label_offset_x=self.label_offset_x,
        label_offset_y=self.label_offset_y,
        label_rotation=self.label_rotation,
        label_position=self.label_position,
        label_overlap=self.label_overlap,
        label_fill_color=self.label_fill_color,
        label_fill_opacity=self.label_fill_opacity,
        label_stroke_color=self.label_stroke_color,
        label_stroke_opacity=self.label_stroke_opacity,
        label_stroke_size=self.label_stroke_size,
        label_font_size=self.label_font_size,
        label_font_weight=self.label_font_weight,
        label_line_height=self.label_line_height,
        label_align=self.label_align,
        ref_stroke_color=self.ref_stroke_color,
        ref_stroke_opacity=self.ref_stroke_opacity,
        ref_stroke_size=self.ref_stroke_size,
        ref_stroke_dash=self.ref_stroke_dash,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.MarkdownCard"><code class="flex name class">
<span>class <span class="ident">MarkdownCard</span></span>
<span>(</span><span>box: str, title: str, content: str, data: Union[dict, str, NoneType] = None, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a card that renders Markdown content.</p>
<p>Github-flavored markdown is supported.
HTML markup is allowed in markdown content.
URLs, if found, are displayed as hyperlinks.
Copyright, reserved, trademark, quotes, etc. are replaced with language-neutral symbols.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MarkdownCard:
    &#34;&#34;&#34;Create a card that renders Markdown content.

    Github-flavored markdown is supported.
    HTML markup is allowed in markdown content.
    URLs, if found, are displayed as hyperlinks.
    Copyright, reserved, trademark, quotes, etc. are replaced with language-neutral symbols.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            content: str,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The title for this card.&#34;&#34;&#34;
        self.content = content
        &#34;&#34;&#34;The markdown content. Supports Github Flavored Markdown (GFM): https://guides.github.com/features/mastering-markdown/&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Additional data for the card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;MarkdownCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;MarkdownCard.title is required.&#39;)
        if self.content is None:
            raise ValueError(&#39;MarkdownCard.content is required.&#39;)
        return _dump(
            view=&#39;markdown&#39;,
            box=self.box,
            title=self.title,
            content=self.content,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;MarkdownCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;MarkdownCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;MarkdownCard.title is required.&#39;)
        __d_content: Any = __d.get(&#39;content&#39;)
        if __d_content is None:
            raise ValueError(&#39;MarkdownCard.content is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        content: str = __d_content
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return MarkdownCard(
            box,
            title,
            content,
            data,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.MarkdownCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_MarkdownCard__d: Dict) ‑> <a title="h2o_q.types.MarkdownCard" href="#h2o_q.types.MarkdownCard">MarkdownCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;MarkdownCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;MarkdownCard.box is required.&#39;)
    __d_title: Any = __d.get(&#39;title&#39;)
    if __d_title is None:
        raise ValueError(&#39;MarkdownCard.title is required.&#39;)
    __d_content: Any = __d.get(&#39;content&#39;)
    if __d_content is None:
        raise ValueError(&#39;MarkdownCard.content is required.&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    title: str = __d_title
    content: str = __d_content
    data: Optional[PackedRecord] = __d_data
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return MarkdownCard(
        box,
        title,
        content,
        data,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.MarkdownCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.MarkdownCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.MarkdownCard.content"><code class="name">var <span class="ident">content</span></code></dt>
<dd>
<div class="desc"><p>The markdown content. Supports Github Flavored Markdown (GFM): <a href="https://guides.github.com/features/mastering-markdown/">https://guides.github.com/features/mastering-markdown/</a></p></div>
</dd>
<dt id="h2o_q.types.MarkdownCard.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Additional data for the card.</p></div>
</dd>
<dt id="h2o_q.types.MarkdownCard.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>The title for this card.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.MarkdownCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;MarkdownCard.box is required.&#39;)
    if self.title is None:
        raise ValueError(&#39;MarkdownCard.title is required.&#39;)
    if self.content is None:
        raise ValueError(&#39;MarkdownCard.content is required.&#39;)
    return _dump(
        view=&#39;markdown&#39;,
        box=self.box,
        title=self.title,
        content=self.content,
        data=self.data,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Markup"><code class="flex name class">
<span>class <span class="ident">Markup</span></span>
<span>(</span><span>content: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Render HTML content.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Markup:
    &#34;&#34;&#34;Render HTML content.
    &#34;&#34;&#34;
    def __init__(
            self,
            content: str,
    ):
        self.content = content
        &#34;&#34;&#34;The HTML content.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.content is None:
            raise ValueError(&#39;Markup.content is required.&#39;)
        return _dump(
            content=self.content,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Markup&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_content: Any = __d.get(&#39;content&#39;)
        if __d_content is None:
            raise ValueError(&#39;Markup.content is required.&#39;)
        content: str = __d_content
        return Markup(
            content,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Markup.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Markup__d: Dict) ‑> <a title="h2o_q.types.Markup" href="#h2o_q.types.Markup">Markup</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Markup&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_content: Any = __d.get(&#39;content&#39;)
    if __d_content is None:
        raise ValueError(&#39;Markup.content is required.&#39;)
    content: str = __d_content
    return Markup(
        content,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Markup.content"><code class="name">var <span class="ident">content</span></code></dt>
<dd>
<div class="desc"><p>The HTML content.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Markup.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.content is None:
        raise ValueError(&#39;Markup.content is required.&#39;)
    return _dump(
        content=self.content,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.MarkupCard"><code class="flex name class">
<span>class <span class="ident">MarkupCard</span></span>
<span>(</span><span>box: str, title: str, content: str, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Render HTML content.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MarkupCard:
    &#34;&#34;&#34;Render HTML content.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            content: str,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The title for this card.&#34;&#34;&#34;
        self.content = content
        &#34;&#34;&#34;The HTML content.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;MarkupCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;MarkupCard.title is required.&#39;)
        if self.content is None:
            raise ValueError(&#39;MarkupCard.content is required.&#39;)
        return _dump(
            view=&#39;markup&#39;,
            box=self.box,
            title=self.title,
            content=self.content,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;MarkupCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;MarkupCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;MarkupCard.title is required.&#39;)
        __d_content: Any = __d.get(&#39;content&#39;)
        if __d_content is None:
            raise ValueError(&#39;MarkupCard.content is required.&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        content: str = __d_content
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return MarkupCard(
            box,
            title,
            content,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.MarkupCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_MarkupCard__d: Dict) ‑> <a title="h2o_q.types.MarkupCard" href="#h2o_q.types.MarkupCard">MarkupCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;MarkupCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;MarkupCard.box is required.&#39;)
    __d_title: Any = __d.get(&#39;title&#39;)
    if __d_title is None:
        raise ValueError(&#39;MarkupCard.title is required.&#39;)
    __d_content: Any = __d.get(&#39;content&#39;)
    if __d_content is None:
        raise ValueError(&#39;MarkupCard.content is required.&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    title: str = __d_title
    content: str = __d_content
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return MarkupCard(
        box,
        title,
        content,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.MarkupCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.MarkupCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.MarkupCard.content"><code class="name">var <span class="ident">content</span></code></dt>
<dd>
<div class="desc"><p>The HTML content.</p></div>
</dd>
<dt id="h2o_q.types.MarkupCard.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>The title for this card.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.MarkupCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;MarkupCard.box is required.&#39;)
    if self.title is None:
        raise ValueError(&#39;MarkupCard.title is required.&#39;)
    if self.content is None:
        raise ValueError(&#39;MarkupCard.content is required.&#39;)
    return _dump(
        view=&#39;markup&#39;,
        box=self.box,
        title=self.title,
        content=self.content,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.MessageBar"><code class="flex name class">
<span>class <span class="ident">MessageBar</span></span>
<span>(</span><span>type: Union[str, NoneType] = None, text: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a message bar.</p>
<p>A message bar is an area at the top of a primary view that displays relevant status information.
You can use a message bar to tell the user about a situation that does not require their immediate attention and
therefore does not need to block other activities.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MessageBar:
    &#34;&#34;&#34;Create a message bar.

    A message bar is an area at the top of a primary view that displays relevant status information.
    You can use a message bar to tell the user about a situation that does not require their immediate attention and
    therefore does not need to block other activities.
    &#34;&#34;&#34;
    def __init__(
            self,
            type: Optional[str] = None,
            text: Optional[str] = None,
    ):
        self.type = type
        &#34;&#34;&#34;The icon and color of the message bar. One of &#39;info&#39;, &#39;error&#39;, &#39;warning&#39;, &#39;success&#39;, &#39;danger&#39;, &#39;blocked&#39;.&#34;&#34;&#34;
        self.text = text
        &#34;&#34;&#34;The text displayed on the message bar.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        return _dump(
            type=self.type,
            text=self.text,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;MessageBar&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_type: Any = __d.get(&#39;type&#39;)
        __d_text: Any = __d.get(&#39;text&#39;)
        type: Optional[str] = __d_type
        text: Optional[str] = __d_text
        return MessageBar(
            type,
            text,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.MessageBar.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_MessageBar__d: Dict) ‑> <a title="h2o_q.types.MessageBar" href="#h2o_q.types.MessageBar">MessageBar</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;MessageBar&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_type: Any = __d.get(&#39;type&#39;)
    __d_text: Any = __d.get(&#39;text&#39;)
    type: Optional[str] = __d_type
    text: Optional[str] = __d_text
    return MessageBar(
        type,
        text,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.MessageBar.text"><code class="name">var <span class="ident">text</span></code></dt>
<dd>
<div class="desc"><p>The text displayed on the message bar.</p></div>
</dd>
<dt id="h2o_q.types.MessageBar.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><p>The icon and color of the message bar. One of 'info', 'error', 'warning', 'success', 'danger', 'blocked'.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.MessageBar.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    return _dump(
        type=self.type,
        text=self.text,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.MetaCard"><code class="flex name class">
<span>class <span class="ident">MetaCard</span></span>
<span>(</span><span>box: str, title: Union[str, NoneType] = None, refresh: Union[int, NoneType] = None, notification: Union[str, NoneType] = None, redirect: Union[str, NoneType] = None, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents page-global state.</p>
<p>This card is invisible.
It is used to control attributes of the active page.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetaCard:
    &#34;&#34;&#34;Represents page-global state.

    This card is invisible.
    It is used to control attributes of the active page.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: Optional[str] = None,
            refresh: Optional[int] = None,
            notification: Optional[str] = None,
            redirect: Optional[str] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The title of the page.&#34;&#34;&#34;
        self.refresh = refresh
        &#34;&#34;&#34;Refresh rate in seconds. A value of 0 turns off live-updates. Values != 0 are currently ignored (reserved for future use).&#34;&#34;&#34;
        self.notification = notification
        &#34;&#34;&#34;Display a desktop notification to the user.&#34;&#34;&#34;
        self.redirect = redirect
        &#34;&#34;&#34;Redirect the page to a new URL.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;MetaCard.box is required.&#39;)
        return _dump(
            view=&#39;meta&#39;,
            box=self.box,
            title=self.title,
            refresh=self.refresh,
            notification=self.notification,
            redirect=self.redirect,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;MetaCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;MetaCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        __d_refresh: Any = __d.get(&#39;refresh&#39;)
        __d_notification: Any = __d.get(&#39;notification&#39;)
        __d_redirect: Any = __d.get(&#39;redirect&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: Optional[str] = __d_title
        refresh: Optional[int] = __d_refresh
        notification: Optional[str] = __d_notification
        redirect: Optional[str] = __d_redirect
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return MetaCard(
            box,
            title,
            refresh,
            notification,
            redirect,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.MetaCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_MetaCard__d: Dict) ‑> <a title="h2o_q.types.MetaCard" href="#h2o_q.types.MetaCard">MetaCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;MetaCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;MetaCard.box is required.&#39;)
    __d_title: Any = __d.get(&#39;title&#39;)
    __d_refresh: Any = __d.get(&#39;refresh&#39;)
    __d_notification: Any = __d.get(&#39;notification&#39;)
    __d_redirect: Any = __d.get(&#39;redirect&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    title: Optional[str] = __d_title
    refresh: Optional[int] = __d_refresh
    notification: Optional[str] = __d_notification
    redirect: Optional[str] = __d_redirect
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return MetaCard(
        box,
        title,
        refresh,
        notification,
        redirect,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.MetaCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.MetaCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.MetaCard.notification"><code class="name">var <span class="ident">notification</span></code></dt>
<dd>
<div class="desc"><p>Display a desktop notification to the user.</p></div>
</dd>
<dt id="h2o_q.types.MetaCard.redirect"><code class="name">var <span class="ident">redirect</span></code></dt>
<dd>
<div class="desc"><p>Redirect the page to a new URL.</p></div>
</dd>
<dt id="h2o_q.types.MetaCard.refresh"><code class="name">var <span class="ident">refresh</span></code></dt>
<dd>
<div class="desc"><p>Refresh rate in seconds. A value of 0 turns off live-updates. Values != 0 are currently ignored (reserved for future use).</p></div>
</dd>
<dt id="h2o_q.types.MetaCard.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>The title of the page.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.MetaCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;MetaCard.box is required.&#39;)
    return _dump(
        view=&#39;meta&#39;,
        box=self.box,
        title=self.title,
        refresh=self.refresh,
        notification=self.notification,
        redirect=self.redirect,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.NavCard"><code class="flex name class">
<span>class <span class="ident">NavCard</span></span>
<span>(</span><span>box: str, items: List[<a title="h2o_q.types.NavGroup" href="#h2o_q.types.NavGroup">NavGroup</a>], commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a card containing a navigation pane.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NavCard:
    &#34;&#34;&#34;Create a card containing a navigation pane.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            items: List[NavGroup],
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.items = items
        &#34;&#34;&#34;The navigation groups contained in this pane.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;NavCard.box is required.&#39;)
        if self.items is None:
            raise ValueError(&#39;NavCard.items is required.&#39;)
        return _dump(
            view=&#39;nav&#39;,
            box=self.box,
            items=[__e.dump() for __e in self.items],
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;NavCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;NavCard.box is required.&#39;)
        __d_items: Any = __d.get(&#39;items&#39;)
        if __d_items is None:
            raise ValueError(&#39;NavCard.items is required.&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        items: List[NavGroup] = [NavGroup.load(__e) for __e in __d_items]
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return NavCard(
            box,
            items,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.NavCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_NavCard__d: Dict) ‑> <a title="h2o_q.types.NavCard" href="#h2o_q.types.NavCard">NavCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;NavCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;NavCard.box is required.&#39;)
    __d_items: Any = __d.get(&#39;items&#39;)
    if __d_items is None:
        raise ValueError(&#39;NavCard.items is required.&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    items: List[NavGroup] = [NavGroup.load(__e) for __e in __d_items]
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return NavCard(
        box,
        items,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.NavCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.NavCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.NavCard.items"><code class="name">var <span class="ident">items</span></code></dt>
<dd>
<div class="desc"><p>The navigation groups contained in this pane.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.NavCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;NavCard.box is required.&#39;)
    if self.items is None:
        raise ValueError(&#39;NavCard.items is required.&#39;)
    return _dump(
        view=&#39;nav&#39;,
        box=self.box,
        items=[__e.dump() for __e in self.items],
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.NavGroup"><code class="flex name class">
<span>class <span class="ident">NavGroup</span></span>
<span>(</span><span>label: str, items: List[<a title="h2o_q.types.NavItem" href="#h2o_q.types.NavItem">NavItem</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Create a group of navigation items.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NavGroup:
    &#34;&#34;&#34;Create a group of navigation items.
    &#34;&#34;&#34;
    def __init__(
            self,
            label: str,
            items: List[NavItem],
    ):
        self.label = label
        &#34;&#34;&#34;The label to display for this group.&#34;&#34;&#34;
        self.items = items
        &#34;&#34;&#34;The navigation items contained in this group.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.label is None:
            raise ValueError(&#39;NavGroup.label is required.&#39;)
        if self.items is None:
            raise ValueError(&#39;NavGroup.items is required.&#39;)
        return _dump(
            label=self.label,
            items=[__e.dump() for __e in self.items],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;NavGroup&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_label: Any = __d.get(&#39;label&#39;)
        if __d_label is None:
            raise ValueError(&#39;NavGroup.label is required.&#39;)
        __d_items: Any = __d.get(&#39;items&#39;)
        if __d_items is None:
            raise ValueError(&#39;NavGroup.items is required.&#39;)
        label: str = __d_label
        items: List[NavItem] = [NavItem.load(__e) for __e in __d_items]
        return NavGroup(
            label,
            items,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.NavGroup.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_NavGroup__d: Dict) ‑> <a title="h2o_q.types.NavGroup" href="#h2o_q.types.NavGroup">NavGroup</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;NavGroup&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_label: Any = __d.get(&#39;label&#39;)
    if __d_label is None:
        raise ValueError(&#39;NavGroup.label is required.&#39;)
    __d_items: Any = __d.get(&#39;items&#39;)
    if __d_items is None:
        raise ValueError(&#39;NavGroup.items is required.&#39;)
    label: str = __d_label
    items: List[NavItem] = [NavItem.load(__e) for __e in __d_items]
    return NavGroup(
        label,
        items,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.NavGroup.items"><code class="name">var <span class="ident">items</span></code></dt>
<dd>
<div class="desc"><p>The navigation items contained in this group.</p></div>
</dd>
<dt id="h2o_q.types.NavGroup.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>The label to display for this group.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.NavGroup.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.label is None:
        raise ValueError(&#39;NavGroup.label is required.&#39;)
    if self.items is None:
        raise ValueError(&#39;NavGroup.items is required.&#39;)
    return _dump(
        label=self.label,
        items=[__e.dump() for __e in self.items],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.NavItem"><code class="flex name class">
<span>class <span class="ident">NavItem</span></span>
<span>(</span><span>name: str, label: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a navigation item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NavItem:
    &#34;&#34;&#34;Create a navigation item.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: str,
    ):
        self.name = name
        &#34;&#34;&#34;The name of this item. Prefix the name with a &#39;#&#39; to trigger hash-change navigation.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;The label to display.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;NavItem.name is required.&#39;)
        if self.label is None:
            raise ValueError(&#39;NavItem.label is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;NavItem&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;NavItem.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        if __d_label is None:
            raise ValueError(&#39;NavItem.label is required.&#39;)
        name: str = __d_name
        label: str = __d_label
        return NavItem(
            name,
            label,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.NavItem.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_NavItem__d: Dict) ‑> <a title="h2o_q.types.NavItem" href="#h2o_q.types.NavItem">NavItem</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;NavItem&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;NavItem.name is required.&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    if __d_label is None:
        raise ValueError(&#39;NavItem.label is required.&#39;)
    name: str = __d_name
    label: str = __d_label
    return NavItem(
        name,
        label,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.NavItem.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>The label to display.</p></div>
</dd>
<dt id="h2o_q.types.NavItem.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>The name of this item. Prefix the name with a '#' to trigger hash-change navigation.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.NavItem.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;NavItem.name is required.&#39;)
    if self.label is None:
        raise ValueError(&#39;NavItem.label is required.&#39;)
    return _dump(
        name=self.name,
        label=self.label,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Picker"><code class="flex name class">
<span>class <span class="ident">Picker</span></span>
<span>(</span><span>name: str, choices: List[<a title="h2o_q.types.Choice" href="#h2o_q.types.Choice">Choice</a>], label: Union[str, NoneType] = None, values: Union[List[str], NoneType] = None, max_choices: Union[int, NoneType] = None, disabled: Union[bool, NoneType] = None, tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a picker.
Pickers are used to select one or more choices, such as tags or files, from a list.
Use a picker to allow the user to quickly search for or manage a few tags or files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Picker:
    &#34;&#34;&#34;Create a picker.
    Pickers are used to select one or more choices, such as tags or files, from a list.
    Use a picker to allow the user to quickly search for or manage a few tags or files.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            choices: List[Choice],
            label: Optional[str] = None,
            values: Optional[List[str]] = None,
            max_choices: Optional[int] = None,
            disabled: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.choices = choices
        &#34;&#34;&#34;The choices to be presented.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed above the component.&#34;&#34;&#34;
        self.values = values
        &#34;&#34;&#34;The names of the selected choices.&#34;&#34;&#34;
        self.max_choices = max_choices
        &#34;&#34;&#34;Maximum number of selectable choices. Defaults to no limit.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;Controls whether the picker should be disabled or not.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Picker.name is required.&#39;)
        if self.choices is None:
            raise ValueError(&#39;Picker.choices is required.&#39;)
        return _dump(
            name=self.name,
            choices=[__e.dump() for __e in self.choices],
            label=self.label,
            values=self.values,
            max_choices=self.max_choices,
            disabled=self.disabled,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Picker&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Picker.name is required.&#39;)
        __d_choices: Any = __d.get(&#39;choices&#39;)
        if __d_choices is None:
            raise ValueError(&#39;Picker.choices is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_values: Any = __d.get(&#39;values&#39;)
        __d_max_choices: Any = __d.get(&#39;max_choices&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        choices: List[Choice] = [Choice.load(__e) for __e in __d_choices]
        label: Optional[str] = __d_label
        values: Optional[List[str]] = __d_values
        max_choices: Optional[int] = __d_max_choices
        disabled: Optional[bool] = __d_disabled
        tooltip: Optional[str] = __d_tooltip
        return Picker(
            name,
            choices,
            label,
            values,
            max_choices,
            disabled,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Picker.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Picker__d: Dict) ‑> <a title="h2o_q.types.Picker" href="#h2o_q.types.Picker">Picker</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Picker&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;Picker.name is required.&#39;)
    __d_choices: Any = __d.get(&#39;choices&#39;)
    if __d_choices is None:
        raise ValueError(&#39;Picker.choices is required.&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    __d_values: Any = __d.get(&#39;values&#39;)
    __d_max_choices: Any = __d.get(&#39;max_choices&#39;)
    __d_disabled: Any = __d.get(&#39;disabled&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    name: str = __d_name
    choices: List[Choice] = [Choice.load(__e) for __e in __d_choices]
    label: Optional[str] = __d_label
    values: Optional[List[str]] = __d_values
    max_choices: Optional[int] = __d_max_choices
    disabled: Optional[bool] = __d_disabled
    tooltip: Optional[str] = __d_tooltip
    return Picker(
        name,
        choices,
        label,
        values,
        max_choices,
        disabled,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Picker.choices"><code class="name">var <span class="ident">choices</span></code></dt>
<dd>
<div class="desc"><p>The choices to be presented.</p></div>
</dd>
<dt id="h2o_q.types.Picker.disabled"><code class="name">var <span class="ident">disabled</span></code></dt>
<dd>
<div class="desc"><p>Controls whether the picker should be disabled or not.</p></div>
</dd>
<dt id="h2o_q.types.Picker.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>Text to be displayed above the component.</p></div>
</dd>
<dt id="h2o_q.types.Picker.max_choices"><code class="name">var <span class="ident">max_choices</span></code></dt>
<dd>
<div class="desc"><p>Maximum number of selectable choices. Defaults to no limit.</p></div>
</dd>
<dt id="h2o_q.types.Picker.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this component.</p></div>
</dd>
<dt id="h2o_q.types.Picker.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>An optional tooltip message displayed when a user clicks the help icon to the right of the component.</p></div>
</dd>
<dt id="h2o_q.types.Picker.values"><code class="name">var <span class="ident">values</span></code></dt>
<dd>
<div class="desc"><p>The names of the selected choices.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Picker.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;Picker.name is required.&#39;)
    if self.choices is None:
        raise ValueError(&#39;Picker.choices is required.&#39;)
    return _dump(
        name=self.name,
        choices=[__e.dump() for __e in self.choices],
        label=self.label,
        values=self.values,
        max_choices=self.max_choices,
        disabled=self.disabled,
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.PixelArtCard"><code class="flex name class">
<span>class <span class="ident">PixelArtCard</span></span>
<span>(</span><span>box: str, title: str, data: Union[dict, str], commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a card displaying a collaborative Pixel art tool, just for kicks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PixelArtCard:
    &#34;&#34;&#34;Create a card displaying a collaborative Pixel art tool, just for kicks.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            data: PackedRecord,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The title for this card.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;The data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;PixelArtCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;PixelArtCard.title is required.&#39;)
        if self.data is None:
            raise ValueError(&#39;PixelArtCard.data is required.&#39;)
        return _dump(
            view=&#39;pixel_art&#39;,
            box=self.box,
            title=self.title,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;PixelArtCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;PixelArtCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;PixelArtCard.title is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        if __d_data is None:
            raise ValueError(&#39;PixelArtCard.data is required.&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        data: PackedRecord = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return PixelArtCard(
            box,
            title,
            data,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.PixelArtCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_PixelArtCard__d: Dict) ‑> <a title="h2o_q.types.PixelArtCard" href="#h2o_q.types.PixelArtCard">PixelArtCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;PixelArtCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;PixelArtCard.box is required.&#39;)
    __d_title: Any = __d.get(&#39;title&#39;)
    if __d_title is None:
        raise ValueError(&#39;PixelArtCard.title is required.&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    if __d_data is None:
        raise ValueError(&#39;PixelArtCard.data is required.&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    title: str = __d_title
    data: PackedRecord = __d_data
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return PixelArtCard(
        box,
        title,
        data,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.PixelArtCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.PixelArtCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.PixelArtCard.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>The data for this card.</p></div>
</dd>
<dt id="h2o_q.types.PixelArtCard.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>The title for this card.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.PixelArtCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;PixelArtCard.box is required.&#39;)
    if self.title is None:
        raise ValueError(&#39;PixelArtCard.title is required.&#39;)
    if self.data is None:
        raise ValueError(&#39;PixelArtCard.data is required.&#39;)
    return _dump(
        view=&#39;pixel_art&#39;,
        box=self.box,
        title=self.title,
        data=self.data,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Plot"><code class="flex name class">
<span>class <span class="ident">Plot</span></span>
<span>(</span><span>marks: List[<a title="h2o_q.types.Mark" href="#h2o_q.types.Mark">Mark</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Create a plot. A plot is composed of one or more graphical mark layers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Plot:
    &#34;&#34;&#34;Create a plot. A plot is composed of one or more graphical mark layers.
    &#34;&#34;&#34;
    def __init__(
            self,
            marks: List[Mark],
    ):
        self.marks = marks
        &#34;&#34;&#34;The graphical mark layers contained in this plot.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.marks is None:
            raise ValueError(&#39;Plot.marks is required.&#39;)
        return _dump(
            marks=[__e.dump() for __e in self.marks],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Plot&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_marks: Any = __d.get(&#39;marks&#39;)
        if __d_marks is None:
            raise ValueError(&#39;Plot.marks is required.&#39;)
        marks: List[Mark] = [Mark.load(__e) for __e in __d_marks]
        return Plot(
            marks,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Plot.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Plot__d: Dict) ‑> <a title="h2o_q.types.Plot" href="#h2o_q.types.Plot">Plot</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Plot&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_marks: Any = __d.get(&#39;marks&#39;)
    if __d_marks is None:
        raise ValueError(&#39;Plot.marks is required.&#39;)
    marks: List[Mark] = [Mark.load(__e) for __e in __d_marks]
    return Plot(
        marks,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Plot.marks"><code class="name">var <span class="ident">marks</span></code></dt>
<dd>
<div class="desc"><p>The graphical mark layers contained in this plot.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Plot.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.marks is None:
        raise ValueError(&#39;Plot.marks is required.&#39;)
    return _dump(
        marks=[__e.dump() for __e in self.marks],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.PlotCard"><code class="flex name class">
<span>class <span class="ident">PlotCard</span></span>
<span>(</span><span>box: str, title: str, data: Union[dict, str], plot: <a title="h2o_q.types.Plot" href="#h2o_q.types.Plot">Plot</a>, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a card displaying a plot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PlotCard:
    &#34;&#34;&#34;Create a card displaying a plot.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            data: PackedRecord,
            plot: Plot,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The title for this card.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.plot = plot
        &#34;&#34;&#34;The plot to be displayed in this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;PlotCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;PlotCard.title is required.&#39;)
        if self.data is None:
            raise ValueError(&#39;PlotCard.data is required.&#39;)
        if self.plot is None:
            raise ValueError(&#39;PlotCard.plot is required.&#39;)
        return _dump(
            view=&#39;plot&#39;,
            box=self.box,
            title=self.title,
            data=self.data,
            plot=self.plot.dump(),
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;PlotCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;PlotCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;PlotCard.title is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        if __d_data is None:
            raise ValueError(&#39;PlotCard.data is required.&#39;)
        __d_plot: Any = __d.get(&#39;plot&#39;)
        if __d_plot is None:
            raise ValueError(&#39;PlotCard.plot is required.&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        data: PackedRecord = __d_data
        plot: Plot = Plot.load(__d_plot)
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return PlotCard(
            box,
            title,
            data,
            plot,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.PlotCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_PlotCard__d: Dict) ‑> <a title="h2o_q.types.PlotCard" href="#h2o_q.types.PlotCard">PlotCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;PlotCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;PlotCard.box is required.&#39;)
    __d_title: Any = __d.get(&#39;title&#39;)
    if __d_title is None:
        raise ValueError(&#39;PlotCard.title is required.&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    if __d_data is None:
        raise ValueError(&#39;PlotCard.data is required.&#39;)
    __d_plot: Any = __d.get(&#39;plot&#39;)
    if __d_plot is None:
        raise ValueError(&#39;PlotCard.plot is required.&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    title: str = __d_title
    data: PackedRecord = __d_data
    plot: Plot = Plot.load(__d_plot)
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return PlotCard(
        box,
        title,
        data,
        plot,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.PlotCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.PlotCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.PlotCard.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Data for this card.</p></div>
</dd>
<dt id="h2o_q.types.PlotCard.plot"><code class="name">var <span class="ident">plot</span></code></dt>
<dd>
<div class="desc"><p>The plot to be displayed in this card.</p></div>
</dd>
<dt id="h2o_q.types.PlotCard.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>The title for this card.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.PlotCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;PlotCard.box is required.&#39;)
    if self.title is None:
        raise ValueError(&#39;PlotCard.title is required.&#39;)
    if self.data is None:
        raise ValueError(&#39;PlotCard.data is required.&#39;)
    if self.plot is None:
        raise ValueError(&#39;PlotCard.plot is required.&#39;)
    return _dump(
        view=&#39;plot&#39;,
        box=self.box,
        title=self.title,
        data=self.data,
        plot=self.plot.dump(),
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Progress"><code class="flex name class">
<span>class <span class="ident">Progress</span></span>
<span>(</span><span>label: str, caption: Union[str, NoneType] = None, value: Union[float, NoneType] = None, tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a progress bar.</p>
<p>Progress bars are used to show the completion status of an operation lasting more than 2 seconds.
If the state of progress cannot be determined, do not set a value.
Progress bars feature a bar showing total units to completion, and total units finished.
The label appears above the bar, and the caption appears below.
The label should tell someone exactly what the operation is doing.</p>
<p>Examples of formatting include:
[Object] is being [operation name], or
[Object] is being [operation name] to [destination name] or
[Object] is being [operation name] from [source name] to [destination name]</p>
<p>Status text is generally in units elapsed and total units.
Real-world examples include copying files to a storage location, saving edits to a file, and more.
Use units that are informative and relevant to give the best idea to users of how long the operation will take to complete.
Avoid time units as they are rarely accurate enough to be trustworthy.
Also, combine steps of a complex operation into one total bar to avoid “rewinding” the bar.
Instead change the label to reflect the change if necessary. Bars moving backwards reduce confidence in the service.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Progress:
    &#34;&#34;&#34;Create a progress bar.

    Progress bars are used to show the completion status of an operation lasting more than 2 seconds.
    If the state of progress cannot be determined, do not set a value.
    Progress bars feature a bar showing total units to completion, and total units finished.
    The label appears above the bar, and the caption appears below.
    The label should tell someone exactly what the operation is doing.

    Examples of formatting include:
    [Object] is being [operation name], or
    [Object] is being [operation name] to [destination name] or
    [Object] is being [operation name] from [source name] to [destination name]

    Status text is generally in units elapsed and total units.
    Real-world examples include copying files to a storage location, saving edits to a file, and more.
    Use units that are informative and relevant to give the best idea to users of how long the operation will take to complete.
    Avoid time units as they are rarely accurate enough to be trustworthy.
    Also, combine steps of a complex operation into one total bar to avoid “rewinding” the bar.
    Instead change the label to reflect the change if necessary. Bars moving backwards reduce confidence in the service.
    &#34;&#34;&#34;
    def __init__(
            self,
            label: str,
            caption: Optional[str] = None,
            value: Optional[float] = None,
            tooltip: Optional[str] = None,
    ):
        self.label = label
        &#34;&#34;&#34;The text displayed above the bar.&#34;&#34;&#34;
        self.caption = caption
        &#34;&#34;&#34;The text displayed below the bar.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The progress, between 0.0 and 1.0, or -1 (default) if indeterminate.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.label is None:
            raise ValueError(&#39;Progress.label is required.&#39;)
        return _dump(
            label=self.label,
            caption=self.caption,
            value=self.value,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Progress&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_label: Any = __d.get(&#39;label&#39;)
        if __d_label is None:
            raise ValueError(&#39;Progress.label is required.&#39;)
        __d_caption: Any = __d.get(&#39;caption&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        label: str = __d_label
        caption: Optional[str] = __d_caption
        value: Optional[float] = __d_value
        tooltip: Optional[str] = __d_tooltip
        return Progress(
            label,
            caption,
            value,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Progress.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Progress__d: Dict) ‑> <a title="h2o_q.types.Progress" href="#h2o_q.types.Progress">Progress</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Progress&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_label: Any = __d.get(&#39;label&#39;)
    if __d_label is None:
        raise ValueError(&#39;Progress.label is required.&#39;)
    __d_caption: Any = __d.get(&#39;caption&#39;)
    __d_value: Any = __d.get(&#39;value&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    label: str = __d_label
    caption: Optional[str] = __d_caption
    value: Optional[float] = __d_value
    tooltip: Optional[str] = __d_tooltip
    return Progress(
        label,
        caption,
        value,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Progress.caption"><code class="name">var <span class="ident">caption</span></code></dt>
<dd>
<div class="desc"><p>The text displayed below the bar.</p></div>
</dd>
<dt id="h2o_q.types.Progress.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>The text displayed above the bar.</p></div>
</dd>
<dt id="h2o_q.types.Progress.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>An optional tooltip message displayed when a user clicks the help icon to the right of the component.</p></div>
</dd>
<dt id="h2o_q.types.Progress.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>The progress, between 0.0 and 1.0, or -1 (default) if indeterminate.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Progress.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.label is None:
        raise ValueError(&#39;Progress.label is required.&#39;)
    return _dump(
        label=self.label,
        caption=self.caption,
        value=self.value,
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.ProgressTableCellType"><code class="flex name class">
<span>class <span class="ident">ProgressTableCellType</span></span>
<span>(</span><span>color: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a cell type that renders a column's cells as progress bars instead of plain text.
If set on a column, the cell value must be between 0.0 and 1.0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProgressTableCellType:
    &#34;&#34;&#34;Create a cell type that renders a column&#39;s cells as progress bars instead of plain text.
    If set on a column, the cell value must be between 0.0 and 1.0.
    &#34;&#34;&#34;
    def __init__(
            self,
            color: Optional[str] = None,
    ):
        self.color = color
        &#34;&#34;&#34;Color of the progress arc.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        return _dump(
            color=self.color,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;ProgressTableCellType&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_color: Any = __d.get(&#39;color&#39;)
        color: Optional[str] = __d_color
        return ProgressTableCellType(
            color,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.ProgressTableCellType.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_ProgressTableCellType__d: Dict) ‑> <a title="h2o_q.types.ProgressTableCellType" href="#h2o_q.types.ProgressTableCellType">ProgressTableCellType</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;ProgressTableCellType&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_color: Any = __d.get(&#39;color&#39;)
    color: Optional[str] = __d_color
    return ProgressTableCellType(
        color,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.ProgressTableCellType.color"><code class="name">var <span class="ident">color</span></code></dt>
<dd>
<div class="desc"><p>Color of the progress arc.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.ProgressTableCellType.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    return _dump(
        color=self.color,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.RangeSlider"><code class="flex name class">
<span>class <span class="ident">RangeSlider</span></span>
<span>(</span><span>name: str, label: Union[str, NoneType] = None, min: Union[float, NoneType] = None, max: Union[float, NoneType] = None, step: Union[float, NoneType] = None, min_value: Union[float, NoneType] = None, max_value: Union[float, NoneType] = None, disabled: Union[bool, NoneType] = None, trigger: Union[bool, NoneType] = None, tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a range slider.</p>
<p>A range slider is an element used to select a value range. It provides a visual indication of adjustable content, as well as the
current setting in the total range of content. It is displayed as a horizontal track with options on either side.
Knobs or levers are dragged to one end or the other to make the choice, indicating the current max and min value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RangeSlider:
    &#34;&#34;&#34;Create a range slider.

    A range slider is an element used to select a value range. It provides a visual indication of adjustable content, as well as the
    current setting in the total range of content. It is displayed as a horizontal track with options on either side.
    Knobs or levers are dragged to one end or the other to make the choice, indicating the current max and min value.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            min: Optional[float] = None,
            max: Optional[float] = None,
            step: Optional[float] = None,
            min_value: Optional[float] = None,
            max_value: Optional[float] = None,
            disabled: Optional[bool] = None,
            trigger: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the component.&#34;&#34;&#34;
        self.min = min
        &#34;&#34;&#34;The minimum value of the slider. Defaults to 0.&#34;&#34;&#34;
        self.max = max
        &#34;&#34;&#34;The maximum value of the slider. Defaults to 100.&#34;&#34;&#34;
        self.step = step
        &#34;&#34;&#34;The difference between two adjacent values of the slider.&#34;&#34;&#34;
        self.min_value = min_value
        &#34;&#34;&#34;The lower bound of the selected range.&#34;&#34;&#34;
        self.max_value = max_value
        &#34;&#34;&#34;The upper bound of the selected range.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if this field is disabled.&#34;&#34;&#34;
        self.trigger = trigger
        &#34;&#34;&#34;True if the form should be submitted when the slider value changes.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;RangeSlider.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            min=self.min,
            max=self.max,
            step=self.step,
            min_value=self.min_value,
            max_value=self.max_value,
            disabled=self.disabled,
            trigger=self.trigger,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;RangeSlider&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;RangeSlider.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_min: Any = __d.get(&#39;min&#39;)
        __d_max: Any = __d.get(&#39;max&#39;)
        __d_step: Any = __d.get(&#39;step&#39;)
        __d_min_value: Any = __d.get(&#39;min_value&#39;)
        __d_max_value: Any = __d.get(&#39;max_value&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_trigger: Any = __d.get(&#39;trigger&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        min: Optional[float] = __d_min
        max: Optional[float] = __d_max
        step: Optional[float] = __d_step
        min_value: Optional[float] = __d_min_value
        max_value: Optional[float] = __d_max_value
        disabled: Optional[bool] = __d_disabled
        trigger: Optional[bool] = __d_trigger
        tooltip: Optional[str] = __d_tooltip
        return RangeSlider(
            name,
            label,
            min,
            max,
            step,
            min_value,
            max_value,
            disabled,
            trigger,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.RangeSlider.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_RangeSlider__d: Dict) ‑> <a title="h2o_q.types.RangeSlider" href="#h2o_q.types.RangeSlider">RangeSlider</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;RangeSlider&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;RangeSlider.name is required.&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    __d_min: Any = __d.get(&#39;min&#39;)
    __d_max: Any = __d.get(&#39;max&#39;)
    __d_step: Any = __d.get(&#39;step&#39;)
    __d_min_value: Any = __d.get(&#39;min_value&#39;)
    __d_max_value: Any = __d.get(&#39;max_value&#39;)
    __d_disabled: Any = __d.get(&#39;disabled&#39;)
    __d_trigger: Any = __d.get(&#39;trigger&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    name: str = __d_name
    label: Optional[str] = __d_label
    min: Optional[float] = __d_min
    max: Optional[float] = __d_max
    step: Optional[float] = __d_step
    min_value: Optional[float] = __d_min_value
    max_value: Optional[float] = __d_max_value
    disabled: Optional[bool] = __d_disabled
    trigger: Optional[bool] = __d_trigger
    tooltip: Optional[str] = __d_tooltip
    return RangeSlider(
        name,
        label,
        min,
        max,
        step,
        min_value,
        max_value,
        disabled,
        trigger,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.RangeSlider.disabled"><code class="name">var <span class="ident">disabled</span></code></dt>
<dd>
<div class="desc"><p>True if this field is disabled.</p></div>
</dd>
<dt id="h2o_q.types.RangeSlider.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>Text to be displayed alongside the component.</p></div>
</dd>
<dt id="h2o_q.types.RangeSlider.max"><code class="name">var <span class="ident">max</span></code></dt>
<dd>
<div class="desc"><p>The maximum value of the slider. Defaults to 100.</p></div>
</dd>
<dt id="h2o_q.types.RangeSlider.max_value"><code class="name">var <span class="ident">max_value</span></code></dt>
<dd>
<div class="desc"><p>The upper bound of the selected range.</p></div>
</dd>
<dt id="h2o_q.types.RangeSlider.min"><code class="name">var <span class="ident">min</span></code></dt>
<dd>
<div class="desc"><p>The minimum value of the slider. Defaults to 0.</p></div>
</dd>
<dt id="h2o_q.types.RangeSlider.min_value"><code class="name">var <span class="ident">min_value</span></code></dt>
<dd>
<div class="desc"><p>The lower bound of the selected range.</p></div>
</dd>
<dt id="h2o_q.types.RangeSlider.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this component.</p></div>
</dd>
<dt id="h2o_q.types.RangeSlider.step"><code class="name">var <span class="ident">step</span></code></dt>
<dd>
<div class="desc"><p>The difference between two adjacent values of the slider.</p></div>
</dd>
<dt id="h2o_q.types.RangeSlider.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>An optional tooltip message displayed when a user clicks the help icon to the right of the component.</p></div>
</dd>
<dt id="h2o_q.types.RangeSlider.trigger"><code class="name">var <span class="ident">trigger</span></code></dt>
<dd>
<div class="desc"><p>True if the form should be submitted when the slider value changes.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.RangeSlider.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;RangeSlider.name is required.&#39;)
    return _dump(
        name=self.name,
        label=self.label,
        min=self.min,
        max=self.max,
        step=self.step,
        min_value=self.min_value,
        max_value=self.max_value,
        disabled=self.disabled,
        trigger=self.trigger,
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.RepeatCard"><code class="flex name class">
<span>class <span class="ident">RepeatCard</span></span>
<span>(</span><span>box: str, item_view: str, item_props: Union[dict, str], data: Union[<a title="h2o_q.core.Data" href="core.html#h2o_q.core.Data">Data</a>, str], commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>EXPERIMENTAL. DO NOT USE.
Create a card containing other cards.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RepeatCard:
    &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.
    Create a card containing other cards.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            item_view: str,
            item_props: PackedRecord,
            data: PackedData,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.item_view = item_view
        &#34;&#34;&#34;EXPERIMENTAL. DO NOT USE.&#34;&#34;&#34;
        self.item_props = item_props
        &#34;&#34;&#34;The child card properties.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;RepeatCard.box is required.&#39;)
        if self.item_view is None:
            raise ValueError(&#39;RepeatCard.item_view is required.&#39;)
        if self.item_props is None:
            raise ValueError(&#39;RepeatCard.item_props is required.&#39;)
        if self.data is None:
            raise ValueError(&#39;RepeatCard.data is required.&#39;)
        return _dump(
            view=&#39;repeat&#39;,
            box=self.box,
            item_view=self.item_view,
            item_props=self.item_props,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;RepeatCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;RepeatCard.box is required.&#39;)
        __d_item_view: Any = __d.get(&#39;item_view&#39;)
        if __d_item_view is None:
            raise ValueError(&#39;RepeatCard.item_view is required.&#39;)
        __d_item_props: Any = __d.get(&#39;item_props&#39;)
        if __d_item_props is None:
            raise ValueError(&#39;RepeatCard.item_props is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        if __d_data is None:
            raise ValueError(&#39;RepeatCard.data is required.&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        item_view: str = __d_item_view
        item_props: PackedRecord = __d_item_props
        data: PackedData = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return RepeatCard(
            box,
            item_view,
            item_props,
            data,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.RepeatCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_RepeatCard__d: Dict) ‑> <a title="h2o_q.types.RepeatCard" href="#h2o_q.types.RepeatCard">RepeatCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;RepeatCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;RepeatCard.box is required.&#39;)
    __d_item_view: Any = __d.get(&#39;item_view&#39;)
    if __d_item_view is None:
        raise ValueError(&#39;RepeatCard.item_view is required.&#39;)
    __d_item_props: Any = __d.get(&#39;item_props&#39;)
    if __d_item_props is None:
        raise ValueError(&#39;RepeatCard.item_props is required.&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    if __d_data is None:
        raise ValueError(&#39;RepeatCard.data is required.&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    item_view: str = __d_item_view
    item_props: PackedRecord = __d_item_props
    data: PackedData = __d_data
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return RepeatCard(
        box,
        item_view,
        item_props,
        data,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.RepeatCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.RepeatCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.RepeatCard.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Data for this card.</p></div>
</dd>
<dt id="h2o_q.types.RepeatCard.item_props"><code class="name">var <span class="ident">item_props</span></code></dt>
<dd>
<div class="desc"><p>The child card properties.</p></div>
</dd>
<dt id="h2o_q.types.RepeatCard.item_view"><code class="name">var <span class="ident">item_view</span></code></dt>
<dd>
<div class="desc"><p>EXPERIMENTAL. DO NOT USE.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.RepeatCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;RepeatCard.box is required.&#39;)
    if self.item_view is None:
        raise ValueError(&#39;RepeatCard.item_view is required.&#39;)
    if self.item_props is None:
        raise ValueError(&#39;RepeatCard.item_props is required.&#39;)
    if self.data is None:
        raise ValueError(&#39;RepeatCard.data is required.&#39;)
    return _dump(
        view=&#39;repeat&#39;,
        box=self.box,
        item_view=self.item_view,
        item_props=self.item_props,
        data=self.data,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Separator"><code class="flex name class">
<span>class <span class="ident">Separator</span></span>
<span>(</span><span>label: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a separator.</p>
<p>A separator visually separates content into groups.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Separator:
    &#34;&#34;&#34;Create a separator.

    A separator visually separates content into groups.
    &#34;&#34;&#34;
    def __init__(
            self,
            label: Optional[str] = None,
    ):
        self.label = label
        &#34;&#34;&#34;The text displayed on the separator.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        return _dump(
            label=self.label,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Separator&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_label: Any = __d.get(&#39;label&#39;)
        label: Optional[str] = __d_label
        return Separator(
            label,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Separator.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Separator__d: Dict) ‑> <a title="h2o_q.types.Separator" href="#h2o_q.types.Separator">Separator</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Separator&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_label: Any = __d.get(&#39;label&#39;)
    label: Optional[str] = __d_label
    return Separator(
        label,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Separator.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>The text displayed on the separator.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Separator.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    return _dump(
        label=self.label,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Slider"><code class="flex name class">
<span>class <span class="ident">Slider</span></span>
<span>(</span><span>name: str, label: Union[str, NoneType] = None, min: Union[float, NoneType] = None, max: Union[float, NoneType] = None, step: Union[float, NoneType] = None, value: Union[float, NoneType] = None, disabled: Union[bool, NoneType] = None, trigger: Union[bool, NoneType] = None, tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a slider.</p>
<p>A slider is an element used to set a value. It provides a visual indication of adjustable content, as well as the
current setting in the total range of content. It is displayed as a horizontal track with options on either side.
A knob or lever is dragged to one end or the other to make the choice, indicating the current value.
Marks on the slider bar can show values and users can choose where they want to drag the knob or lever to
set the value.</p>
<p>A slider is a good choice when you know that users think of the value as a relative quantity, not a numeric value.
For example, users think about setting their audio volume to low or medium — not about setting the
value to two or five.</p>
<p>The default value of the slider will be zero or be constrained to the min and max values. The min will be returned
if the value is set under the min and the max will be returned if set higher than the max value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Slider:
    &#34;&#34;&#34;Create a slider.

    A slider is an element used to set a value. It provides a visual indication of adjustable content, as well as the
    current setting in the total range of content. It is displayed as a horizontal track with options on either side.
    A knob or lever is dragged to one end or the other to make the choice, indicating the current value.
    Marks on the slider bar can show values and users can choose where they want to drag the knob or lever to
    set the value.

    A slider is a good choice when you know that users think of the value as a relative quantity, not a numeric value.
    For example, users think about setting their audio volume to low or medium — not about setting the
    value to two or five.

    The default value of the slider will be zero or be constrained to the min and max values. The min will be returned
    if the value is set under the min and the max will be returned if set higher than the max value.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            min: Optional[float] = None,
            max: Optional[float] = None,
            step: Optional[float] = None,
            value: Optional[float] = None,
            disabled: Optional[bool] = None,
            trigger: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the component.&#34;&#34;&#34;
        self.min = min
        &#34;&#34;&#34;The minimum value of the slider.&#34;&#34;&#34;
        self.max = max
        &#34;&#34;&#34;The maximum value of the slider.&#34;&#34;&#34;
        self.step = step
        &#34;&#34;&#34;The difference between two adjacent values of the slider.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The current value of the slider.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if this field is disabled.&#34;&#34;&#34;
        self.trigger = trigger
        &#34;&#34;&#34;True if the form should be submitted when the slider value changes.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Slider.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            min=self.min,
            max=self.max,
            step=self.step,
            value=self.value,
            disabled=self.disabled,
            trigger=self.trigger,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Slider&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Slider.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_min: Any = __d.get(&#39;min&#39;)
        __d_max: Any = __d.get(&#39;max&#39;)
        __d_step: Any = __d.get(&#39;step&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_trigger: Any = __d.get(&#39;trigger&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        min: Optional[float] = __d_min
        max: Optional[float] = __d_max
        step: Optional[float] = __d_step
        value: Optional[float] = __d_value
        disabled: Optional[bool] = __d_disabled
        trigger: Optional[bool] = __d_trigger
        tooltip: Optional[str] = __d_tooltip
        return Slider(
            name,
            label,
            min,
            max,
            step,
            value,
            disabled,
            trigger,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Slider.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Slider__d: Dict) ‑> <a title="h2o_q.types.Slider" href="#h2o_q.types.Slider">Slider</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Slider&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;Slider.name is required.&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    __d_min: Any = __d.get(&#39;min&#39;)
    __d_max: Any = __d.get(&#39;max&#39;)
    __d_step: Any = __d.get(&#39;step&#39;)
    __d_value: Any = __d.get(&#39;value&#39;)
    __d_disabled: Any = __d.get(&#39;disabled&#39;)
    __d_trigger: Any = __d.get(&#39;trigger&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    name: str = __d_name
    label: Optional[str] = __d_label
    min: Optional[float] = __d_min
    max: Optional[float] = __d_max
    step: Optional[float] = __d_step
    value: Optional[float] = __d_value
    disabled: Optional[bool] = __d_disabled
    trigger: Optional[bool] = __d_trigger
    tooltip: Optional[str] = __d_tooltip
    return Slider(
        name,
        label,
        min,
        max,
        step,
        value,
        disabled,
        trigger,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Slider.disabled"><code class="name">var <span class="ident">disabled</span></code></dt>
<dd>
<div class="desc"><p>True if this field is disabled.</p></div>
</dd>
<dt id="h2o_q.types.Slider.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>Text to be displayed alongside the component.</p></div>
</dd>
<dt id="h2o_q.types.Slider.max"><code class="name">var <span class="ident">max</span></code></dt>
<dd>
<div class="desc"><p>The maximum value of the slider.</p></div>
</dd>
<dt id="h2o_q.types.Slider.min"><code class="name">var <span class="ident">min</span></code></dt>
<dd>
<div class="desc"><p>The minimum value of the slider.</p></div>
</dd>
<dt id="h2o_q.types.Slider.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this component.</p></div>
</dd>
<dt id="h2o_q.types.Slider.step"><code class="name">var <span class="ident">step</span></code></dt>
<dd>
<div class="desc"><p>The difference between two adjacent values of the slider.</p></div>
</dd>
<dt id="h2o_q.types.Slider.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>An optional tooltip message displayed when a user clicks the help icon to the right of the component.</p></div>
</dd>
<dt id="h2o_q.types.Slider.trigger"><code class="name">var <span class="ident">trigger</span></code></dt>
<dd>
<div class="desc"><p>True if the form should be submitted when the slider value changes.</p></div>
</dd>
<dt id="h2o_q.types.Slider.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>The current value of the slider.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Slider.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;Slider.name is required.&#39;)
    return _dump(
        name=self.name,
        label=self.label,
        min=self.min,
        max=self.max,
        step=self.step,
        value=self.value,
        disabled=self.disabled,
        trigger=self.trigger,
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.SmallSeriesStatCard"><code class="flex name class">
<span>class <span class="ident">SmallSeriesStatCard</span></span>
<span>(</span><span>box: str, title: str, value: str, plot_data: Union[<a title="h2o_q.core.Data" href="core.html#h2o_q.core.Data">Data</a>, str], plot_value: str, plot_zero_value: Union[float, NoneType] = None, plot_category: Union[str, NoneType] = None, plot_type: Union[str, NoneType] = None, plot_curve: Union[str, NoneType] = None, plot_color: Union[str, NoneType] = None, data: Union[dict, str, NoneType] = None, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a small stat card displaying a primary value and a series plot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SmallSeriesStatCard:
    &#34;&#34;&#34;Create a small stat card displaying a primary value and a series plot.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            value: str,
            plot_data: PackedData,
            plot_value: str,
            plot_zero_value: Optional[float] = None,
            plot_category: Optional[str] = None,
            plot_type: Optional[str] = None,
            plot_curve: Optional[str] = None,
            plot_color: Optional[str] = None,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The card&#39;s title.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The primary value displayed.&#34;&#34;&#34;
        self.plot_data = plot_data
        &#34;&#34;&#34;The plot&#39;s data.&#34;&#34;&#34;
        self.plot_value = plot_value
        &#34;&#34;&#34;The data field to use for y-axis values.&#34;&#34;&#34;
        self.plot_zero_value = plot_zero_value
        &#34;&#34;&#34;The base value to use for each y-axis mark. Set this to `0` if you want to pin the x-axis at `y=0`. If not provided, the minimum value from the data is used.&#34;&#34;&#34;
        self.plot_category = plot_category
        &#34;&#34;&#34;The data field to use for x-axis values (ignored if `plot_type` is `area`; must be provided if `plot_type` is `interval`). Defaults to &#39;x&#39;.&#34;&#34;&#34;
        self.plot_type = plot_type
        &#34;&#34;&#34;The type of plot. Defaults to `area`. One of &#39;area&#39;, &#39;interval&#39;.&#34;&#34;&#34;
        self.plot_curve = plot_curve
        &#34;&#34;&#34;The plot&#39;s curve style. Defaults to `linear`. One of &#39;linear&#39;, &#39;smooth&#39;, &#39;step&#39;, &#39;step-after&#39;, &#39;step-before&#39;.&#34;&#34;&#34;
        self.plot_color = plot_color
        &#34;&#34;&#34;The plot&#39;s color.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;SmallSeriesStatCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;SmallSeriesStatCard.title is required.&#39;)
        if self.value is None:
            raise ValueError(&#39;SmallSeriesStatCard.value is required.&#39;)
        if self.plot_data is None:
            raise ValueError(&#39;SmallSeriesStatCard.plot_data is required.&#39;)
        if self.plot_value is None:
            raise ValueError(&#39;SmallSeriesStatCard.plot_value is required.&#39;)
        return _dump(
            view=&#39;small_series_stat&#39;,
            box=self.box,
            title=self.title,
            value=self.value,
            plot_data=self.plot_data,
            plot_value=self.plot_value,
            plot_zero_value=self.plot_zero_value,
            plot_category=self.plot_category,
            plot_type=self.plot_type,
            plot_curve=self.plot_curve,
            plot_color=self.plot_color,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;SmallSeriesStatCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;SmallSeriesStatCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;SmallSeriesStatCard.title is required.&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        if __d_value is None:
            raise ValueError(&#39;SmallSeriesStatCard.value is required.&#39;)
        __d_plot_data: Any = __d.get(&#39;plot_data&#39;)
        if __d_plot_data is None:
            raise ValueError(&#39;SmallSeriesStatCard.plot_data is required.&#39;)
        __d_plot_value: Any = __d.get(&#39;plot_value&#39;)
        if __d_plot_value is None:
            raise ValueError(&#39;SmallSeriesStatCard.plot_value is required.&#39;)
        __d_plot_zero_value: Any = __d.get(&#39;plot_zero_value&#39;)
        __d_plot_category: Any = __d.get(&#39;plot_category&#39;)
        __d_plot_type: Any = __d.get(&#39;plot_type&#39;)
        __d_plot_curve: Any = __d.get(&#39;plot_curve&#39;)
        __d_plot_color: Any = __d.get(&#39;plot_color&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        value: str = __d_value
        plot_data: PackedData = __d_plot_data
        plot_value: str = __d_plot_value
        plot_zero_value: Optional[float] = __d_plot_zero_value
        plot_category: Optional[str] = __d_plot_category
        plot_type: Optional[str] = __d_plot_type
        plot_curve: Optional[str] = __d_plot_curve
        plot_color: Optional[str] = __d_plot_color
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return SmallSeriesStatCard(
            box,
            title,
            value,
            plot_data,
            plot_value,
            plot_zero_value,
            plot_category,
            plot_type,
            plot_curve,
            plot_color,
            data,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.SmallSeriesStatCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_SmallSeriesStatCard__d: Dict) ‑> <a title="h2o_q.types.SmallSeriesStatCard" href="#h2o_q.types.SmallSeriesStatCard">SmallSeriesStatCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;SmallSeriesStatCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;SmallSeriesStatCard.box is required.&#39;)
    __d_title: Any = __d.get(&#39;title&#39;)
    if __d_title is None:
        raise ValueError(&#39;SmallSeriesStatCard.title is required.&#39;)
    __d_value: Any = __d.get(&#39;value&#39;)
    if __d_value is None:
        raise ValueError(&#39;SmallSeriesStatCard.value is required.&#39;)
    __d_plot_data: Any = __d.get(&#39;plot_data&#39;)
    if __d_plot_data is None:
        raise ValueError(&#39;SmallSeriesStatCard.plot_data is required.&#39;)
    __d_plot_value: Any = __d.get(&#39;plot_value&#39;)
    if __d_plot_value is None:
        raise ValueError(&#39;SmallSeriesStatCard.plot_value is required.&#39;)
    __d_plot_zero_value: Any = __d.get(&#39;plot_zero_value&#39;)
    __d_plot_category: Any = __d.get(&#39;plot_category&#39;)
    __d_plot_type: Any = __d.get(&#39;plot_type&#39;)
    __d_plot_curve: Any = __d.get(&#39;plot_curve&#39;)
    __d_plot_color: Any = __d.get(&#39;plot_color&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    title: str = __d_title
    value: str = __d_value
    plot_data: PackedData = __d_plot_data
    plot_value: str = __d_plot_value
    plot_zero_value: Optional[float] = __d_plot_zero_value
    plot_category: Optional[str] = __d_plot_category
    plot_type: Optional[str] = __d_plot_type
    plot_curve: Optional[str] = __d_plot_curve
    plot_color: Optional[str] = __d_plot_color
    data: Optional[PackedRecord] = __d_data
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return SmallSeriesStatCard(
        box,
        title,
        value,
        plot_data,
        plot_value,
        plot_zero_value,
        plot_category,
        plot_type,
        plot_curve,
        plot_color,
        data,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.SmallSeriesStatCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.SmallSeriesStatCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.SmallSeriesStatCard.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Data for this card.</p></div>
</dd>
<dt id="h2o_q.types.SmallSeriesStatCard.plot_category"><code class="name">var <span class="ident">plot_category</span></code></dt>
<dd>
<div class="desc"><p>The data field to use for x-axis values (ignored if <code>plot_type</code> is <code>area</code>; must be provided if <code>plot_type</code> is <code>interval</code>). Defaults to 'x'.</p></div>
</dd>
<dt id="h2o_q.types.SmallSeriesStatCard.plot_color"><code class="name">var <span class="ident">plot_color</span></code></dt>
<dd>
<div class="desc"><p>The plot's color.</p></div>
</dd>
<dt id="h2o_q.types.SmallSeriesStatCard.plot_curve"><code class="name">var <span class="ident">plot_curve</span></code></dt>
<dd>
<div class="desc"><p>The plot's curve style. Defaults to <code>linear</code>. One of 'linear', 'smooth', 'step', 'step-after', 'step-before'.</p></div>
</dd>
<dt id="h2o_q.types.SmallSeriesStatCard.plot_data"><code class="name">var <span class="ident">plot_data</span></code></dt>
<dd>
<div class="desc"><p>The plot's data.</p></div>
</dd>
<dt id="h2o_q.types.SmallSeriesStatCard.plot_type"><code class="name">var <span class="ident">plot_type</span></code></dt>
<dd>
<div class="desc"><p>The type of plot. Defaults to <code>area</code>. One of 'area', 'interval'.</p></div>
</dd>
<dt id="h2o_q.types.SmallSeriesStatCard.plot_value"><code class="name">var <span class="ident">plot_value</span></code></dt>
<dd>
<div class="desc"><p>The data field to use for y-axis values.</p></div>
</dd>
<dt id="h2o_q.types.SmallSeriesStatCard.plot_zero_value"><code class="name">var <span class="ident">plot_zero_value</span></code></dt>
<dd>
<div class="desc"><p>The base value to use for each y-axis mark. Set this to <code>0</code> if you want to pin the x-axis at <code>y=0</code>. If not provided, the minimum value from the data is used.</p></div>
</dd>
<dt id="h2o_q.types.SmallSeriesStatCard.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>The card's title.</p></div>
</dd>
<dt id="h2o_q.types.SmallSeriesStatCard.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>The primary value displayed.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.SmallSeriesStatCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;SmallSeriesStatCard.box is required.&#39;)
    if self.title is None:
        raise ValueError(&#39;SmallSeriesStatCard.title is required.&#39;)
    if self.value is None:
        raise ValueError(&#39;SmallSeriesStatCard.value is required.&#39;)
    if self.plot_data is None:
        raise ValueError(&#39;SmallSeriesStatCard.plot_data is required.&#39;)
    if self.plot_value is None:
        raise ValueError(&#39;SmallSeriesStatCard.plot_value is required.&#39;)
    return _dump(
        view=&#39;small_series_stat&#39;,
        box=self.box,
        title=self.title,
        value=self.value,
        plot_data=self.plot_data,
        plot_value=self.plot_value,
        plot_zero_value=self.plot_zero_value,
        plot_category=self.plot_category,
        plot_type=self.plot_type,
        plot_curve=self.plot_curve,
        plot_color=self.plot_color,
        data=self.data,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.SmallStatCard"><code class="flex name class">
<span>class <span class="ident">SmallStatCard</span></span>
<span>(</span><span>box: str, title: str, value: str, data: Union[dict, str, NoneType] = None, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a stat card displaying a single value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SmallStatCard:
    &#34;&#34;&#34;Create a stat card displaying a single value.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            value: str,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The card&#39;s title.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The primary value displayed.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;SmallStatCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;SmallStatCard.title is required.&#39;)
        if self.value is None:
            raise ValueError(&#39;SmallStatCard.value is required.&#39;)
        return _dump(
            view=&#39;small_stat&#39;,
            box=self.box,
            title=self.title,
            value=self.value,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;SmallStatCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;SmallStatCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;SmallStatCard.title is required.&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        if __d_value is None:
            raise ValueError(&#39;SmallStatCard.value is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        value: str = __d_value
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return SmallStatCard(
            box,
            title,
            value,
            data,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.SmallStatCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_SmallStatCard__d: Dict) ‑> <a title="h2o_q.types.SmallStatCard" href="#h2o_q.types.SmallStatCard">SmallStatCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;SmallStatCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;SmallStatCard.box is required.&#39;)
    __d_title: Any = __d.get(&#39;title&#39;)
    if __d_title is None:
        raise ValueError(&#39;SmallStatCard.title is required.&#39;)
    __d_value: Any = __d.get(&#39;value&#39;)
    if __d_value is None:
        raise ValueError(&#39;SmallStatCard.value is required.&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    title: str = __d_title
    value: str = __d_value
    data: Optional[PackedRecord] = __d_data
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return SmallStatCard(
        box,
        title,
        value,
        data,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.SmallStatCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.SmallStatCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.SmallStatCard.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Data for this card.</p></div>
</dd>
<dt id="h2o_q.types.SmallStatCard.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>The card's title.</p></div>
</dd>
<dt id="h2o_q.types.SmallStatCard.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>The primary value displayed.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.SmallStatCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;SmallStatCard.box is required.&#39;)
    if self.title is None:
        raise ValueError(&#39;SmallStatCard.title is required.&#39;)
    if self.value is None:
        raise ValueError(&#39;SmallStatCard.value is required.&#39;)
    return _dump(
        view=&#39;small_stat&#39;,
        box=self.box,
        title=self.title,
        value=self.value,
        data=self.data,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Spinbox"><code class="flex name class">
<span>class <span class="ident">Spinbox</span></span>
<span>(</span><span>name: str, label: Union[str, NoneType] = None, min: Union[float, NoneType] = None, max: Union[float, NoneType] = None, step: Union[float, NoneType] = None, value: Union[float, NoneType] = None, disabled: Union[bool, NoneType] = None, tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a spinbox.</p>
<p>A spinbox allows the user to incrementally adjust a value in small steps.
It is mainly used for numeric values, but other values are supported too.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Spinbox:
    &#34;&#34;&#34;Create a spinbox.

    A spinbox allows the user to incrementally adjust a value in small steps.
    It is mainly used for numeric values, but other values are supported too.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            min: Optional[float] = None,
            max: Optional[float] = None,
            step: Optional[float] = None,
            value: Optional[float] = None,
            disabled: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the component.&#34;&#34;&#34;
        self.min = min
        &#34;&#34;&#34;The minimum value of the spinbox.&#34;&#34;&#34;
        self.max = max
        &#34;&#34;&#34;The maximum value of the spinbox.&#34;&#34;&#34;
        self.step = step
        &#34;&#34;&#34;The difference between two adjacent values of the spinbox.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The current value of the spinbox.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if this field is disabled.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Spinbox.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            min=self.min,
            max=self.max,
            step=self.step,
            value=self.value,
            disabled=self.disabled,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Spinbox&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Spinbox.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_min: Any = __d.get(&#39;min&#39;)
        __d_max: Any = __d.get(&#39;max&#39;)
        __d_step: Any = __d.get(&#39;step&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        min: Optional[float] = __d_min
        max: Optional[float] = __d_max
        step: Optional[float] = __d_step
        value: Optional[float] = __d_value
        disabled: Optional[bool] = __d_disabled
        tooltip: Optional[str] = __d_tooltip
        return Spinbox(
            name,
            label,
            min,
            max,
            step,
            value,
            disabled,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Spinbox.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Spinbox__d: Dict) ‑> <a title="h2o_q.types.Spinbox" href="#h2o_q.types.Spinbox">Spinbox</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Spinbox&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;Spinbox.name is required.&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    __d_min: Any = __d.get(&#39;min&#39;)
    __d_max: Any = __d.get(&#39;max&#39;)
    __d_step: Any = __d.get(&#39;step&#39;)
    __d_value: Any = __d.get(&#39;value&#39;)
    __d_disabled: Any = __d.get(&#39;disabled&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    name: str = __d_name
    label: Optional[str] = __d_label
    min: Optional[float] = __d_min
    max: Optional[float] = __d_max
    step: Optional[float] = __d_step
    value: Optional[float] = __d_value
    disabled: Optional[bool] = __d_disabled
    tooltip: Optional[str] = __d_tooltip
    return Spinbox(
        name,
        label,
        min,
        max,
        step,
        value,
        disabled,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Spinbox.disabled"><code class="name">var <span class="ident">disabled</span></code></dt>
<dd>
<div class="desc"><p>True if this field is disabled.</p></div>
</dd>
<dt id="h2o_q.types.Spinbox.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>Text to be displayed alongside the component.</p></div>
</dd>
<dt id="h2o_q.types.Spinbox.max"><code class="name">var <span class="ident">max</span></code></dt>
<dd>
<div class="desc"><p>The maximum value of the spinbox.</p></div>
</dd>
<dt id="h2o_q.types.Spinbox.min"><code class="name">var <span class="ident">min</span></code></dt>
<dd>
<div class="desc"><p>The minimum value of the spinbox.</p></div>
</dd>
<dt id="h2o_q.types.Spinbox.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this component.</p></div>
</dd>
<dt id="h2o_q.types.Spinbox.step"><code class="name">var <span class="ident">step</span></code></dt>
<dd>
<div class="desc"><p>The difference between two adjacent values of the spinbox.</p></div>
</dd>
<dt id="h2o_q.types.Spinbox.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>An optional tooltip message displayed when a user clicks the help icon to the right of the component.</p></div>
</dd>
<dt id="h2o_q.types.Spinbox.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>The current value of the spinbox.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Spinbox.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;Spinbox.name is required.&#39;)
    return _dump(
        name=self.name,
        label=self.label,
        min=self.min,
        max=self.max,
        step=self.step,
        value=self.value,
        disabled=self.disabled,
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Step"><code class="flex name class">
<span>class <span class="ident">Step</span></span>
<span>(</span><span>label: str, icon: Union[str, NoneType] = None, done: Union[bool, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a step for a stepper.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Step:
    &#34;&#34;&#34;Create a step for a stepper.
    &#34;&#34;&#34;
    def __init__(
            self,
            label: str,
            icon: Optional[str] = None,
            done: Optional[bool] = None,
    ):
        self.label = label
        &#34;&#34;&#34;Text displayed below icon.&#34;&#34;&#34;
        self.icon = icon
        &#34;&#34;&#34;Icon to be displayed.&#34;&#34;&#34;
        self.done = done
        &#34;&#34;&#34;Indicates whether this step has already been completed.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.label is None:
            raise ValueError(&#39;Step.label is required.&#39;)
        return _dump(
            label=self.label,
            icon=self.icon,
            done=self.done,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Step&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_label: Any = __d.get(&#39;label&#39;)
        if __d_label is None:
            raise ValueError(&#39;Step.label is required.&#39;)
        __d_icon: Any = __d.get(&#39;icon&#39;)
        __d_done: Any = __d.get(&#39;done&#39;)
        label: str = __d_label
        icon: Optional[str] = __d_icon
        done: Optional[bool] = __d_done
        return Step(
            label,
            icon,
            done,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Step.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Step__d: Dict) ‑> <a title="h2o_q.types.Step" href="#h2o_q.types.Step">Step</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Step&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_label: Any = __d.get(&#39;label&#39;)
    if __d_label is None:
        raise ValueError(&#39;Step.label is required.&#39;)
    __d_icon: Any = __d.get(&#39;icon&#39;)
    __d_done: Any = __d.get(&#39;done&#39;)
    label: str = __d_label
    icon: Optional[str] = __d_icon
    done: Optional[bool] = __d_done
    return Step(
        label,
        icon,
        done,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Step.done"><code class="name">var <span class="ident">done</span></code></dt>
<dd>
<div class="desc"><p>Indicates whether this step has already been completed.</p></div>
</dd>
<dt id="h2o_q.types.Step.icon"><code class="name">var <span class="ident">icon</span></code></dt>
<dd>
<div class="desc"><p>Icon to be displayed.</p></div>
</dd>
<dt id="h2o_q.types.Step.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>Text displayed below icon.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Step.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.label is None:
        raise ValueError(&#39;Step.label is required.&#39;)
    return _dump(
        label=self.label,
        icon=self.icon,
        done=self.done,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Stepper"><code class="flex name class">
<span>class <span class="ident">Stepper</span></span>
<span>(</span><span>name: str, items: List[<a title="h2o_q.types.Step" href="#h2o_q.types.Step">Step</a>], tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a component that displays a sequence of steps in a process.
The steps keep users informed about where they are in the process and how much is left to complete.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Stepper:
    &#34;&#34;&#34;Create a component that displays a sequence of steps in a process.
    The steps keep users informed about where they are in the process and how much is left to complete.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            items: List[Step],
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.items = items
        &#34;&#34;&#34;The sequence of steps to be displayed.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Stepper.name is required.&#39;)
        if self.items is None:
            raise ValueError(&#39;Stepper.items is required.&#39;)
        return _dump(
            name=self.name,
            items=[__e.dump() for __e in self.items],
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Stepper&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Stepper.name is required.&#39;)
        __d_items: Any = __d.get(&#39;items&#39;)
        if __d_items is None:
            raise ValueError(&#39;Stepper.items is required.&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        items: List[Step] = [Step.load(__e) for __e in __d_items]
        tooltip: Optional[str] = __d_tooltip
        return Stepper(
            name,
            items,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Stepper.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Stepper__d: Dict) ‑> <a title="h2o_q.types.Stepper" href="#h2o_q.types.Stepper">Stepper</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Stepper&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;Stepper.name is required.&#39;)
    __d_items: Any = __d.get(&#39;items&#39;)
    if __d_items is None:
        raise ValueError(&#39;Stepper.items is required.&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    name: str = __d_name
    items: List[Step] = [Step.load(__e) for __e in __d_items]
    tooltip: Optional[str] = __d_tooltip
    return Stepper(
        name,
        items,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Stepper.items"><code class="name">var <span class="ident">items</span></code></dt>
<dd>
<div class="desc"><p>The sequence of steps to be displayed.</p></div>
</dd>
<dt id="h2o_q.types.Stepper.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this component.</p></div>
</dd>
<dt id="h2o_q.types.Stepper.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>An optional tooltip message displayed when a user clicks the help icon to the right of the component.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Stepper.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;Stepper.name is required.&#39;)
    if self.items is None:
        raise ValueError(&#39;Stepper.items is required.&#39;)
    return _dump(
        name=self.name,
        items=[__e.dump() for __e in self.items],
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Tab"><code class="flex name class">
<span>class <span class="ident">Tab</span></span>
<span>(</span><span>name: str, label: Union[str, NoneType] = None, icon: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a tab.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tab:
    &#34;&#34;&#34;Create a tab.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            icon: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;The text displayed on the tab.&#34;&#34;&#34;
        self.icon = icon
        &#34;&#34;&#34;The icon displayed on the tab.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Tab.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            icon=self.icon,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Tab&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Tab.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_icon: Any = __d.get(&#39;icon&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        icon: Optional[str] = __d_icon
        return Tab(
            name,
            label,
            icon,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Tab.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Tab__d: Dict) ‑> <a title="h2o_q.types.Tab" href="#h2o_q.types.Tab">Tab</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Tab&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;Tab.name is required.&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    __d_icon: Any = __d.get(&#39;icon&#39;)
    name: str = __d_name
    label: Optional[str] = __d_label
    icon: Optional[str] = __d_icon
    return Tab(
        name,
        label,
        icon,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Tab.icon"><code class="name">var <span class="ident">icon</span></code></dt>
<dd>
<div class="desc"><p>The icon displayed on the tab.</p></div>
</dd>
<dt id="h2o_q.types.Tab.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>The text displayed on the tab.</p></div>
</dd>
<dt id="h2o_q.types.Tab.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this component.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Tab.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;Tab.name is required.&#39;)
    return _dump(
        name=self.name,
        label=self.label,
        icon=self.icon,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.TabCard"><code class="flex name class">
<span>class <span class="ident">TabCard</span></span>
<span>(</span><span>box: str, items: List[<a title="h2o_q.types.Tab" href="#h2o_q.types.Tab">Tab</a>], link: Union[bool, NoneType] = None, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a card containing tabs for navigation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TabCard:
    &#34;&#34;&#34;Create a card containing tabs for navigation.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            items: List[Tab],
            link: Optional[bool] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.items = items
        &#34;&#34;&#34;Items to render.&#34;&#34;&#34;
        self.link = link
        &#34;&#34;&#34;True if tabs should be rendered as links and not a standard tab.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;TabCard.box is required.&#39;)
        if self.items is None:
            raise ValueError(&#39;TabCard.items is required.&#39;)
        return _dump(
            view=&#39;tab&#39;,
            box=self.box,
            items=[__e.dump() for __e in self.items],
            link=self.link,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TabCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;TabCard.box is required.&#39;)
        __d_items: Any = __d.get(&#39;items&#39;)
        if __d_items is None:
            raise ValueError(&#39;TabCard.items is required.&#39;)
        __d_link: Any = __d.get(&#39;link&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        items: List[Tab] = [Tab.load(__e) for __e in __d_items]
        link: Optional[bool] = __d_link
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return TabCard(
            box,
            items,
            link,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.TabCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_TabCard__d: Dict) ‑> <a title="h2o_q.types.TabCard" href="#h2o_q.types.TabCard">TabCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;TabCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;TabCard.box is required.&#39;)
    __d_items: Any = __d.get(&#39;items&#39;)
    if __d_items is None:
        raise ValueError(&#39;TabCard.items is required.&#39;)
    __d_link: Any = __d.get(&#39;link&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    items: List[Tab] = [Tab.load(__e) for __e in __d_items]
    link: Optional[bool] = __d_link
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return TabCard(
        box,
        items,
        link,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.TabCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.TabCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.TabCard.items"><code class="name">var <span class="ident">items</span></code></dt>
<dd>
<div class="desc"><p>Items to render.</p></div>
</dd>
<dt id="h2o_q.types.TabCard.link"><code class="name">var <span class="ident">link</span></code></dt>
<dd>
<div class="desc"><p>True if tabs should be rendered as links and not a standard tab.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.TabCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;TabCard.box is required.&#39;)
    if self.items is None:
        raise ValueError(&#39;TabCard.items is required.&#39;)
    return _dump(
        view=&#39;tab&#39;,
        box=self.box,
        items=[__e.dump() for __e in self.items],
        link=self.link,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Table"><code class="flex name class">
<span>class <span class="ident">Table</span></span>
<span>(</span><span>name: str, columns: List[<a title="h2o_q.types.TableColumn" href="#h2o_q.types.TableColumn">TableColumn</a>], rows: List[<a title="h2o_q.types.TableRow" href="#h2o_q.types.TableRow">TableRow</a>], multiple: Union[bool, NoneType] = None, groupable: Union[bool, NoneType] = None, downloadable: Union[bool, NoneType] = None, resettable: Union[bool, NoneType] = None, height: Union[str, NoneType] = None, tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an interactive table.</p>
<p>This table differs from a markdown table in that it supports clicking or selecting rows. If you simply want to
display a non-interactive table of information, use a markdown table.</p>
<p>If <code>multiple</code> is set to False (default), each row in the table is clickable. When a row is clicked, the form is
submitted automatically, and <code>q.args.table_name</code> is set to <code>[row_name]</code>, where <code>table_name</code> is the <code>name</code> of
the table, and <code>row_name</code> is the <code>name</code> of the row that was clicked on.</p>
<p>If <code>multiple</code> is set to True, each row in the table is selectable. A row can be selected by clicking on it.
Multiple rows can be selected either by shift+clicking or using marquee selection. When the form is submitted,
<code>q.args.table_name</code> is set to <code>[row1_name, row2_name, &hellip;]</code> where <code>table_name</code> is the <code>name</code> of the table,
and <code>row1_name</code>, <code>row2_name</code> are the <code>name</code> of the rows that were selected. Note that if <code>multiple</code> is
set to True, the form is not submitted automatically, and one or more buttons are required in the form to trigger
submission.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Table:
    &#34;&#34;&#34;Create an interactive table.

    This table differs from a markdown table in that it supports clicking or selecting rows. If you simply want to
    display a non-interactive table of information, use a markdown table.

    If `multiple` is set to False (default), each row in the table is clickable. When a row is clicked, the form is
    submitted automatically, and `q.args.table_name` is set to `[row_name]`, where `table_name` is the `name` of
    the table, and `row_name` is the `name` of the row that was clicked on.

    If `multiple` is set to True, each row in the table is selectable. A row can be selected by clicking on it.
    Multiple rows can be selected either by shift+clicking or using marquee selection. When the form is submitted,
    `q.args.table_name` is set to `[row1_name, row2_name, ...]` where `table_name` is the `name` of the table,
    and `row1_name`, `row2_name` are the `name` of the rows that were selected. Note that if `multiple` is
    set to True, the form is not submitted automatically, and one or more buttons are required in the form to trigger
    submission.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            columns: List[TableColumn],
            rows: List[TableRow],
            multiple: Optional[bool] = None,
            groupable: Optional[bool] = None,
            downloadable: Optional[bool] = None,
            resettable: Optional[bool] = None,
            height: Optional[str] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.columns = columns
        &#34;&#34;&#34;The columns in this table.&#34;&#34;&#34;
        self.rows = rows
        &#34;&#34;&#34;The rows in this table.&#34;&#34;&#34;
        self.multiple = multiple
        &#34;&#34;&#34;True to allow multiple rows to be selected.&#34;&#34;&#34;
        self.groupable = groupable
        &#34;&#34;&#34;True to allow group by feature.&#34;&#34;&#34;
        self.downloadable = downloadable
        &#34;&#34;&#34;Indicates whether the contents of this table can be downloaded and saved as a CSV file. Defaults to False.&#34;&#34;&#34;
        self.resettable = resettable
        &#34;&#34;&#34;Indicates whether a Reset button should be displayed to reset search / filter / group-by values to their defaults. Defaults to False.&#34;&#34;&#34;
        self.height = height
        &#34;&#34;&#34;The height of the table, e.g. &#39;400px&#39;, &#39;50%&#39;, etc.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Table.name is required.&#39;)
        if self.columns is None:
            raise ValueError(&#39;Table.columns is required.&#39;)
        if self.rows is None:
            raise ValueError(&#39;Table.rows is required.&#39;)
        return _dump(
            name=self.name,
            columns=[__e.dump() for __e in self.columns],
            rows=[__e.dump() for __e in self.rows],
            multiple=self.multiple,
            groupable=self.groupable,
            downloadable=self.downloadable,
            resettable=self.resettable,
            height=self.height,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Table&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Table.name is required.&#39;)
        __d_columns: Any = __d.get(&#39;columns&#39;)
        if __d_columns is None:
            raise ValueError(&#39;Table.columns is required.&#39;)
        __d_rows: Any = __d.get(&#39;rows&#39;)
        if __d_rows is None:
            raise ValueError(&#39;Table.rows is required.&#39;)
        __d_multiple: Any = __d.get(&#39;multiple&#39;)
        __d_groupable: Any = __d.get(&#39;groupable&#39;)
        __d_downloadable: Any = __d.get(&#39;downloadable&#39;)
        __d_resettable: Any = __d.get(&#39;resettable&#39;)
        __d_height: Any = __d.get(&#39;height&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        columns: List[TableColumn] = [TableColumn.load(__e) for __e in __d_columns]
        rows: List[TableRow] = [TableRow.load(__e) for __e in __d_rows]
        multiple: Optional[bool] = __d_multiple
        groupable: Optional[bool] = __d_groupable
        downloadable: Optional[bool] = __d_downloadable
        resettable: Optional[bool] = __d_resettable
        height: Optional[str] = __d_height
        tooltip: Optional[str] = __d_tooltip
        return Table(
            name,
            columns,
            rows,
            multiple,
            groupable,
            downloadable,
            resettable,
            height,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Table.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Table__d: Dict) ‑> <a title="h2o_q.types.Table" href="#h2o_q.types.Table">Table</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Table&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;Table.name is required.&#39;)
    __d_columns: Any = __d.get(&#39;columns&#39;)
    if __d_columns is None:
        raise ValueError(&#39;Table.columns is required.&#39;)
    __d_rows: Any = __d.get(&#39;rows&#39;)
    if __d_rows is None:
        raise ValueError(&#39;Table.rows is required.&#39;)
    __d_multiple: Any = __d.get(&#39;multiple&#39;)
    __d_groupable: Any = __d.get(&#39;groupable&#39;)
    __d_downloadable: Any = __d.get(&#39;downloadable&#39;)
    __d_resettable: Any = __d.get(&#39;resettable&#39;)
    __d_height: Any = __d.get(&#39;height&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    name: str = __d_name
    columns: List[TableColumn] = [TableColumn.load(__e) for __e in __d_columns]
    rows: List[TableRow] = [TableRow.load(__e) for __e in __d_rows]
    multiple: Optional[bool] = __d_multiple
    groupable: Optional[bool] = __d_groupable
    downloadable: Optional[bool] = __d_downloadable
    resettable: Optional[bool] = __d_resettable
    height: Optional[str] = __d_height
    tooltip: Optional[str] = __d_tooltip
    return Table(
        name,
        columns,
        rows,
        multiple,
        groupable,
        downloadable,
        resettable,
        height,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Table.columns"><code class="name">var <span class="ident">columns</span></code></dt>
<dd>
<div class="desc"><p>The columns in this table.</p></div>
</dd>
<dt id="h2o_q.types.Table.downloadable"><code class="name">var <span class="ident">downloadable</span></code></dt>
<dd>
<div class="desc"><p>Indicates whether the contents of this table can be downloaded and saved as a CSV file. Defaults to False.</p></div>
</dd>
<dt id="h2o_q.types.Table.groupable"><code class="name">var <span class="ident">groupable</span></code></dt>
<dd>
<div class="desc"><p>True to allow group by feature.</p></div>
</dd>
<dt id="h2o_q.types.Table.height"><code class="name">var <span class="ident">height</span></code></dt>
<dd>
<div class="desc"><p>The height of the table, e.g. '400px', '50%', etc.</p></div>
</dd>
<dt id="h2o_q.types.Table.multiple"><code class="name">var <span class="ident">multiple</span></code></dt>
<dd>
<div class="desc"><p>True to allow multiple rows to be selected.</p></div>
</dd>
<dt id="h2o_q.types.Table.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this component.</p></div>
</dd>
<dt id="h2o_q.types.Table.resettable"><code class="name">var <span class="ident">resettable</span></code></dt>
<dd>
<div class="desc"><p>Indicates whether a Reset button should be displayed to reset search / filter / group-by values to their defaults. Defaults to False.</p></div>
</dd>
<dt id="h2o_q.types.Table.rows"><code class="name">var <span class="ident">rows</span></code></dt>
<dd>
<div class="desc"><p>The rows in this table.</p></div>
</dd>
<dt id="h2o_q.types.Table.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>An optional tooltip message displayed when a user clicks the help icon to the right of the component.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Table.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;Table.name is required.&#39;)
    if self.columns is None:
        raise ValueError(&#39;Table.columns is required.&#39;)
    if self.rows is None:
        raise ValueError(&#39;Table.rows is required.&#39;)
    return _dump(
        name=self.name,
        columns=[__e.dump() for __e in self.columns],
        rows=[__e.dump() for __e in self.rows],
        multiple=self.multiple,
        groupable=self.groupable,
        downloadable=self.downloadable,
        resettable=self.resettable,
        height=self.height,
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.TableCellType"><code class="flex name class">
<span>class <span class="ident">TableCellType</span></span>
<span>(</span><span>progress: Union[<a title="h2o_q.types.ProgressTableCellType" href="#h2o_q.types.ProgressTableCellType">ProgressTableCellType</a>, NoneType] = None, icon: Union[<a title="h2o_q.types.IconTableCellType" href="#h2o_q.types.IconTableCellType">IconTableCellType</a>, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines cell content to be rendered instead of a simple text.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TableCellType:
    &#34;&#34;&#34;Defines cell content to be rendered instead of a simple text.
    &#34;&#34;&#34;
    def __init__(
            self,
            progress: Optional[ProgressTableCellType] = None,
            icon: Optional[IconTableCellType] = None,
    ):
        self.progress = progress
        &#34;&#34;&#34;No documentation available.&#34;&#34;&#34;
        self.icon = icon
        &#34;&#34;&#34;No documentation available.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        return _dump(
            progress=None if self.progress is None else self.progress.dump(),
            icon=None if self.icon is None else self.icon.dump(),
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TableCellType&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_progress: Any = __d.get(&#39;progress&#39;)
        __d_icon: Any = __d.get(&#39;icon&#39;)
        progress: Optional[ProgressTableCellType] = None if __d_progress is None else ProgressTableCellType.load(__d_progress)
        icon: Optional[IconTableCellType] = None if __d_icon is None else IconTableCellType.load(__d_icon)
        return TableCellType(
            progress,
            icon,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.TableCellType.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_TableCellType__d: Dict) ‑> <a title="h2o_q.types.TableCellType" href="#h2o_q.types.TableCellType">TableCellType</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;TableCellType&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_progress: Any = __d.get(&#39;progress&#39;)
    __d_icon: Any = __d.get(&#39;icon&#39;)
    progress: Optional[ProgressTableCellType] = None if __d_progress is None else ProgressTableCellType.load(__d_progress)
    icon: Optional[IconTableCellType] = None if __d_icon is None else IconTableCellType.load(__d_icon)
    return TableCellType(
        progress,
        icon,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.TableCellType.icon"><code class="name">var <span class="ident">icon</span></code></dt>
<dd>
<div class="desc"><p>No documentation available.</p></div>
</dd>
<dt id="h2o_q.types.TableCellType.progress"><code class="name">var <span class="ident">progress</span></code></dt>
<dd>
<div class="desc"><p>No documentation available.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.TableCellType.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    return _dump(
        progress=None if self.progress is None else self.progress.dump(),
        icon=None if self.icon is None else self.icon.dump(),
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.TableColumn"><code class="flex name class">
<span>class <span class="ident">TableColumn</span></span>
<span>(</span><span>name: str, label: str, min_width: Union[str, NoneType] = None, max_width: Union[str, NoneType] = None, sortable: Union[bool, NoneType] = None, searchable: Union[bool, NoneType] = None, filterable: Union[bool, NoneType] = None, link: Union[bool, NoneType] = None, cell_type: Union[<a title="h2o_q.types.TableCellType" href="#h2o_q.types.TableCellType">TableCellType</a>, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a table column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TableColumn:
    &#34;&#34;&#34;Create a table column.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: str,
            min_width: Optional[str] = None,
            max_width: Optional[str] = None,
            sortable: Optional[bool] = None,
            searchable: Optional[bool] = None,
            filterable: Optional[bool] = None,
            link: Optional[bool] = None,
            cell_type: Optional[TableCellType] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this column.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;The text displayed on the column header.&#34;&#34;&#34;
        self.min_width = min_width
        &#34;&#34;&#34;The minimum width of this column, e.g. &#39;50px&#39;. Only `px` units are supported at this time.&#34;&#34;&#34;
        self.max_width = max_width
        &#34;&#34;&#34;The maximum width of this column, e.g. &#39;100px&#39;. Only `px` units are supported at this time.&#34;&#34;&#34;
        self.sortable = sortable
        &#34;&#34;&#34;Indicates whether the column is sortable.&#34;&#34;&#34;
        self.searchable = searchable
        &#34;&#34;&#34;Indicates whether the contents of this column can be searched through. Enables a search box for the table if true.&#34;&#34;&#34;
        self.filterable = filterable
        &#34;&#34;&#34;Indicates whether the contents of this column are displayed as filters in a dropdown.&#34;&#34;&#34;
        self.link = link
        &#34;&#34;&#34;Indicates whether each cell in this column should be displayed as a clickable link.&#34;&#34;&#34;
        self.cell_type = cell_type
        &#34;&#34;&#34;Defines how to render each cell in this column. Defaults to plain text.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;TableColumn.name is required.&#39;)
        if self.label is None:
            raise ValueError(&#39;TableColumn.label is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            min_width=self.min_width,
            max_width=self.max_width,
            sortable=self.sortable,
            searchable=self.searchable,
            filterable=self.filterable,
            link=self.link,
            cell_type=None if self.cell_type is None else self.cell_type.dump(),
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TableColumn&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;TableColumn.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        if __d_label is None:
            raise ValueError(&#39;TableColumn.label is required.&#39;)
        __d_min_width: Any = __d.get(&#39;min_width&#39;)
        __d_max_width: Any = __d.get(&#39;max_width&#39;)
        __d_sortable: Any = __d.get(&#39;sortable&#39;)
        __d_searchable: Any = __d.get(&#39;searchable&#39;)
        __d_filterable: Any = __d.get(&#39;filterable&#39;)
        __d_link: Any = __d.get(&#39;link&#39;)
        __d_cell_type: Any = __d.get(&#39;cell_type&#39;)
        name: str = __d_name
        label: str = __d_label
        min_width: Optional[str] = __d_min_width
        max_width: Optional[str] = __d_max_width
        sortable: Optional[bool] = __d_sortable
        searchable: Optional[bool] = __d_searchable
        filterable: Optional[bool] = __d_filterable
        link: Optional[bool] = __d_link
        cell_type: Optional[TableCellType] = None if __d_cell_type is None else TableCellType.load(__d_cell_type)
        return TableColumn(
            name,
            label,
            min_width,
            max_width,
            sortable,
            searchable,
            filterable,
            link,
            cell_type,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.TableColumn.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_TableColumn__d: Dict) ‑> <a title="h2o_q.types.TableColumn" href="#h2o_q.types.TableColumn">TableColumn</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;TableColumn&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;TableColumn.name is required.&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    if __d_label is None:
        raise ValueError(&#39;TableColumn.label is required.&#39;)
    __d_min_width: Any = __d.get(&#39;min_width&#39;)
    __d_max_width: Any = __d.get(&#39;max_width&#39;)
    __d_sortable: Any = __d.get(&#39;sortable&#39;)
    __d_searchable: Any = __d.get(&#39;searchable&#39;)
    __d_filterable: Any = __d.get(&#39;filterable&#39;)
    __d_link: Any = __d.get(&#39;link&#39;)
    __d_cell_type: Any = __d.get(&#39;cell_type&#39;)
    name: str = __d_name
    label: str = __d_label
    min_width: Optional[str] = __d_min_width
    max_width: Optional[str] = __d_max_width
    sortable: Optional[bool] = __d_sortable
    searchable: Optional[bool] = __d_searchable
    filterable: Optional[bool] = __d_filterable
    link: Optional[bool] = __d_link
    cell_type: Optional[TableCellType] = None if __d_cell_type is None else TableCellType.load(__d_cell_type)
    return TableColumn(
        name,
        label,
        min_width,
        max_width,
        sortable,
        searchable,
        filterable,
        link,
        cell_type,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.TableColumn.cell_type"><code class="name">var <span class="ident">cell_type</span></code></dt>
<dd>
<div class="desc"><p>Defines how to render each cell in this column. Defaults to plain text.</p></div>
</dd>
<dt id="h2o_q.types.TableColumn.filterable"><code class="name">var <span class="ident">filterable</span></code></dt>
<dd>
<div class="desc"><p>Indicates whether the contents of this column are displayed as filters in a dropdown.</p></div>
</dd>
<dt id="h2o_q.types.TableColumn.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>The text displayed on the column header.</p></div>
</dd>
<dt id="h2o_q.types.TableColumn.link"><code class="name">var <span class="ident">link</span></code></dt>
<dd>
<div class="desc"><p>Indicates whether each cell in this column should be displayed as a clickable link.</p></div>
</dd>
<dt id="h2o_q.types.TableColumn.max_width"><code class="name">var <span class="ident">max_width</span></code></dt>
<dd>
<div class="desc"><p>The maximum width of this column, e.g. '100px'. Only <code>px</code> units are supported at this time.</p></div>
</dd>
<dt id="h2o_q.types.TableColumn.min_width"><code class="name">var <span class="ident">min_width</span></code></dt>
<dd>
<div class="desc"><p>The minimum width of this column, e.g. '50px'. Only <code>px</code> units are supported at this time.</p></div>
</dd>
<dt id="h2o_q.types.TableColumn.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this column.</p></div>
</dd>
<dt id="h2o_q.types.TableColumn.searchable"><code class="name">var <span class="ident">searchable</span></code></dt>
<dd>
<div class="desc"><p>Indicates whether the contents of this column can be searched through. Enables a search box for the table if true.</p></div>
</dd>
<dt id="h2o_q.types.TableColumn.sortable"><code class="name">var <span class="ident">sortable</span></code></dt>
<dd>
<div class="desc"><p>Indicates whether the column is sortable.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.TableColumn.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;TableColumn.name is required.&#39;)
    if self.label is None:
        raise ValueError(&#39;TableColumn.label is required.&#39;)
    return _dump(
        name=self.name,
        label=self.label,
        min_width=self.min_width,
        max_width=self.max_width,
        sortable=self.sortable,
        searchable=self.searchable,
        filterable=self.filterable,
        link=self.link,
        cell_type=None if self.cell_type is None else self.cell_type.dump(),
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.TableRow"><code class="flex name class">
<span>class <span class="ident">TableRow</span></span>
<span>(</span><span>name: str, cells: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Create a table row.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TableRow:
    &#34;&#34;&#34;Create a table row.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            cells: List[str],
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this row.&#34;&#34;&#34;
        self.cells = cells
        &#34;&#34;&#34;The cells in this row (displayed left to right).&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;TableRow.name is required.&#39;)
        if self.cells is None:
            raise ValueError(&#39;TableRow.cells is required.&#39;)
        return _dump(
            name=self.name,
            cells=self.cells,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TableRow&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;TableRow.name is required.&#39;)
        __d_cells: Any = __d.get(&#39;cells&#39;)
        if __d_cells is None:
            raise ValueError(&#39;TableRow.cells is required.&#39;)
        name: str = __d_name
        cells: List[str] = __d_cells
        return TableRow(
            name,
            cells,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.TableRow.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_TableRow__d: Dict) ‑> <a title="h2o_q.types.TableRow" href="#h2o_q.types.TableRow">TableRow</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;TableRow&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;TableRow.name is required.&#39;)
    __d_cells: Any = __d.get(&#39;cells&#39;)
    if __d_cells is None:
        raise ValueError(&#39;TableRow.cells is required.&#39;)
    name: str = __d_name
    cells: List[str] = __d_cells
    return TableRow(
        name,
        cells,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.TableRow.cells"><code class="name">var <span class="ident">cells</span></code></dt>
<dd>
<div class="desc"><p>The cells in this row (displayed left to right).</p></div>
</dd>
<dt id="h2o_q.types.TableRow.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this row.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.TableRow.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;TableRow.name is required.&#39;)
    if self.cells is None:
        raise ValueError(&#39;TableRow.cells is required.&#39;)
    return _dump(
        name=self.name,
        cells=self.cells,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Tabs"><code class="flex name class">
<span>class <span class="ident">Tabs</span></span>
<span>(</span><span>name: str, value: Union[str, NoneType] = None, items: Union[List[<a title="h2o_q.types.Tab" href="#h2o_q.types.Tab">Tab</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a tab bar.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tabs:
    &#34;&#34;&#34;Create a tab bar.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            value: Optional[str] = None,
            items: Optional[List[Tab]] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The name of the tab to select.&#34;&#34;&#34;
        self.items = items
        &#34;&#34;&#34;The tabs in this tab bar.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Tabs.name is required.&#39;)
        return _dump(
            name=self.name,
            value=self.value,
            items=None if self.items is None else [__e.dump() for __e in self.items],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Tabs&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Tabs.name is required.&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_items: Any = __d.get(&#39;items&#39;)
        name: str = __d_name
        value: Optional[str] = __d_value
        items: Optional[List[Tab]] = None if __d_items is None else [Tab.load(__e) for __e in __d_items]
        return Tabs(
            name,
            value,
            items,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Tabs.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Tabs__d: Dict) ‑> <a title="h2o_q.types.Tabs" href="#h2o_q.types.Tabs">Tabs</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Tabs&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;Tabs.name is required.&#39;)
    __d_value: Any = __d.get(&#39;value&#39;)
    __d_items: Any = __d.get(&#39;items&#39;)
    name: str = __d_name
    value: Optional[str] = __d_value
    items: Optional[List[Tab]] = None if __d_items is None else [Tab.load(__e) for __e in __d_items]
    return Tabs(
        name,
        value,
        items,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Tabs.items"><code class="name">var <span class="ident">items</span></code></dt>
<dd>
<div class="desc"><p>The tabs in this tab bar.</p></div>
</dd>
<dt id="h2o_q.types.Tabs.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this component.</p></div>
</dd>
<dt id="h2o_q.types.Tabs.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>The name of the tab to select.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Tabs.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;Tabs.name is required.&#39;)
    return _dump(
        name=self.name,
        value=self.value,
        items=None if self.items is None else [__e.dump() for __e in self.items],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.TallGaugeStatCard"><code class="flex name class">
<span>class <span class="ident">TallGaugeStatCard</span></span>
<span>(</span><span>box: str, title: str, value: str, aux_value: str, progress: float, plot_color: Union[str, NoneType] = None, data: Union[dict, str, NoneType] = None, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a tall stat card displaying a primary value, an auxiliary value and a progress gauge.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TallGaugeStatCard:
    &#34;&#34;&#34;Create a tall stat card displaying a primary value, an auxiliary value and a progress gauge.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            value: str,
            aux_value: str,
            progress: float,
            plot_color: Optional[str] = None,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The card&#39;s title.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The primary value displayed.&#34;&#34;&#34;
        self.aux_value = aux_value
        &#34;&#34;&#34;The auxiliary value displayed next to the primary value.&#34;&#34;&#34;
        self.progress = progress
        &#34;&#34;&#34;The value of the progress gauge, between 0 and 1.&#34;&#34;&#34;
        self.plot_color = plot_color
        &#34;&#34;&#34;The color of the progress gauge.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;TallGaugeStatCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;TallGaugeStatCard.title is required.&#39;)
        if self.value is None:
            raise ValueError(&#39;TallGaugeStatCard.value is required.&#39;)
        if self.aux_value is None:
            raise ValueError(&#39;TallGaugeStatCard.aux_value is required.&#39;)
        if self.progress is None:
            raise ValueError(&#39;TallGaugeStatCard.progress is required.&#39;)
        return _dump(
            view=&#39;tall_gauge_stat&#39;,
            box=self.box,
            title=self.title,
            value=self.value,
            aux_value=self.aux_value,
            progress=self.progress,
            plot_color=self.plot_color,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TallGaugeStatCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;TallGaugeStatCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;TallGaugeStatCard.title is required.&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        if __d_value is None:
            raise ValueError(&#39;TallGaugeStatCard.value is required.&#39;)
        __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
        if __d_aux_value is None:
            raise ValueError(&#39;TallGaugeStatCard.aux_value is required.&#39;)
        __d_progress: Any = __d.get(&#39;progress&#39;)
        if __d_progress is None:
            raise ValueError(&#39;TallGaugeStatCard.progress is required.&#39;)
        __d_plot_color: Any = __d.get(&#39;plot_color&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        value: str = __d_value
        aux_value: str = __d_aux_value
        progress: float = __d_progress
        plot_color: Optional[str] = __d_plot_color
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return TallGaugeStatCard(
            box,
            title,
            value,
            aux_value,
            progress,
            plot_color,
            data,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.TallGaugeStatCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_TallGaugeStatCard__d: Dict) ‑> <a title="h2o_q.types.TallGaugeStatCard" href="#h2o_q.types.TallGaugeStatCard">TallGaugeStatCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;TallGaugeStatCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;TallGaugeStatCard.box is required.&#39;)
    __d_title: Any = __d.get(&#39;title&#39;)
    if __d_title is None:
        raise ValueError(&#39;TallGaugeStatCard.title is required.&#39;)
    __d_value: Any = __d.get(&#39;value&#39;)
    if __d_value is None:
        raise ValueError(&#39;TallGaugeStatCard.value is required.&#39;)
    __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
    if __d_aux_value is None:
        raise ValueError(&#39;TallGaugeStatCard.aux_value is required.&#39;)
    __d_progress: Any = __d.get(&#39;progress&#39;)
    if __d_progress is None:
        raise ValueError(&#39;TallGaugeStatCard.progress is required.&#39;)
    __d_plot_color: Any = __d.get(&#39;plot_color&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    title: str = __d_title
    value: str = __d_value
    aux_value: str = __d_aux_value
    progress: float = __d_progress
    plot_color: Optional[str] = __d_plot_color
    data: Optional[PackedRecord] = __d_data
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return TallGaugeStatCard(
        box,
        title,
        value,
        aux_value,
        progress,
        plot_color,
        data,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.TallGaugeStatCard.aux_value"><code class="name">var <span class="ident">aux_value</span></code></dt>
<dd>
<div class="desc"><p>The auxiliary value displayed next to the primary value.</p></div>
</dd>
<dt id="h2o_q.types.TallGaugeStatCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.TallGaugeStatCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.TallGaugeStatCard.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Data for this card.</p></div>
</dd>
<dt id="h2o_q.types.TallGaugeStatCard.plot_color"><code class="name">var <span class="ident">plot_color</span></code></dt>
<dd>
<div class="desc"><p>The color of the progress gauge.</p></div>
</dd>
<dt id="h2o_q.types.TallGaugeStatCard.progress"><code class="name">var <span class="ident">progress</span></code></dt>
<dd>
<div class="desc"><p>The value of the progress gauge, between 0 and 1.</p></div>
</dd>
<dt id="h2o_q.types.TallGaugeStatCard.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>The card's title.</p></div>
</dd>
<dt id="h2o_q.types.TallGaugeStatCard.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>The primary value displayed.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.TallGaugeStatCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;TallGaugeStatCard.box is required.&#39;)
    if self.title is None:
        raise ValueError(&#39;TallGaugeStatCard.title is required.&#39;)
    if self.value is None:
        raise ValueError(&#39;TallGaugeStatCard.value is required.&#39;)
    if self.aux_value is None:
        raise ValueError(&#39;TallGaugeStatCard.aux_value is required.&#39;)
    if self.progress is None:
        raise ValueError(&#39;TallGaugeStatCard.progress is required.&#39;)
    return _dump(
        view=&#39;tall_gauge_stat&#39;,
        box=self.box,
        title=self.title,
        value=self.value,
        aux_value=self.aux_value,
        progress=self.progress,
        plot_color=self.plot_color,
        data=self.data,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.TallSeriesStatCard"><code class="flex name class">
<span>class <span class="ident">TallSeriesStatCard</span></span>
<span>(</span><span>box: str, title: str, value: str, aux_value: str, plot_data: Union[<a title="h2o_q.core.Data" href="core.html#h2o_q.core.Data">Data</a>, str], plot_value: str, plot_zero_value: Union[float, NoneType] = None, plot_category: Union[str, NoneType] = None, plot_type: Union[str, NoneType] = None, plot_curve: Union[str, NoneType] = None, plot_color: Union[str, NoneType] = None, data: Union[dict, str, NoneType] = None, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a tall stat card displaying a primary value, an auxiliary value and a series plot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TallSeriesStatCard:
    &#34;&#34;&#34;Create a tall stat card displaying a primary value, an auxiliary value and a series plot.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            value: str,
            aux_value: str,
            plot_data: PackedData,
            plot_value: str,
            plot_zero_value: Optional[float] = None,
            plot_category: Optional[str] = None,
            plot_type: Optional[str] = None,
            plot_curve: Optional[str] = None,
            plot_color: Optional[str] = None,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The card&#39;s title.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The primary value displayed.&#34;&#34;&#34;
        self.aux_value = aux_value
        &#34;&#34;&#34;The auxiliary value displayed below the primary value.&#34;&#34;&#34;
        self.plot_data = plot_data
        &#34;&#34;&#34;The plot&#39;s data.&#34;&#34;&#34;
        self.plot_value = plot_value
        &#34;&#34;&#34;The data field to use for y-axis values.&#34;&#34;&#34;
        self.plot_zero_value = plot_zero_value
        &#34;&#34;&#34;The base value to use for each y-axis mark. Set this to `0` if you want to pin the x-axis at `y=0`. If not provided, the minimum value from the data is used.&#34;&#34;&#34;
        self.plot_category = plot_category
        &#34;&#34;&#34;The data field to use for x-axis values (ignored if `plot_type` is `area`; must be provided if `plot_type` is `interval`). Defaults to &#39;x&#39;.&#34;&#34;&#34;
        self.plot_type = plot_type
        &#34;&#34;&#34;The type of plot. Defaults to `area`. One of &#39;area&#39;, &#39;interval&#39;.&#34;&#34;&#34;
        self.plot_curve = plot_curve
        &#34;&#34;&#34;The plot&#39;s curve style. Defaults to `linear`. One of &#39;linear&#39;, &#39;smooth&#39;, &#39;step&#39;, &#39;step-after&#39;, &#39;step-before&#39;.&#34;&#34;&#34;
        self.plot_color = plot_color
        &#34;&#34;&#34;The plot&#39;s color.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;TallSeriesStatCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;TallSeriesStatCard.title is required.&#39;)
        if self.value is None:
            raise ValueError(&#39;TallSeriesStatCard.value is required.&#39;)
        if self.aux_value is None:
            raise ValueError(&#39;TallSeriesStatCard.aux_value is required.&#39;)
        if self.plot_data is None:
            raise ValueError(&#39;TallSeriesStatCard.plot_data is required.&#39;)
        if self.plot_value is None:
            raise ValueError(&#39;TallSeriesStatCard.plot_value is required.&#39;)
        return _dump(
            view=&#39;tall_series_stat&#39;,
            box=self.box,
            title=self.title,
            value=self.value,
            aux_value=self.aux_value,
            plot_data=self.plot_data,
            plot_value=self.plot_value,
            plot_zero_value=self.plot_zero_value,
            plot_category=self.plot_category,
            plot_type=self.plot_type,
            plot_curve=self.plot_curve,
            plot_color=self.plot_color,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TallSeriesStatCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;TallSeriesStatCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;TallSeriesStatCard.title is required.&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        if __d_value is None:
            raise ValueError(&#39;TallSeriesStatCard.value is required.&#39;)
        __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
        if __d_aux_value is None:
            raise ValueError(&#39;TallSeriesStatCard.aux_value is required.&#39;)
        __d_plot_data: Any = __d.get(&#39;plot_data&#39;)
        if __d_plot_data is None:
            raise ValueError(&#39;TallSeriesStatCard.plot_data is required.&#39;)
        __d_plot_value: Any = __d.get(&#39;plot_value&#39;)
        if __d_plot_value is None:
            raise ValueError(&#39;TallSeriesStatCard.plot_value is required.&#39;)
        __d_plot_zero_value: Any = __d.get(&#39;plot_zero_value&#39;)
        __d_plot_category: Any = __d.get(&#39;plot_category&#39;)
        __d_plot_type: Any = __d.get(&#39;plot_type&#39;)
        __d_plot_curve: Any = __d.get(&#39;plot_curve&#39;)
        __d_plot_color: Any = __d.get(&#39;plot_color&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        value: str = __d_value
        aux_value: str = __d_aux_value
        plot_data: PackedData = __d_plot_data
        plot_value: str = __d_plot_value
        plot_zero_value: Optional[float] = __d_plot_zero_value
        plot_category: Optional[str] = __d_plot_category
        plot_type: Optional[str] = __d_plot_type
        plot_curve: Optional[str] = __d_plot_curve
        plot_color: Optional[str] = __d_plot_color
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return TallSeriesStatCard(
            box,
            title,
            value,
            aux_value,
            plot_data,
            plot_value,
            plot_zero_value,
            plot_category,
            plot_type,
            plot_curve,
            plot_color,
            data,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.TallSeriesStatCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_TallSeriesStatCard__d: Dict) ‑> <a title="h2o_q.types.TallSeriesStatCard" href="#h2o_q.types.TallSeriesStatCard">TallSeriesStatCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;TallSeriesStatCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;TallSeriesStatCard.box is required.&#39;)
    __d_title: Any = __d.get(&#39;title&#39;)
    if __d_title is None:
        raise ValueError(&#39;TallSeriesStatCard.title is required.&#39;)
    __d_value: Any = __d.get(&#39;value&#39;)
    if __d_value is None:
        raise ValueError(&#39;TallSeriesStatCard.value is required.&#39;)
    __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
    if __d_aux_value is None:
        raise ValueError(&#39;TallSeriesStatCard.aux_value is required.&#39;)
    __d_plot_data: Any = __d.get(&#39;plot_data&#39;)
    if __d_plot_data is None:
        raise ValueError(&#39;TallSeriesStatCard.plot_data is required.&#39;)
    __d_plot_value: Any = __d.get(&#39;plot_value&#39;)
    if __d_plot_value is None:
        raise ValueError(&#39;TallSeriesStatCard.plot_value is required.&#39;)
    __d_plot_zero_value: Any = __d.get(&#39;plot_zero_value&#39;)
    __d_plot_category: Any = __d.get(&#39;plot_category&#39;)
    __d_plot_type: Any = __d.get(&#39;plot_type&#39;)
    __d_plot_curve: Any = __d.get(&#39;plot_curve&#39;)
    __d_plot_color: Any = __d.get(&#39;plot_color&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    title: str = __d_title
    value: str = __d_value
    aux_value: str = __d_aux_value
    plot_data: PackedData = __d_plot_data
    plot_value: str = __d_plot_value
    plot_zero_value: Optional[float] = __d_plot_zero_value
    plot_category: Optional[str] = __d_plot_category
    plot_type: Optional[str] = __d_plot_type
    plot_curve: Optional[str] = __d_plot_curve
    plot_color: Optional[str] = __d_plot_color
    data: Optional[PackedRecord] = __d_data
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return TallSeriesStatCard(
        box,
        title,
        value,
        aux_value,
        plot_data,
        plot_value,
        plot_zero_value,
        plot_category,
        plot_type,
        plot_curve,
        plot_color,
        data,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.TallSeriesStatCard.aux_value"><code class="name">var <span class="ident">aux_value</span></code></dt>
<dd>
<div class="desc"><p>The auxiliary value displayed below the primary value.</p></div>
</dd>
<dt id="h2o_q.types.TallSeriesStatCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.TallSeriesStatCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.TallSeriesStatCard.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Data for this card.</p></div>
</dd>
<dt id="h2o_q.types.TallSeriesStatCard.plot_category"><code class="name">var <span class="ident">plot_category</span></code></dt>
<dd>
<div class="desc"><p>The data field to use for x-axis values (ignored if <code>plot_type</code> is <code>area</code>; must be provided if <code>plot_type</code> is <code>interval</code>). Defaults to 'x'.</p></div>
</dd>
<dt id="h2o_q.types.TallSeriesStatCard.plot_color"><code class="name">var <span class="ident">plot_color</span></code></dt>
<dd>
<div class="desc"><p>The plot's color.</p></div>
</dd>
<dt id="h2o_q.types.TallSeriesStatCard.plot_curve"><code class="name">var <span class="ident">plot_curve</span></code></dt>
<dd>
<div class="desc"><p>The plot's curve style. Defaults to <code>linear</code>. One of 'linear', 'smooth', 'step', 'step-after', 'step-before'.</p></div>
</dd>
<dt id="h2o_q.types.TallSeriesStatCard.plot_data"><code class="name">var <span class="ident">plot_data</span></code></dt>
<dd>
<div class="desc"><p>The plot's data.</p></div>
</dd>
<dt id="h2o_q.types.TallSeriesStatCard.plot_type"><code class="name">var <span class="ident">plot_type</span></code></dt>
<dd>
<div class="desc"><p>The type of plot. Defaults to <code>area</code>. One of 'area', 'interval'.</p></div>
</dd>
<dt id="h2o_q.types.TallSeriesStatCard.plot_value"><code class="name">var <span class="ident">plot_value</span></code></dt>
<dd>
<div class="desc"><p>The data field to use for y-axis values.</p></div>
</dd>
<dt id="h2o_q.types.TallSeriesStatCard.plot_zero_value"><code class="name">var <span class="ident">plot_zero_value</span></code></dt>
<dd>
<div class="desc"><p>The base value to use for each y-axis mark. Set this to <code>0</code> if you want to pin the x-axis at <code>y=0</code>. If not provided, the minimum value from the data is used.</p></div>
</dd>
<dt id="h2o_q.types.TallSeriesStatCard.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>The card's title.</p></div>
</dd>
<dt id="h2o_q.types.TallSeriesStatCard.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>The primary value displayed.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.TallSeriesStatCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;TallSeriesStatCard.box is required.&#39;)
    if self.title is None:
        raise ValueError(&#39;TallSeriesStatCard.title is required.&#39;)
    if self.value is None:
        raise ValueError(&#39;TallSeriesStatCard.value is required.&#39;)
    if self.aux_value is None:
        raise ValueError(&#39;TallSeriesStatCard.aux_value is required.&#39;)
    if self.plot_data is None:
        raise ValueError(&#39;TallSeriesStatCard.plot_data is required.&#39;)
    if self.plot_value is None:
        raise ValueError(&#39;TallSeriesStatCard.plot_value is required.&#39;)
    return _dump(
        view=&#39;tall_series_stat&#39;,
        box=self.box,
        title=self.title,
        value=self.value,
        aux_value=self.aux_value,
        plot_data=self.plot_data,
        plot_value=self.plot_value,
        plot_zero_value=self.plot_zero_value,
        plot_category=self.plot_category,
        plot_type=self.plot_type,
        plot_curve=self.plot_curve,
        plot_color=self.plot_color,
        data=self.data,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Template"><code class="flex name class">
<span>class <span class="ident">Template</span></span>
<span>(</span><span>content: str, data: Union[dict, str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Render dynamic content using a HTML template.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Template:
    &#34;&#34;&#34;Render dynamic content using a HTML template.
    &#34;&#34;&#34;
    def __init__(
            self,
            content: str,
            data: Optional[PackedRecord] = None,
    ):
        self.content = content
        &#34;&#34;&#34;The Handlebars template. https://handlebarsjs.com/guide/&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for the Handlebars template&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.content is None:
            raise ValueError(&#39;Template.content is required.&#39;)
        return _dump(
            content=self.content,
            data=self.data,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Template&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_content: Any = __d.get(&#39;content&#39;)
        if __d_content is None:
            raise ValueError(&#39;Template.content is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        content: str = __d_content
        data: Optional[PackedRecord] = __d_data
        return Template(
            content,
            data,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Template.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Template__d: Dict) ‑> <a title="h2o_q.types.Template" href="#h2o_q.types.Template">Template</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Template&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_content: Any = __d.get(&#39;content&#39;)
    if __d_content is None:
        raise ValueError(&#39;Template.content is required.&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    content: str = __d_content
    data: Optional[PackedRecord] = __d_data
    return Template(
        content,
        data,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Template.content"><code class="name">var <span class="ident">content</span></code></dt>
<dd>
<div class="desc"><p>The Handlebars template. <a href="https://handlebarsjs.com/guide/">https://handlebarsjs.com/guide/</a></p></div>
</dd>
<dt id="h2o_q.types.Template.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Data for the Handlebars template</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Template.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.content is None:
        raise ValueError(&#39;Template.content is required.&#39;)
    return _dump(
        content=self.content,
        data=self.data,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.TemplateCard"><code class="flex name class">
<span>class <span class="ident">TemplateCard</span></span>
<span>(</span><span>box: str, title: str, content: str, data: Union[dict, str, NoneType] = None, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Render dynamic content using a HTML template.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TemplateCard:
    &#34;&#34;&#34;Render dynamic content using a HTML template.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            content: str,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The title for this card.&#34;&#34;&#34;
        self.content = content
        &#34;&#34;&#34;The Handlebars template. https://handlebarsjs.com/guide/&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for the Handlebars template&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;TemplateCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;TemplateCard.title is required.&#39;)
        if self.content is None:
            raise ValueError(&#39;TemplateCard.content is required.&#39;)
        return _dump(
            view=&#39;template&#39;,
            box=self.box,
            title=self.title,
            content=self.content,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TemplateCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;TemplateCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;TemplateCard.title is required.&#39;)
        __d_content: Any = __d.get(&#39;content&#39;)
        if __d_content is None:
            raise ValueError(&#39;TemplateCard.content is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        content: str = __d_content
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return TemplateCard(
            box,
            title,
            content,
            data,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.TemplateCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_TemplateCard__d: Dict) ‑> <a title="h2o_q.types.TemplateCard" href="#h2o_q.types.TemplateCard">TemplateCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;TemplateCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;TemplateCard.box is required.&#39;)
    __d_title: Any = __d.get(&#39;title&#39;)
    if __d_title is None:
        raise ValueError(&#39;TemplateCard.title is required.&#39;)
    __d_content: Any = __d.get(&#39;content&#39;)
    if __d_content is None:
        raise ValueError(&#39;TemplateCard.content is required.&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    title: str = __d_title
    content: str = __d_content
    data: Optional[PackedRecord] = __d_data
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return TemplateCard(
        box,
        title,
        content,
        data,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.TemplateCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.TemplateCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.TemplateCard.content"><code class="name">var <span class="ident">content</span></code></dt>
<dd>
<div class="desc"><p>The Handlebars template. <a href="https://handlebarsjs.com/guide/">https://handlebarsjs.com/guide/</a></p></div>
</dd>
<dt id="h2o_q.types.TemplateCard.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Data for the Handlebars template</p></div>
</dd>
<dt id="h2o_q.types.TemplateCard.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>The title for this card.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.TemplateCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;TemplateCard.box is required.&#39;)
    if self.title is None:
        raise ValueError(&#39;TemplateCard.title is required.&#39;)
    if self.content is None:
        raise ValueError(&#39;TemplateCard.content is required.&#39;)
    return _dump(
        view=&#39;template&#39;,
        box=self.box,
        title=self.title,
        content=self.content,
        data=self.data,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Text"><code class="flex name class">
<span>class <span class="ident">Text</span></span>
<span>(</span><span>content: str, size: Union[str, NoneType] = None, tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create text content.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Text:
    &#34;&#34;&#34;Create text content.
    &#34;&#34;&#34;
    def __init__(
            self,
            content: str,
            size: Optional[str] = None,
            tooltip: Optional[str] = None,
    ):
        self.content = content
        &#34;&#34;&#34;The text content.&#34;&#34;&#34;
        self.size = size
        &#34;&#34;&#34;The font size of the text content. One of &#39;xl&#39;, &#39;l&#39;, &#39;m&#39;, &#39;s&#39;, &#39;xs&#39;.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;Tooltip message.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.content is None:
            raise ValueError(&#39;Text.content is required.&#39;)
        return _dump(
            content=self.content,
            size=self.size,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Text&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_content: Any = __d.get(&#39;content&#39;)
        if __d_content is None:
            raise ValueError(&#39;Text.content is required.&#39;)
        __d_size: Any = __d.get(&#39;size&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        content: str = __d_content
        size: Optional[str] = __d_size
        tooltip: Optional[str] = __d_tooltip
        return Text(
            content,
            size,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Text.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Text__d: Dict) ‑> <a title="h2o_q.types.Text" href="#h2o_q.types.Text">Text</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Text&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_content: Any = __d.get(&#39;content&#39;)
    if __d_content is None:
        raise ValueError(&#39;Text.content is required.&#39;)
    __d_size: Any = __d.get(&#39;size&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    content: str = __d_content
    size: Optional[str] = __d_size
    tooltip: Optional[str] = __d_tooltip
    return Text(
        content,
        size,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Text.content"><code class="name">var <span class="ident">content</span></code></dt>
<dd>
<div class="desc"><p>The text content.</p></div>
</dd>
<dt id="h2o_q.types.Text.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"><p>The font size of the text content. One of 'xl', 'l', 'm', 's', 'xs'.</p></div>
</dd>
<dt id="h2o_q.types.Text.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>Tooltip message.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Text.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.content is None:
        raise ValueError(&#39;Text.content is required.&#39;)
    return _dump(
        content=self.content,
        size=self.size,
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.TextL"><code class="flex name class">
<span>class <span class="ident">TextL</span></span>
<span>(</span><span>content: str, tooltip: Union[str, NoneType] = None, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create large sized text content.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TextL:
    &#34;&#34;&#34;Create large sized text content.
    &#34;&#34;&#34;
    def __init__(
            self,
            content: str,
            tooltip: Optional[str] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.content = content
        &#34;&#34;&#34;The text content.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;Tooltip message.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.content is None:
            raise ValueError(&#39;TextL.content is required.&#39;)
        return _dump(
            content=self.content,
            tooltip=self.tooltip,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TextL&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_content: Any = __d.get(&#39;content&#39;)
        if __d_content is None:
            raise ValueError(&#39;TextL.content is required.&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        content: str = __d_content
        tooltip: Optional[str] = __d_tooltip
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return TextL(
            content,
            tooltip,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.TextL.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_TextL__d: Dict) ‑> <a title="h2o_q.types.TextL" href="#h2o_q.types.TextL">TextL</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;TextL&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_content: Any = __d.get(&#39;content&#39;)
    if __d_content is None:
        raise ValueError(&#39;TextL.content is required.&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    content: str = __d_content
    tooltip: Optional[str] = __d_tooltip
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return TextL(
        content,
        tooltip,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.TextL.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.TextL.content"><code class="name">var <span class="ident">content</span></code></dt>
<dd>
<div class="desc"><p>The text content.</p></div>
</dd>
<dt id="h2o_q.types.TextL.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>Tooltip message.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.TextL.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.content is None:
        raise ValueError(&#39;TextL.content is required.&#39;)
    return _dump(
        content=self.content,
        tooltip=self.tooltip,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.TextM"><code class="flex name class">
<span>class <span class="ident">TextM</span></span>
<span>(</span><span>content: str, tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create medium sized text content.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TextM:
    &#34;&#34;&#34;Create medium sized text content.
    &#34;&#34;&#34;
    def __init__(
            self,
            content: str,
            tooltip: Optional[str] = None,
    ):
        self.content = content
        &#34;&#34;&#34;The text content.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;Tooltip message.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.content is None:
            raise ValueError(&#39;TextM.content is required.&#39;)
        return _dump(
            content=self.content,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TextM&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_content: Any = __d.get(&#39;content&#39;)
        if __d_content is None:
            raise ValueError(&#39;TextM.content is required.&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        content: str = __d_content
        tooltip: Optional[str] = __d_tooltip
        return TextM(
            content,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.TextM.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_TextM__d: Dict) ‑> <a title="h2o_q.types.TextM" href="#h2o_q.types.TextM">TextM</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;TextM&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_content: Any = __d.get(&#39;content&#39;)
    if __d_content is None:
        raise ValueError(&#39;TextM.content is required.&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    content: str = __d_content
    tooltip: Optional[str] = __d_tooltip
    return TextM(
        content,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.TextM.content"><code class="name">var <span class="ident">content</span></code></dt>
<dd>
<div class="desc"><p>The text content.</p></div>
</dd>
<dt id="h2o_q.types.TextM.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>Tooltip message.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.TextM.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.content is None:
        raise ValueError(&#39;TextM.content is required.&#39;)
    return _dump(
        content=self.content,
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.TextS"><code class="flex name class">
<span>class <span class="ident">TextS</span></span>
<span>(</span><span>content: str, tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create small sized text content.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TextS:
    &#34;&#34;&#34;Create small sized text content.
    &#34;&#34;&#34;
    def __init__(
            self,
            content: str,
            tooltip: Optional[str] = None,
    ):
        self.content = content
        &#34;&#34;&#34;The text content.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;Tooltip message.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.content is None:
            raise ValueError(&#39;TextS.content is required.&#39;)
        return _dump(
            content=self.content,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TextS&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_content: Any = __d.get(&#39;content&#39;)
        if __d_content is None:
            raise ValueError(&#39;TextS.content is required.&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        content: str = __d_content
        tooltip: Optional[str] = __d_tooltip
        return TextS(
            content,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.TextS.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_TextS__d: Dict) ‑> <a title="h2o_q.types.TextS" href="#h2o_q.types.TextS">TextS</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;TextS&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_content: Any = __d.get(&#39;content&#39;)
    if __d_content is None:
        raise ValueError(&#39;TextS.content is required.&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    content: str = __d_content
    tooltip: Optional[str] = __d_tooltip
    return TextS(
        content,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.TextS.content"><code class="name">var <span class="ident">content</span></code></dt>
<dd>
<div class="desc"><p>The text content.</p></div>
</dd>
<dt id="h2o_q.types.TextS.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>Tooltip message.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.TextS.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.content is None:
        raise ValueError(&#39;TextS.content is required.&#39;)
    return _dump(
        content=self.content,
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.TextXl"><code class="flex name class">
<span>class <span class="ident">TextXl</span></span>
<span>(</span><span>content: str, tooltip: Union[str, NoneType] = None, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create extra-large sized text content.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TextXl:
    &#34;&#34;&#34;Create extra-large sized text content.
    &#34;&#34;&#34;
    def __init__(
            self,
            content: str,
            tooltip: Optional[str] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.content = content
        &#34;&#34;&#34;The text content.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;Tooltip message.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.content is None:
            raise ValueError(&#39;TextXl.content is required.&#39;)
        return _dump(
            content=self.content,
            tooltip=self.tooltip,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TextXl&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_content: Any = __d.get(&#39;content&#39;)
        if __d_content is None:
            raise ValueError(&#39;TextXl.content is required.&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        content: str = __d_content
        tooltip: Optional[str] = __d_tooltip
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return TextXl(
            content,
            tooltip,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.TextXl.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_TextXl__d: Dict) ‑> <a title="h2o_q.types.TextXl" href="#h2o_q.types.TextXl">TextXl</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;TextXl&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_content: Any = __d.get(&#39;content&#39;)
    if __d_content is None:
        raise ValueError(&#39;TextXl.content is required.&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    content: str = __d_content
    tooltip: Optional[str] = __d_tooltip
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return TextXl(
        content,
        tooltip,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.TextXl.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.TextXl.content"><code class="name">var <span class="ident">content</span></code></dt>
<dd>
<div class="desc"><p>The text content.</p></div>
</dd>
<dt id="h2o_q.types.TextXl.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>Tooltip message.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.TextXl.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.content is None:
        raise ValueError(&#39;TextXl.content is required.&#39;)
    return _dump(
        content=self.content,
        tooltip=self.tooltip,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.TextXs"><code class="flex name class">
<span>class <span class="ident">TextXs</span></span>
<span>(</span><span>content: str, tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create extra-small sized text content.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TextXs:
    &#34;&#34;&#34;Create extra-small sized text content.
    &#34;&#34;&#34;
    def __init__(
            self,
            content: str,
            tooltip: Optional[str] = None,
    ):
        self.content = content
        &#34;&#34;&#34;The text content.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;Tooltip message.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.content is None:
            raise ValueError(&#39;TextXs.content is required.&#39;)
        return _dump(
            content=self.content,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;TextXs&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_content: Any = __d.get(&#39;content&#39;)
        if __d_content is None:
            raise ValueError(&#39;TextXs.content is required.&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        content: str = __d_content
        tooltip: Optional[str] = __d_tooltip
        return TextXs(
            content,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.TextXs.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_TextXs__d: Dict) ‑> <a title="h2o_q.types.TextXs" href="#h2o_q.types.TextXs">TextXs</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;TextXs&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_content: Any = __d.get(&#39;content&#39;)
    if __d_content is None:
        raise ValueError(&#39;TextXs.content is required.&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    content: str = __d_content
    tooltip: Optional[str] = __d_tooltip
    return TextXs(
        content,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.TextXs.content"><code class="name">var <span class="ident">content</span></code></dt>
<dd>
<div class="desc"><p>The text content.</p></div>
</dd>
<dt id="h2o_q.types.TextXs.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>Tooltip message.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.TextXs.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.content is None:
        raise ValueError(&#39;TextXs.content is required.&#39;)
    return _dump(
        content=self.content,
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Textbox"><code class="flex name class">
<span>class <span class="ident">Textbox</span></span>
<span>(</span><span>name: str, label: Union[str, NoneType] = None, placeholder: Union[str, NoneType] = None, value: Union[str, NoneType] = None, mask: Union[str, NoneType] = None, icon: Union[str, NoneType] = None, prefix: Union[str, NoneType] = None, suffix: Union[str, NoneType] = None, error: Union[str, NoneType] = None, required: Union[bool, NoneType] = None, disabled: Union[bool, NoneType] = None, readonly: Union[bool, NoneType] = None, multiline: Union[bool, NoneType] = None, password: Union[bool, NoneType] = None, trigger: Union[bool, NoneType] = None, tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a text box.</p>
<p>The text box component enables a user to type text into an app.
It's typically used to capture a single line of text, but can be configured to capture multiple lines of text.
The text displays on the screen in a simple, uniform format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Textbox:
    &#34;&#34;&#34;Create a text box.

    The text box component enables a user to type text into an app.
    It&#39;s typically used to capture a single line of text, but can be configured to capture multiple lines of text.
    The text displays on the screen in a simple, uniform format.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            placeholder: Optional[str] = None,
            value: Optional[str] = None,
            mask: Optional[str] = None,
            icon: Optional[str] = None,
            prefix: Optional[str] = None,
            suffix: Optional[str] = None,
            error: Optional[str] = None,
            required: Optional[bool] = None,
            disabled: Optional[bool] = None,
            readonly: Optional[bool] = None,
            multiline: Optional[bool] = None,
            password: Optional[bool] = None,
            trigger: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;The text displayed above the field.&#34;&#34;&#34;
        self.placeholder = placeholder
        &#34;&#34;&#34;A string that provides a brief hint to the user as to what kind of information is expected in the field. It should be a word or short phrase that demonstrates the expected type of data, rather than an explanatory message.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;Text to be displayed inside the text box.&#34;&#34;&#34;
        self.mask = mask
        &#34;&#34;&#34;The masking string that defines the mask&#39;s behavior. A backslash will escape any character. Special format characters are: &#39;9&#39;: [0-9] &#39;a&#39;: [a-zA-Z] &#39;*&#39;: [a-zA-Z0-9].&#34;&#34;&#34;
        self.icon = icon
        &#34;&#34;&#34;Icon displayed in the far right end of the text field.&#34;&#34;&#34;
        self.prefix = prefix
        &#34;&#34;&#34;Text to be displayed before the text box contents.&#34;&#34;&#34;
        self.suffix = suffix
        &#34;&#34;&#34;Text to be displayed after the text box contents.&#34;&#34;&#34;
        self.error = error
        &#34;&#34;&#34;Text to be displayed as an error below the text box.&#34;&#34;&#34;
        self.required = required
        &#34;&#34;&#34;True if the text box is a required field.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if the text box is disabled.&#34;&#34;&#34;
        self.readonly = readonly
        &#34;&#34;&#34;True if the text box is a read-only field.&#34;&#34;&#34;
        self.multiline = multiline
        &#34;&#34;&#34;True if the text box should allow multi-line text entry.&#34;&#34;&#34;
        self.password = password
        &#34;&#34;&#34;True if the text box should hide text content.&#34;&#34;&#34;
        self.trigger = trigger
        &#34;&#34;&#34;True if the form should be submitted when the text value changes.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Textbox.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            placeholder=self.placeholder,
            value=self.value,
            mask=self.mask,
            icon=self.icon,
            prefix=self.prefix,
            suffix=self.suffix,
            error=self.error,
            required=self.required,
            disabled=self.disabled,
            readonly=self.readonly,
            multiline=self.multiline,
            password=self.password,
            trigger=self.trigger,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Textbox&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Textbox.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_placeholder: Any = __d.get(&#39;placeholder&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_mask: Any = __d.get(&#39;mask&#39;)
        __d_icon: Any = __d.get(&#39;icon&#39;)
        __d_prefix: Any = __d.get(&#39;prefix&#39;)
        __d_suffix: Any = __d.get(&#39;suffix&#39;)
        __d_error: Any = __d.get(&#39;error&#39;)
        __d_required: Any = __d.get(&#39;required&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_readonly: Any = __d.get(&#39;readonly&#39;)
        __d_multiline: Any = __d.get(&#39;multiline&#39;)
        __d_password: Any = __d.get(&#39;password&#39;)
        __d_trigger: Any = __d.get(&#39;trigger&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        placeholder: Optional[str] = __d_placeholder
        value: Optional[str] = __d_value
        mask: Optional[str] = __d_mask
        icon: Optional[str] = __d_icon
        prefix: Optional[str] = __d_prefix
        suffix: Optional[str] = __d_suffix
        error: Optional[str] = __d_error
        required: Optional[bool] = __d_required
        disabled: Optional[bool] = __d_disabled
        readonly: Optional[bool] = __d_readonly
        multiline: Optional[bool] = __d_multiline
        password: Optional[bool] = __d_password
        trigger: Optional[bool] = __d_trigger
        tooltip: Optional[str] = __d_tooltip
        return Textbox(
            name,
            label,
            placeholder,
            value,
            mask,
            icon,
            prefix,
            suffix,
            error,
            required,
            disabled,
            readonly,
            multiline,
            password,
            trigger,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Textbox.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Textbox__d: Dict) ‑> <a title="h2o_q.types.Textbox" href="#h2o_q.types.Textbox">Textbox</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Textbox&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;Textbox.name is required.&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    __d_placeholder: Any = __d.get(&#39;placeholder&#39;)
    __d_value: Any = __d.get(&#39;value&#39;)
    __d_mask: Any = __d.get(&#39;mask&#39;)
    __d_icon: Any = __d.get(&#39;icon&#39;)
    __d_prefix: Any = __d.get(&#39;prefix&#39;)
    __d_suffix: Any = __d.get(&#39;suffix&#39;)
    __d_error: Any = __d.get(&#39;error&#39;)
    __d_required: Any = __d.get(&#39;required&#39;)
    __d_disabled: Any = __d.get(&#39;disabled&#39;)
    __d_readonly: Any = __d.get(&#39;readonly&#39;)
    __d_multiline: Any = __d.get(&#39;multiline&#39;)
    __d_password: Any = __d.get(&#39;password&#39;)
    __d_trigger: Any = __d.get(&#39;trigger&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    name: str = __d_name
    label: Optional[str] = __d_label
    placeholder: Optional[str] = __d_placeholder
    value: Optional[str] = __d_value
    mask: Optional[str] = __d_mask
    icon: Optional[str] = __d_icon
    prefix: Optional[str] = __d_prefix
    suffix: Optional[str] = __d_suffix
    error: Optional[str] = __d_error
    required: Optional[bool] = __d_required
    disabled: Optional[bool] = __d_disabled
    readonly: Optional[bool] = __d_readonly
    multiline: Optional[bool] = __d_multiline
    password: Optional[bool] = __d_password
    trigger: Optional[bool] = __d_trigger
    tooltip: Optional[str] = __d_tooltip
    return Textbox(
        name,
        label,
        placeholder,
        value,
        mask,
        icon,
        prefix,
        suffix,
        error,
        required,
        disabled,
        readonly,
        multiline,
        password,
        trigger,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Textbox.disabled"><code class="name">var <span class="ident">disabled</span></code></dt>
<dd>
<div class="desc"><p>True if the text box is disabled.</p></div>
</dd>
<dt id="h2o_q.types.Textbox.error"><code class="name">var <span class="ident">error</span></code></dt>
<dd>
<div class="desc"><p>Text to be displayed as an error below the text box.</p></div>
</dd>
<dt id="h2o_q.types.Textbox.icon"><code class="name">var <span class="ident">icon</span></code></dt>
<dd>
<div class="desc"><p>Icon displayed in the far right end of the text field.</p></div>
</dd>
<dt id="h2o_q.types.Textbox.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>The text displayed above the field.</p></div>
</dd>
<dt id="h2o_q.types.Textbox.mask"><code class="name">var <span class="ident">mask</span></code></dt>
<dd>
<div class="desc"><p>The masking string that defines the mask's behavior. A backslash will escape any character. Special format characters are: '9': [0-9] 'a': [a-zA-Z] '*': [a-zA-Z0-9].</p></div>
</dd>
<dt id="h2o_q.types.Textbox.multiline"><code class="name">var <span class="ident">multiline</span></code></dt>
<dd>
<div class="desc"><p>True if the text box should allow multi-line text entry.</p></div>
</dd>
<dt id="h2o_q.types.Textbox.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this component.</p></div>
</dd>
<dt id="h2o_q.types.Textbox.password"><code class="name">var <span class="ident">password</span></code></dt>
<dd>
<div class="desc"><p>True if the text box should hide text content.</p></div>
</dd>
<dt id="h2o_q.types.Textbox.placeholder"><code class="name">var <span class="ident">placeholder</span></code></dt>
<dd>
<div class="desc"><p>A string that provides a brief hint to the user as to what kind of information is expected in the field. It should be a word or short phrase that demonstrates the expected type of data, rather than an explanatory message.</p></div>
</dd>
<dt id="h2o_q.types.Textbox.prefix"><code class="name">var <span class="ident">prefix</span></code></dt>
<dd>
<div class="desc"><p>Text to be displayed before the text box contents.</p></div>
</dd>
<dt id="h2o_q.types.Textbox.readonly"><code class="name">var <span class="ident">readonly</span></code></dt>
<dd>
<div class="desc"><p>True if the text box is a read-only field.</p></div>
</dd>
<dt id="h2o_q.types.Textbox.required"><code class="name">var <span class="ident">required</span></code></dt>
<dd>
<div class="desc"><p>True if the text box is a required field.</p></div>
</dd>
<dt id="h2o_q.types.Textbox.suffix"><code class="name">var <span class="ident">suffix</span></code></dt>
<dd>
<div class="desc"><p>Text to be displayed after the text box contents.</p></div>
</dd>
<dt id="h2o_q.types.Textbox.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>An optional tooltip message displayed when a user clicks the help icon to the right of the component.</p></div>
</dd>
<dt id="h2o_q.types.Textbox.trigger"><code class="name">var <span class="ident">trigger</span></code></dt>
<dd>
<div class="desc"><p>True if the form should be submitted when the text value changes.</p></div>
</dd>
<dt id="h2o_q.types.Textbox.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>Text to be displayed inside the text box.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Textbox.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;Textbox.name is required.&#39;)
    return _dump(
        name=self.name,
        label=self.label,
        placeholder=self.placeholder,
        value=self.value,
        mask=self.mask,
        icon=self.icon,
        prefix=self.prefix,
        suffix=self.suffix,
        error=self.error,
        required=self.required,
        disabled=self.disabled,
        readonly=self.readonly,
        multiline=self.multiline,
        password=self.password,
        trigger=self.trigger,
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Toggle"><code class="flex name class">
<span>class <span class="ident">Toggle</span></span>
<span>(</span><span>name: str, label: Union[str, NoneType] = None, value: Union[bool, NoneType] = None, disabled: Union[bool, NoneType] = None, trigger: Union[bool, NoneType] = None, tooltip: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a toggle.
Toggles represent a physical switch that allows users to turn things on or off.
Use toggles to present users with two mutually exclusive options (like on/off), where choosing an option results
in an immediate action.</p>
<p>Use a toggle for binary operations that take effect right after the user flips the Toggle.
For example, use a Toggle to turn services or hardware components on or off.
In other words, if a physical switch would work for the action, a Toggle is probably the best component to use.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Toggle:
    &#34;&#34;&#34;Create a toggle.
    Toggles represent a physical switch that allows users to turn things on or off.
    Use toggles to present users with two mutually exclusive options (like on/off), where choosing an option results
    in an immediate action.

    Use a toggle for binary operations that take effect right after the user flips the Toggle.
    For example, use a Toggle to turn services or hardware components on or off.
    In other words, if a physical switch would work for the action, a Toggle is probably the best component to use.
    &#34;&#34;&#34;
    def __init__(
            self,
            name: str,
            label: Optional[str] = None,
            value: Optional[bool] = None,
            disabled: Optional[bool] = None,
            trigger: Optional[bool] = None,
            tooltip: Optional[str] = None,
    ):
        self.name = name
        &#34;&#34;&#34;An identifying name for this component.&#34;&#34;&#34;
        self.label = label
        &#34;&#34;&#34;Text to be displayed alongside the component.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;True if selected, False if unselected.&#34;&#34;&#34;
        self.disabled = disabled
        &#34;&#34;&#34;True if the checkbox is disabled.&#34;&#34;&#34;
        self.trigger = trigger
        &#34;&#34;&#34;True if the form should be submitted when the toggle value changes.&#34;&#34;&#34;
        self.tooltip = tooltip
        &#34;&#34;&#34;An optional tooltip message displayed when a user clicks the help icon to the right of the component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.name is None:
            raise ValueError(&#39;Toggle.name is required.&#39;)
        return _dump(
            name=self.name,
            label=self.label,
            value=self.value,
            disabled=self.disabled,
            trigger=self.trigger,
            tooltip=self.tooltip,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Toggle&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_name: Any = __d.get(&#39;name&#39;)
        if __d_name is None:
            raise ValueError(&#39;Toggle.name is required.&#39;)
        __d_label: Any = __d.get(&#39;label&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        __d_disabled: Any = __d.get(&#39;disabled&#39;)
        __d_trigger: Any = __d.get(&#39;trigger&#39;)
        __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
        name: str = __d_name
        label: Optional[str] = __d_label
        value: Optional[bool] = __d_value
        disabled: Optional[bool] = __d_disabled
        trigger: Optional[bool] = __d_trigger
        tooltip: Optional[str] = __d_tooltip
        return Toggle(
            name,
            label,
            value,
            disabled,
            trigger,
            tooltip,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Toggle.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Toggle__d: Dict) ‑> <a title="h2o_q.types.Toggle" href="#h2o_q.types.Toggle">Toggle</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Toggle&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_name: Any = __d.get(&#39;name&#39;)
    if __d_name is None:
        raise ValueError(&#39;Toggle.name is required.&#39;)
    __d_label: Any = __d.get(&#39;label&#39;)
    __d_value: Any = __d.get(&#39;value&#39;)
    __d_disabled: Any = __d.get(&#39;disabled&#39;)
    __d_trigger: Any = __d.get(&#39;trigger&#39;)
    __d_tooltip: Any = __d.get(&#39;tooltip&#39;)
    name: str = __d_name
    label: Optional[str] = __d_label
    value: Optional[bool] = __d_value
    disabled: Optional[bool] = __d_disabled
    trigger: Optional[bool] = __d_trigger
    tooltip: Optional[str] = __d_tooltip
    return Toggle(
        name,
        label,
        value,
        disabled,
        trigger,
        tooltip,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Toggle.disabled"><code class="name">var <span class="ident">disabled</span></code></dt>
<dd>
<div class="desc"><p>True if the checkbox is disabled.</p></div>
</dd>
<dt id="h2o_q.types.Toggle.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>Text to be displayed alongside the component.</p></div>
</dd>
<dt id="h2o_q.types.Toggle.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>An identifying name for this component.</p></div>
</dd>
<dt id="h2o_q.types.Toggle.tooltip"><code class="name">var <span class="ident">tooltip</span></code></dt>
<dd>
<div class="desc"><p>An optional tooltip message displayed when a user clicks the help icon to the right of the component.</p></div>
</dd>
<dt id="h2o_q.types.Toggle.trigger"><code class="name">var <span class="ident">trigger</span></code></dt>
<dd>
<div class="desc"><p>True if the form should be submitted when the toggle value changes.</p></div>
</dd>
<dt id="h2o_q.types.Toggle.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>True if selected, False if unselected.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Toggle.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.name is None:
        raise ValueError(&#39;Toggle.name is required.&#39;)
    return _dump(
        name=self.name,
        label=self.label,
        value=self.value,
        disabled=self.disabled,
        trigger=self.trigger,
        tooltip=self.tooltip,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.ToolbarCard"><code class="flex name class">
<span>class <span class="ident">ToolbarCard</span></span>
<span>(</span><span>box: str, items: List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], secondary_items: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None, overflow_items: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a card containing a toolbar.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ToolbarCard:
    &#34;&#34;&#34;Create a card containing a toolbar.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            items: List[Command],
            secondary_items: Optional[List[Command]] = None,
            overflow_items: Optional[List[Command]] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.items = items
        &#34;&#34;&#34;Items to render.&#34;&#34;&#34;
        self.secondary_items = secondary_items
        &#34;&#34;&#34;Items to render on the right side (or left, in RTL).&#34;&#34;&#34;
        self.overflow_items = overflow_items
        &#34;&#34;&#34;Items to render in an overflow menu.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;ToolbarCard.box is required.&#39;)
        if self.items is None:
            raise ValueError(&#39;ToolbarCard.items is required.&#39;)
        return _dump(
            view=&#39;toolbar&#39;,
            box=self.box,
            items=[__e.dump() for __e in self.items],
            secondary_items=None if self.secondary_items is None else [__e.dump() for __e in self.secondary_items],
            overflow_items=None if self.overflow_items is None else [__e.dump() for __e in self.overflow_items],
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;ToolbarCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;ToolbarCard.box is required.&#39;)
        __d_items: Any = __d.get(&#39;items&#39;)
        if __d_items is None:
            raise ValueError(&#39;ToolbarCard.items is required.&#39;)
        __d_secondary_items: Any = __d.get(&#39;secondary_items&#39;)
        __d_overflow_items: Any = __d.get(&#39;overflow_items&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        items: List[Command] = [Command.load(__e) for __e in __d_items]
        secondary_items: Optional[List[Command]] = None if __d_secondary_items is None else [Command.load(__e) for __e in __d_secondary_items]
        overflow_items: Optional[List[Command]] = None if __d_overflow_items is None else [Command.load(__e) for __e in __d_overflow_items]
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return ToolbarCard(
            box,
            items,
            secondary_items,
            overflow_items,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.ToolbarCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_ToolbarCard__d: Dict) ‑> <a title="h2o_q.types.ToolbarCard" href="#h2o_q.types.ToolbarCard">ToolbarCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;ToolbarCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;ToolbarCard.box is required.&#39;)
    __d_items: Any = __d.get(&#39;items&#39;)
    if __d_items is None:
        raise ValueError(&#39;ToolbarCard.items is required.&#39;)
    __d_secondary_items: Any = __d.get(&#39;secondary_items&#39;)
    __d_overflow_items: Any = __d.get(&#39;overflow_items&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    items: List[Command] = [Command.load(__e) for __e in __d_items]
    secondary_items: Optional[List[Command]] = None if __d_secondary_items is None else [Command.load(__e) for __e in __d_secondary_items]
    overflow_items: Optional[List[Command]] = None if __d_overflow_items is None else [Command.load(__e) for __e in __d_overflow_items]
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return ToolbarCard(
        box,
        items,
        secondary_items,
        overflow_items,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.ToolbarCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.ToolbarCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.ToolbarCard.items"><code class="name">var <span class="ident">items</span></code></dt>
<dd>
<div class="desc"><p>Items to render.</p></div>
</dd>
<dt id="h2o_q.types.ToolbarCard.overflow_items"><code class="name">var <span class="ident">overflow_items</span></code></dt>
<dd>
<div class="desc"><p>Items to render in an overflow menu.</p></div>
</dd>
<dt id="h2o_q.types.ToolbarCard.secondary_items"><code class="name">var <span class="ident">secondary_items</span></code></dt>
<dd>
<div class="desc"><p>Items to render on the right side (or left, in RTL).</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.ToolbarCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;ToolbarCard.box is required.&#39;)
    if self.items is None:
        raise ValueError(&#39;ToolbarCard.items is required.&#39;)
    return _dump(
        view=&#39;toolbar&#39;,
        box=self.box,
        items=[__e.dump() for __e in self.items],
        secondary_items=None if self.secondary_items is None else [__e.dump() for __e in self.secondary_items],
        overflow_items=None if self.overflow_items is None else [__e.dump() for __e in self.overflow_items],
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.VegaCard"><code class="flex name class">
<span>class <span class="ident">VegaCard</span></span>
<span>(</span><span>box: str, title: str, specification: str, data: Union[dict, str, NoneType] = None, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a card containing a Vega-lite plot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VegaCard:
    &#34;&#34;&#34;Create a card containing a Vega-lite plot.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            specification: str,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The title of this card.&#34;&#34;&#34;
        self.specification = specification
        &#34;&#34;&#34;The Vega-lite specification.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for the plot, if any.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;VegaCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;VegaCard.title is required.&#39;)
        if self.specification is None:
            raise ValueError(&#39;VegaCard.specification is required.&#39;)
        return _dump(
            view=&#39;vega&#39;,
            box=self.box,
            title=self.title,
            specification=self.specification,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;VegaCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;VegaCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;VegaCard.title is required.&#39;)
        __d_specification: Any = __d.get(&#39;specification&#39;)
        if __d_specification is None:
            raise ValueError(&#39;VegaCard.specification is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        specification: str = __d_specification
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return VegaCard(
            box,
            title,
            specification,
            data,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.VegaCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_VegaCard__d: Dict) ‑> <a title="h2o_q.types.VegaCard" href="#h2o_q.types.VegaCard">VegaCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;VegaCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;VegaCard.box is required.&#39;)
    __d_title: Any = __d.get(&#39;title&#39;)
    if __d_title is None:
        raise ValueError(&#39;VegaCard.title is required.&#39;)
    __d_specification: Any = __d.get(&#39;specification&#39;)
    if __d_specification is None:
        raise ValueError(&#39;VegaCard.specification is required.&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    title: str = __d_title
    specification: str = __d_specification
    data: Optional[PackedRecord] = __d_data
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return VegaCard(
        box,
        title,
        specification,
        data,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.VegaCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.VegaCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.VegaCard.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Data for the plot, if any.</p></div>
</dd>
<dt id="h2o_q.types.VegaCard.specification"><code class="name">var <span class="ident">specification</span></code></dt>
<dd>
<div class="desc"><p>The Vega-lite specification.</p></div>
</dd>
<dt id="h2o_q.types.VegaCard.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>The title of this card.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.VegaCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;VegaCard.box is required.&#39;)
    if self.title is None:
        raise ValueError(&#39;VegaCard.title is required.&#39;)
    if self.specification is None:
        raise ValueError(&#39;VegaCard.specification is required.&#39;)
    return _dump(
        view=&#39;vega&#39;,
        box=self.box,
        title=self.title,
        specification=self.specification,
        data=self.data,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.VegaVisualization"><code class="flex name class">
<span>class <span class="ident">VegaVisualization</span></span>
<span>(</span><span>specification: str, data: Union[dict, str, NoneType] = None, width: Union[str, NoneType] = None, height: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Vega-lite plot for display inside a form.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VegaVisualization:
    &#34;&#34;&#34;Create a Vega-lite plot for display inside a form.
    &#34;&#34;&#34;
    def __init__(
            self,
            specification: str,
            data: Optional[PackedRecord] = None,
            width: Optional[str] = None,
            height: Optional[str] = None,
    ):
        self.specification = specification
        &#34;&#34;&#34;The Vega-lite specification.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for the plot, if any.&#34;&#34;&#34;
        self.width = width
        &#34;&#34;&#34;The width of the visualization. Defaults to 100%.&#34;&#34;&#34;
        self.height = height
        &#34;&#34;&#34;The height of the visualization. Defaults to 300px.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.specification is None:
            raise ValueError(&#39;VegaVisualization.specification is required.&#39;)
        return _dump(
            specification=self.specification,
            data=self.data,
            width=self.width,
            height=self.height,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;VegaVisualization&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_specification: Any = __d.get(&#39;specification&#39;)
        if __d_specification is None:
            raise ValueError(&#39;VegaVisualization.specification is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_width: Any = __d.get(&#39;width&#39;)
        __d_height: Any = __d.get(&#39;height&#39;)
        specification: str = __d_specification
        data: Optional[PackedRecord] = __d_data
        width: Optional[str] = __d_width
        height: Optional[str] = __d_height
        return VegaVisualization(
            specification,
            data,
            width,
            height,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.VegaVisualization.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_VegaVisualization__d: Dict) ‑> <a title="h2o_q.types.VegaVisualization" href="#h2o_q.types.VegaVisualization">VegaVisualization</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;VegaVisualization&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_specification: Any = __d.get(&#39;specification&#39;)
    if __d_specification is None:
        raise ValueError(&#39;VegaVisualization.specification is required.&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    __d_width: Any = __d.get(&#39;width&#39;)
    __d_height: Any = __d.get(&#39;height&#39;)
    specification: str = __d_specification
    data: Optional[PackedRecord] = __d_data
    width: Optional[str] = __d_width
    height: Optional[str] = __d_height
    return VegaVisualization(
        specification,
        data,
        width,
        height,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.VegaVisualization.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Data for the plot, if any.</p></div>
</dd>
<dt id="h2o_q.types.VegaVisualization.height"><code class="name">var <span class="ident">height</span></code></dt>
<dd>
<div class="desc"><p>The height of the visualization. Defaults to 300px.</p></div>
</dd>
<dt id="h2o_q.types.VegaVisualization.specification"><code class="name">var <span class="ident">specification</span></code></dt>
<dd>
<div class="desc"><p>The Vega-lite specification.</p></div>
</dd>
<dt id="h2o_q.types.VegaVisualization.width"><code class="name">var <span class="ident">width</span></code></dt>
<dd>
<div class="desc"><p>The width of the visualization. Defaults to 100%.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.VegaVisualization.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.specification is None:
        raise ValueError(&#39;VegaVisualization.specification is required.&#39;)
    return _dump(
        specification=self.specification,
        data=self.data,
        width=self.width,
        height=self.height,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.Visualization"><code class="flex name class">
<span>class <span class="ident">Visualization</span></span>
<span>(</span><span>plot: <a title="h2o_q.types.Plot" href="#h2o_q.types.Plot">Plot</a>, data: Union[dict, str], width: Union[str, NoneType] = None, height: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a visualization for display inside a form.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Visualization:
    &#34;&#34;&#34;Create a visualization for display inside a form.
    &#34;&#34;&#34;
    def __init__(
            self,
            plot: Plot,
            data: PackedRecord,
            width: Optional[str] = None,
            height: Optional[str] = None,
    ):
        self.plot = plot
        &#34;&#34;&#34;The plot to be rendered in this visualization.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this visualization.&#34;&#34;&#34;
        self.width = width
        &#34;&#34;&#34;The width of the visualization. Defaults to 100%.&#34;&#34;&#34;
        self.height = height
        &#34;&#34;&#34;The height of the visualization. Defaults to 300px.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.plot is None:
            raise ValueError(&#39;Visualization.plot is required.&#39;)
        if self.data is None:
            raise ValueError(&#39;Visualization.data is required.&#39;)
        return _dump(
            plot=self.plot.dump(),
            data=self.data,
            width=self.width,
            height=self.height,
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;Visualization&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_plot: Any = __d.get(&#39;plot&#39;)
        if __d_plot is None:
            raise ValueError(&#39;Visualization.plot is required.&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        if __d_data is None:
            raise ValueError(&#39;Visualization.data is required.&#39;)
        __d_width: Any = __d.get(&#39;width&#39;)
        __d_height: Any = __d.get(&#39;height&#39;)
        plot: Plot = Plot.load(__d_plot)
        data: PackedRecord = __d_data
        width: Optional[str] = __d_width
        height: Optional[str] = __d_height
        return Visualization(
            plot,
            data,
            width,
            height,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.Visualization.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_Visualization__d: Dict) ‑> <a title="h2o_q.types.Visualization" href="#h2o_q.types.Visualization">Visualization</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;Visualization&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_plot: Any = __d.get(&#39;plot&#39;)
    if __d_plot is None:
        raise ValueError(&#39;Visualization.plot is required.&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    if __d_data is None:
        raise ValueError(&#39;Visualization.data is required.&#39;)
    __d_width: Any = __d.get(&#39;width&#39;)
    __d_height: Any = __d.get(&#39;height&#39;)
    plot: Plot = Plot.load(__d_plot)
    data: PackedRecord = __d_data
    width: Optional[str] = __d_width
    height: Optional[str] = __d_height
    return Visualization(
        plot,
        data,
        width,
        height,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.Visualization.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Data for this visualization.</p></div>
</dd>
<dt id="h2o_q.types.Visualization.height"><code class="name">var <span class="ident">height</span></code></dt>
<dd>
<div class="desc"><p>The height of the visualization. Defaults to 300px.</p></div>
</dd>
<dt id="h2o_q.types.Visualization.plot"><code class="name">var <span class="ident">plot</span></code></dt>
<dd>
<div class="desc"><p>The plot to be rendered in this visualization.</p></div>
</dd>
<dt id="h2o_q.types.Visualization.width"><code class="name">var <span class="ident">width</span></code></dt>
<dd>
<div class="desc"><p>The width of the visualization. Defaults to 100%.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.Visualization.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.plot is None:
        raise ValueError(&#39;Visualization.plot is required.&#39;)
    if self.data is None:
        raise ValueError(&#39;Visualization.data is required.&#39;)
    return _dump(
        plot=self.plot.dump(),
        data=self.data,
        width=self.width,
        height=self.height,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.WideBarStatCard"><code class="flex name class">
<span>class <span class="ident">WideBarStatCard</span></span>
<span>(</span><span>box: str, title: str, value: str, aux_value: str, progress: float, plot_color: Union[str, NoneType] = None, data: Union[dict, str, NoneType] = None, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a wide stat card displaying a primary value, an auxiliary value and a progress bar.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WideBarStatCard:
    &#34;&#34;&#34;Create a wide stat card displaying a primary value, an auxiliary value and a progress bar.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            value: str,
            aux_value: str,
            progress: float,
            plot_color: Optional[str] = None,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The card&#39;s title.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The primary value displayed.&#34;&#34;&#34;
        self.aux_value = aux_value
        &#34;&#34;&#34;The auxiliary value displayed next to the primary value.&#34;&#34;&#34;
        self.progress = progress
        &#34;&#34;&#34;The value of the progress bar, between 0 and 1.&#34;&#34;&#34;
        self.plot_color = plot_color
        &#34;&#34;&#34;The color of the progress bar.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;WideBarStatCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;WideBarStatCard.title is required.&#39;)
        if self.value is None:
            raise ValueError(&#39;WideBarStatCard.value is required.&#39;)
        if self.aux_value is None:
            raise ValueError(&#39;WideBarStatCard.aux_value is required.&#39;)
        if self.progress is None:
            raise ValueError(&#39;WideBarStatCard.progress is required.&#39;)
        return _dump(
            view=&#39;wide_bar_stat&#39;,
            box=self.box,
            title=self.title,
            value=self.value,
            aux_value=self.aux_value,
            progress=self.progress,
            plot_color=self.plot_color,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;WideBarStatCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;WideBarStatCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;WideBarStatCard.title is required.&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        if __d_value is None:
            raise ValueError(&#39;WideBarStatCard.value is required.&#39;)
        __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
        if __d_aux_value is None:
            raise ValueError(&#39;WideBarStatCard.aux_value is required.&#39;)
        __d_progress: Any = __d.get(&#39;progress&#39;)
        if __d_progress is None:
            raise ValueError(&#39;WideBarStatCard.progress is required.&#39;)
        __d_plot_color: Any = __d.get(&#39;plot_color&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        value: str = __d_value
        aux_value: str = __d_aux_value
        progress: float = __d_progress
        plot_color: Optional[str] = __d_plot_color
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return WideBarStatCard(
            box,
            title,
            value,
            aux_value,
            progress,
            plot_color,
            data,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.WideBarStatCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_WideBarStatCard__d: Dict) ‑> <a title="h2o_q.types.WideBarStatCard" href="#h2o_q.types.WideBarStatCard">WideBarStatCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;WideBarStatCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;WideBarStatCard.box is required.&#39;)
    __d_title: Any = __d.get(&#39;title&#39;)
    if __d_title is None:
        raise ValueError(&#39;WideBarStatCard.title is required.&#39;)
    __d_value: Any = __d.get(&#39;value&#39;)
    if __d_value is None:
        raise ValueError(&#39;WideBarStatCard.value is required.&#39;)
    __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
    if __d_aux_value is None:
        raise ValueError(&#39;WideBarStatCard.aux_value is required.&#39;)
    __d_progress: Any = __d.get(&#39;progress&#39;)
    if __d_progress is None:
        raise ValueError(&#39;WideBarStatCard.progress is required.&#39;)
    __d_plot_color: Any = __d.get(&#39;plot_color&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    title: str = __d_title
    value: str = __d_value
    aux_value: str = __d_aux_value
    progress: float = __d_progress
    plot_color: Optional[str] = __d_plot_color
    data: Optional[PackedRecord] = __d_data
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return WideBarStatCard(
        box,
        title,
        value,
        aux_value,
        progress,
        plot_color,
        data,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.WideBarStatCard.aux_value"><code class="name">var <span class="ident">aux_value</span></code></dt>
<dd>
<div class="desc"><p>The auxiliary value displayed next to the primary value.</p></div>
</dd>
<dt id="h2o_q.types.WideBarStatCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.WideBarStatCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.WideBarStatCard.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Data for this card.</p></div>
</dd>
<dt id="h2o_q.types.WideBarStatCard.plot_color"><code class="name">var <span class="ident">plot_color</span></code></dt>
<dd>
<div class="desc"><p>The color of the progress bar.</p></div>
</dd>
<dt id="h2o_q.types.WideBarStatCard.progress"><code class="name">var <span class="ident">progress</span></code></dt>
<dd>
<div class="desc"><p>The value of the progress bar, between 0 and 1.</p></div>
</dd>
<dt id="h2o_q.types.WideBarStatCard.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>The card's title.</p></div>
</dd>
<dt id="h2o_q.types.WideBarStatCard.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>The primary value displayed.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.WideBarStatCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;WideBarStatCard.box is required.&#39;)
    if self.title is None:
        raise ValueError(&#39;WideBarStatCard.title is required.&#39;)
    if self.value is None:
        raise ValueError(&#39;WideBarStatCard.value is required.&#39;)
    if self.aux_value is None:
        raise ValueError(&#39;WideBarStatCard.aux_value is required.&#39;)
    if self.progress is None:
        raise ValueError(&#39;WideBarStatCard.progress is required.&#39;)
    return _dump(
        view=&#39;wide_bar_stat&#39;,
        box=self.box,
        title=self.title,
        value=self.value,
        aux_value=self.aux_value,
        progress=self.progress,
        plot_color=self.plot_color,
        data=self.data,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.WideGaugeStatCard"><code class="flex name class">
<span>class <span class="ident">WideGaugeStatCard</span></span>
<span>(</span><span>box: str, title: str, value: str, aux_value: str, progress: float, plot_color: Union[str, NoneType] = None, data: Union[dict, str, NoneType] = None, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a wide stat card displaying a primary value, an auxiliary value and a progress gauge.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WideGaugeStatCard:
    &#34;&#34;&#34;Create a wide stat card displaying a primary value, an auxiliary value and a progress gauge.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            value: str,
            aux_value: str,
            progress: float,
            plot_color: Optional[str] = None,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The card&#39;s title.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The primary value displayed.&#34;&#34;&#34;
        self.aux_value = aux_value
        &#34;&#34;&#34;The auxiliary value displayed next to the primary value.&#34;&#34;&#34;
        self.progress = progress
        &#34;&#34;&#34;The value of the progress gauge, between 0 and 1.&#34;&#34;&#34;
        self.plot_color = plot_color
        &#34;&#34;&#34;The color of the progress gauge.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;WideGaugeStatCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;WideGaugeStatCard.title is required.&#39;)
        if self.value is None:
            raise ValueError(&#39;WideGaugeStatCard.value is required.&#39;)
        if self.aux_value is None:
            raise ValueError(&#39;WideGaugeStatCard.aux_value is required.&#39;)
        if self.progress is None:
            raise ValueError(&#39;WideGaugeStatCard.progress is required.&#39;)
        return _dump(
            view=&#39;wide_gauge_stat&#39;,
            box=self.box,
            title=self.title,
            value=self.value,
            aux_value=self.aux_value,
            progress=self.progress,
            plot_color=self.plot_color,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;WideGaugeStatCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;WideGaugeStatCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;WideGaugeStatCard.title is required.&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        if __d_value is None:
            raise ValueError(&#39;WideGaugeStatCard.value is required.&#39;)
        __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
        if __d_aux_value is None:
            raise ValueError(&#39;WideGaugeStatCard.aux_value is required.&#39;)
        __d_progress: Any = __d.get(&#39;progress&#39;)
        if __d_progress is None:
            raise ValueError(&#39;WideGaugeStatCard.progress is required.&#39;)
        __d_plot_color: Any = __d.get(&#39;plot_color&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        value: str = __d_value
        aux_value: str = __d_aux_value
        progress: float = __d_progress
        plot_color: Optional[str] = __d_plot_color
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return WideGaugeStatCard(
            box,
            title,
            value,
            aux_value,
            progress,
            plot_color,
            data,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.WideGaugeStatCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_WideGaugeStatCard__d: Dict) ‑> <a title="h2o_q.types.WideGaugeStatCard" href="#h2o_q.types.WideGaugeStatCard">WideGaugeStatCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;WideGaugeStatCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;WideGaugeStatCard.box is required.&#39;)
    __d_title: Any = __d.get(&#39;title&#39;)
    if __d_title is None:
        raise ValueError(&#39;WideGaugeStatCard.title is required.&#39;)
    __d_value: Any = __d.get(&#39;value&#39;)
    if __d_value is None:
        raise ValueError(&#39;WideGaugeStatCard.value is required.&#39;)
    __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
    if __d_aux_value is None:
        raise ValueError(&#39;WideGaugeStatCard.aux_value is required.&#39;)
    __d_progress: Any = __d.get(&#39;progress&#39;)
    if __d_progress is None:
        raise ValueError(&#39;WideGaugeStatCard.progress is required.&#39;)
    __d_plot_color: Any = __d.get(&#39;plot_color&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    title: str = __d_title
    value: str = __d_value
    aux_value: str = __d_aux_value
    progress: float = __d_progress
    plot_color: Optional[str] = __d_plot_color
    data: Optional[PackedRecord] = __d_data
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return WideGaugeStatCard(
        box,
        title,
        value,
        aux_value,
        progress,
        plot_color,
        data,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.WideGaugeStatCard.aux_value"><code class="name">var <span class="ident">aux_value</span></code></dt>
<dd>
<div class="desc"><p>The auxiliary value displayed next to the primary value.</p></div>
</dd>
<dt id="h2o_q.types.WideGaugeStatCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.WideGaugeStatCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.WideGaugeStatCard.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Data for this card.</p></div>
</dd>
<dt id="h2o_q.types.WideGaugeStatCard.plot_color"><code class="name">var <span class="ident">plot_color</span></code></dt>
<dd>
<div class="desc"><p>The color of the progress gauge.</p></div>
</dd>
<dt id="h2o_q.types.WideGaugeStatCard.progress"><code class="name">var <span class="ident">progress</span></code></dt>
<dd>
<div class="desc"><p>The value of the progress gauge, between 0 and 1.</p></div>
</dd>
<dt id="h2o_q.types.WideGaugeStatCard.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>The card's title.</p></div>
</dd>
<dt id="h2o_q.types.WideGaugeStatCard.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>The primary value displayed.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.WideGaugeStatCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;WideGaugeStatCard.box is required.&#39;)
    if self.title is None:
        raise ValueError(&#39;WideGaugeStatCard.title is required.&#39;)
    if self.value is None:
        raise ValueError(&#39;WideGaugeStatCard.value is required.&#39;)
    if self.aux_value is None:
        raise ValueError(&#39;WideGaugeStatCard.aux_value is required.&#39;)
    if self.progress is None:
        raise ValueError(&#39;WideGaugeStatCard.progress is required.&#39;)
    return _dump(
        view=&#39;wide_gauge_stat&#39;,
        box=self.box,
        title=self.title,
        value=self.value,
        aux_value=self.aux_value,
        progress=self.progress,
        plot_color=self.plot_color,
        data=self.data,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="h2o_q.types.WideSeriesStatCard"><code class="flex name class">
<span>class <span class="ident">WideSeriesStatCard</span></span>
<span>(</span><span>box: str, title: str, value: str, aux_value: str, plot_data: Union[<a title="h2o_q.core.Data" href="core.html#h2o_q.core.Data">Data</a>, str], plot_value: str, plot_zero_value: Union[float, NoneType] = None, plot_category: Union[str, NoneType] = None, plot_type: Union[str, NoneType] = None, plot_curve: Union[str, NoneType] = None, plot_color: Union[str, NoneType] = None, data: Union[dict, str, NoneType] = None, commands: Union[List[<a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a>], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a wide stat card displaying a primary value, an auxiliary value and a series plot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WideSeriesStatCard:
    &#34;&#34;&#34;Create a wide stat card displaying a primary value, an auxiliary value and a series plot.
    &#34;&#34;&#34;
    def __init__(
            self,
            box: str,
            title: str,
            value: str,
            aux_value: str,
            plot_data: PackedData,
            plot_value: str,
            plot_zero_value: Optional[float] = None,
            plot_category: Optional[str] = None,
            plot_type: Optional[str] = None,
            plot_curve: Optional[str] = None,
            plot_color: Optional[str] = None,
            data: Optional[PackedRecord] = None,
            commands: Optional[List[Command]] = None,
    ):
        self.box = box
        &#34;&#34;&#34;A string indicating how to place this component on the page.&#34;&#34;&#34;
        self.title = title
        &#34;&#34;&#34;The card&#39;s title.&#34;&#34;&#34;
        self.value = value
        &#34;&#34;&#34;The primary value displayed.&#34;&#34;&#34;
        self.aux_value = aux_value
        &#34;&#34;&#34;The auxiliary value displayed below the primary value.&#34;&#34;&#34;
        self.plot_data = plot_data
        &#34;&#34;&#34;The plot&#39;s data.&#34;&#34;&#34;
        self.plot_value = plot_value
        &#34;&#34;&#34;The data field to use for y-axis values.&#34;&#34;&#34;
        self.plot_zero_value = plot_zero_value
        &#34;&#34;&#34;The base value to use for each y-axis mark. Set this to `0` if you want to pin the x-axis at `y=0`. If not provided, the minimum value from the data is used.&#34;&#34;&#34;
        self.plot_category = plot_category
        &#34;&#34;&#34;The data field to use for x-axis values (ignored if `plot_type` is `area`; must be provided if `plot_type` is `interval`). Defaults to &#39;x&#39;.&#34;&#34;&#34;
        self.plot_type = plot_type
        &#34;&#34;&#34;The type of plot. Defaults to `area`. One of &#39;area&#39;, &#39;interval&#39;.&#34;&#34;&#34;
        self.plot_curve = plot_curve
        &#34;&#34;&#34;The plot&#39;s curve style. Defaults to `linear`. One of &#39;linear&#39;, &#39;smooth&#39;, &#39;step&#39;, &#39;step-after&#39;, &#39;step-before&#39;.&#34;&#34;&#34;
        self.plot_color = plot_color
        &#34;&#34;&#34;The plot&#39;s color.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for this card.&#34;&#34;&#34;
        self.commands = commands
        &#34;&#34;&#34;Contextual menu commands for this component.&#34;&#34;&#34;

    def dump(self) -&gt; Dict:
        &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
        if self.box is None:
            raise ValueError(&#39;WideSeriesStatCard.box is required.&#39;)
        if self.title is None:
            raise ValueError(&#39;WideSeriesStatCard.title is required.&#39;)
        if self.value is None:
            raise ValueError(&#39;WideSeriesStatCard.value is required.&#39;)
        if self.aux_value is None:
            raise ValueError(&#39;WideSeriesStatCard.aux_value is required.&#39;)
        if self.plot_data is None:
            raise ValueError(&#39;WideSeriesStatCard.plot_data is required.&#39;)
        if self.plot_value is None:
            raise ValueError(&#39;WideSeriesStatCard.plot_value is required.&#39;)
        return _dump(
            view=&#39;wide_series_stat&#39;,
            box=self.box,
            title=self.title,
            value=self.value,
            aux_value=self.aux_value,
            plot_data=self.plot_data,
            plot_value=self.plot_value,
            plot_zero_value=self.plot_zero_value,
            plot_category=self.plot_category,
            plot_type=self.plot_type,
            plot_curve=self.plot_curve,
            plot_color=self.plot_color,
            data=self.data,
            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
        )

    @staticmethod
    def load(__d: Dict) -&gt; &#39;WideSeriesStatCard&#39;:
        &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
        __d_box: Any = __d.get(&#39;box&#39;)
        if __d_box is None:
            raise ValueError(&#39;WideSeriesStatCard.box is required.&#39;)
        __d_title: Any = __d.get(&#39;title&#39;)
        if __d_title is None:
            raise ValueError(&#39;WideSeriesStatCard.title is required.&#39;)
        __d_value: Any = __d.get(&#39;value&#39;)
        if __d_value is None:
            raise ValueError(&#39;WideSeriesStatCard.value is required.&#39;)
        __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
        if __d_aux_value is None:
            raise ValueError(&#39;WideSeriesStatCard.aux_value is required.&#39;)
        __d_plot_data: Any = __d.get(&#39;plot_data&#39;)
        if __d_plot_data is None:
            raise ValueError(&#39;WideSeriesStatCard.plot_data is required.&#39;)
        __d_plot_value: Any = __d.get(&#39;plot_value&#39;)
        if __d_plot_value is None:
            raise ValueError(&#39;WideSeriesStatCard.plot_value is required.&#39;)
        __d_plot_zero_value: Any = __d.get(&#39;plot_zero_value&#39;)
        __d_plot_category: Any = __d.get(&#39;plot_category&#39;)
        __d_plot_type: Any = __d.get(&#39;plot_type&#39;)
        __d_plot_curve: Any = __d.get(&#39;plot_curve&#39;)
        __d_plot_color: Any = __d.get(&#39;plot_color&#39;)
        __d_data: Any = __d.get(&#39;data&#39;)
        __d_commands: Any = __d.get(&#39;commands&#39;)
        box: str = __d_box
        title: str = __d_title
        value: str = __d_value
        aux_value: str = __d_aux_value
        plot_data: PackedData = __d_plot_data
        plot_value: str = __d_plot_value
        plot_zero_value: Optional[float] = __d_plot_zero_value
        plot_category: Optional[str] = __d_plot_category
        plot_type: Optional[str] = __d_plot_type
        plot_curve: Optional[str] = __d_plot_curve
        plot_color: Optional[str] = __d_plot_color
        data: Optional[PackedRecord] = __d_data
        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
        return WideSeriesStatCard(
            box,
            title,
            value,
            aux_value,
            plot_data,
            plot_value,
            plot_zero_value,
            plot_category,
            plot_type,
            plot_curve,
            plot_color,
            data,
            commands,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="h2o_q.types.WideSeriesStatCard.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>_WideSeriesStatCard__d: Dict) ‑> <a title="h2o_q.types.WideSeriesStatCard" href="#h2o_q.types.WideSeriesStatCard">WideSeriesStatCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of this class using the contents of a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(__d: Dict) -&gt; &#39;WideSeriesStatCard&#39;:
    &#34;&#34;&#34;Creates an instance of this class using the contents of a dict.&#34;&#34;&#34;
    __d_box: Any = __d.get(&#39;box&#39;)
    if __d_box is None:
        raise ValueError(&#39;WideSeriesStatCard.box is required.&#39;)
    __d_title: Any = __d.get(&#39;title&#39;)
    if __d_title is None:
        raise ValueError(&#39;WideSeriesStatCard.title is required.&#39;)
    __d_value: Any = __d.get(&#39;value&#39;)
    if __d_value is None:
        raise ValueError(&#39;WideSeriesStatCard.value is required.&#39;)
    __d_aux_value: Any = __d.get(&#39;aux_value&#39;)
    if __d_aux_value is None:
        raise ValueError(&#39;WideSeriesStatCard.aux_value is required.&#39;)
    __d_plot_data: Any = __d.get(&#39;plot_data&#39;)
    if __d_plot_data is None:
        raise ValueError(&#39;WideSeriesStatCard.plot_data is required.&#39;)
    __d_plot_value: Any = __d.get(&#39;plot_value&#39;)
    if __d_plot_value is None:
        raise ValueError(&#39;WideSeriesStatCard.plot_value is required.&#39;)
    __d_plot_zero_value: Any = __d.get(&#39;plot_zero_value&#39;)
    __d_plot_category: Any = __d.get(&#39;plot_category&#39;)
    __d_plot_type: Any = __d.get(&#39;plot_type&#39;)
    __d_plot_curve: Any = __d.get(&#39;plot_curve&#39;)
    __d_plot_color: Any = __d.get(&#39;plot_color&#39;)
    __d_data: Any = __d.get(&#39;data&#39;)
    __d_commands: Any = __d.get(&#39;commands&#39;)
    box: str = __d_box
    title: str = __d_title
    value: str = __d_value
    aux_value: str = __d_aux_value
    plot_data: PackedData = __d_plot_data
    plot_value: str = __d_plot_value
    plot_zero_value: Optional[float] = __d_plot_zero_value
    plot_category: Optional[str] = __d_plot_category
    plot_type: Optional[str] = __d_plot_type
    plot_curve: Optional[str] = __d_plot_curve
    plot_color: Optional[str] = __d_plot_color
    data: Optional[PackedRecord] = __d_data
    commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
    return WideSeriesStatCard(
        box,
        title,
        value,
        aux_value,
        plot_data,
        plot_value,
        plot_zero_value,
        plot_category,
        plot_type,
        plot_curve,
        plot_color,
        data,
        commands,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="h2o_q.types.WideSeriesStatCard.aux_value"><code class="name">var <span class="ident">aux_value</span></code></dt>
<dd>
<div class="desc"><p>The auxiliary value displayed below the primary value.</p></div>
</dd>
<dt id="h2o_q.types.WideSeriesStatCard.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<div class="desc"><p>A string indicating how to place this component on the page.</p></div>
</dd>
<dt id="h2o_q.types.WideSeriesStatCard.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"><p>Contextual menu commands for this component.</p></div>
</dd>
<dt id="h2o_q.types.WideSeriesStatCard.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Data for this card.</p></div>
</dd>
<dt id="h2o_q.types.WideSeriesStatCard.plot_category"><code class="name">var <span class="ident">plot_category</span></code></dt>
<dd>
<div class="desc"><p>The data field to use for x-axis values (ignored if <code>plot_type</code> is <code>area</code>; must be provided if <code>plot_type</code> is <code>interval</code>). Defaults to 'x'.</p></div>
</dd>
<dt id="h2o_q.types.WideSeriesStatCard.plot_color"><code class="name">var <span class="ident">plot_color</span></code></dt>
<dd>
<div class="desc"><p>The plot's color.</p></div>
</dd>
<dt id="h2o_q.types.WideSeriesStatCard.plot_curve"><code class="name">var <span class="ident">plot_curve</span></code></dt>
<dd>
<div class="desc"><p>The plot's curve style. Defaults to <code>linear</code>. One of 'linear', 'smooth', 'step', 'step-after', 'step-before'.</p></div>
</dd>
<dt id="h2o_q.types.WideSeriesStatCard.plot_data"><code class="name">var <span class="ident">plot_data</span></code></dt>
<dd>
<div class="desc"><p>The plot's data.</p></div>
</dd>
<dt id="h2o_q.types.WideSeriesStatCard.plot_type"><code class="name">var <span class="ident">plot_type</span></code></dt>
<dd>
<div class="desc"><p>The type of plot. Defaults to <code>area</code>. One of 'area', 'interval'.</p></div>
</dd>
<dt id="h2o_q.types.WideSeriesStatCard.plot_value"><code class="name">var <span class="ident">plot_value</span></code></dt>
<dd>
<div class="desc"><p>The data field to use for y-axis values.</p></div>
</dd>
<dt id="h2o_q.types.WideSeriesStatCard.plot_zero_value"><code class="name">var <span class="ident">plot_zero_value</span></code></dt>
<dd>
<div class="desc"><p>The base value to use for each y-axis mark. Set this to <code>0</code> if you want to pin the x-axis at <code>y=0</code>. If not provided, the minimum value from the data is used.</p></div>
</dd>
<dt id="h2o_q.types.WideSeriesStatCard.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>The card's title.</p></div>
</dd>
<dt id="h2o_q.types.WideSeriesStatCard.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>The primary value displayed.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="h2o_q.types.WideSeriesStatCard.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the contents of this object as a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; Dict:
    &#34;&#34;&#34;Returns the contents of this object as a dict.&#34;&#34;&#34;
    if self.box is None:
        raise ValueError(&#39;WideSeriesStatCard.box is required.&#39;)
    if self.title is None:
        raise ValueError(&#39;WideSeriesStatCard.title is required.&#39;)
    if self.value is None:
        raise ValueError(&#39;WideSeriesStatCard.value is required.&#39;)
    if self.aux_value is None:
        raise ValueError(&#39;WideSeriesStatCard.aux_value is required.&#39;)
    if self.plot_data is None:
        raise ValueError(&#39;WideSeriesStatCard.plot_data is required.&#39;)
    if self.plot_value is None:
        raise ValueError(&#39;WideSeriesStatCard.plot_value is required.&#39;)
    return _dump(
        view=&#39;wide_series_stat&#39;,
        box=self.box,
        title=self.title,
        value=self.value,
        aux_value=self.aux_value,
        plot_data=self.plot_data,
        plot_value=self.plot_value,
        plot_zero_value=self.plot_zero_value,
        plot_category=self.plot_category,
        plot_type=self.plot_type,
        plot_curve=self.plot_curve,
        plot_color=self.plot_color,
        data=self.data,
        commands=None if self.commands is None else [__e.dump() for __e in self.commands],
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<img class='logo' src='https://h2oai.github.io/qd/q.png'/>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="h2o_q" href="index.html">h2o_q</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="h2o_q.types.Breadcrumb" href="#h2o_q.types.Breadcrumb">Breadcrumb</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.Breadcrumb.dump" href="#h2o_q.types.Breadcrumb.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Breadcrumb.label" href="#h2o_q.types.Breadcrumb.label">label</a></code></li>
<li><code><a title="h2o_q.types.Breadcrumb.load" href="#h2o_q.types.Breadcrumb.load">load</a></code></li>
<li><code><a title="h2o_q.types.Breadcrumb.name" href="#h2o_q.types.Breadcrumb.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.BreadcrumbsCard" href="#h2o_q.types.BreadcrumbsCard">BreadcrumbsCard</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.BreadcrumbsCard.box" href="#h2o_q.types.BreadcrumbsCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.BreadcrumbsCard.commands" href="#h2o_q.types.BreadcrumbsCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.BreadcrumbsCard.dump" href="#h2o_q.types.BreadcrumbsCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.BreadcrumbsCard.items" href="#h2o_q.types.BreadcrumbsCard.items">items</a></code></li>
<li><code><a title="h2o_q.types.BreadcrumbsCard.load" href="#h2o_q.types.BreadcrumbsCard.load">load</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Button" href="#h2o_q.types.Button">Button</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.Button.caption" href="#h2o_q.types.Button.caption">caption</a></code></li>
<li><code><a title="h2o_q.types.Button.disabled" href="#h2o_q.types.Button.disabled">disabled</a></code></li>
<li><code><a title="h2o_q.types.Button.dump" href="#h2o_q.types.Button.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Button.label" href="#h2o_q.types.Button.label">label</a></code></li>
<li><code><a title="h2o_q.types.Button.link" href="#h2o_q.types.Button.link">link</a></code></li>
<li><code><a title="h2o_q.types.Button.load" href="#h2o_q.types.Button.load">load</a></code></li>
<li><code><a title="h2o_q.types.Button.name" href="#h2o_q.types.Button.name">name</a></code></li>
<li><code><a title="h2o_q.types.Button.primary" href="#h2o_q.types.Button.primary">primary</a></code></li>
<li><code><a title="h2o_q.types.Button.tooltip" href="#h2o_q.types.Button.tooltip">tooltip</a></code></li>
<li><code><a title="h2o_q.types.Button.value" href="#h2o_q.types.Button.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Buttons" href="#h2o_q.types.Buttons">Buttons</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.Buttons.dump" href="#h2o_q.types.Buttons.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Buttons.items" href="#h2o_q.types.Buttons.items">items</a></code></li>
<li><code><a title="h2o_q.types.Buttons.load" href="#h2o_q.types.Buttons.load">load</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Checkbox" href="#h2o_q.types.Checkbox">Checkbox</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.Checkbox.disabled" href="#h2o_q.types.Checkbox.disabled">disabled</a></code></li>
<li><code><a title="h2o_q.types.Checkbox.dump" href="#h2o_q.types.Checkbox.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Checkbox.indeterminate" href="#h2o_q.types.Checkbox.indeterminate">indeterminate</a></code></li>
<li><code><a title="h2o_q.types.Checkbox.label" href="#h2o_q.types.Checkbox.label">label</a></code></li>
<li><code><a title="h2o_q.types.Checkbox.load" href="#h2o_q.types.Checkbox.load">load</a></code></li>
<li><code><a title="h2o_q.types.Checkbox.name" href="#h2o_q.types.Checkbox.name">name</a></code></li>
<li><code><a title="h2o_q.types.Checkbox.tooltip" href="#h2o_q.types.Checkbox.tooltip">tooltip</a></code></li>
<li><code><a title="h2o_q.types.Checkbox.trigger" href="#h2o_q.types.Checkbox.trigger">trigger</a></code></li>
<li><code><a title="h2o_q.types.Checkbox.value" href="#h2o_q.types.Checkbox.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Checklist" href="#h2o_q.types.Checklist">Checklist</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.Checklist.choices" href="#h2o_q.types.Checklist.choices">choices</a></code></li>
<li><code><a title="h2o_q.types.Checklist.dump" href="#h2o_q.types.Checklist.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Checklist.label" href="#h2o_q.types.Checklist.label">label</a></code></li>
<li><code><a title="h2o_q.types.Checklist.load" href="#h2o_q.types.Checklist.load">load</a></code></li>
<li><code><a title="h2o_q.types.Checklist.name" href="#h2o_q.types.Checklist.name">name</a></code></li>
<li><code><a title="h2o_q.types.Checklist.tooltip" href="#h2o_q.types.Checklist.tooltip">tooltip</a></code></li>
<li><code><a title="h2o_q.types.Checklist.trigger" href="#h2o_q.types.Checklist.trigger">trigger</a></code></li>
<li><code><a title="h2o_q.types.Checklist.values" href="#h2o_q.types.Checklist.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Choice" href="#h2o_q.types.Choice">Choice</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.Choice.disabled" href="#h2o_q.types.Choice.disabled">disabled</a></code></li>
<li><code><a title="h2o_q.types.Choice.dump" href="#h2o_q.types.Choice.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Choice.label" href="#h2o_q.types.Choice.label">label</a></code></li>
<li><code><a title="h2o_q.types.Choice.load" href="#h2o_q.types.Choice.load">load</a></code></li>
<li><code><a title="h2o_q.types.Choice.name" href="#h2o_q.types.Choice.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.ChoiceGroup" href="#h2o_q.types.ChoiceGroup">ChoiceGroup</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.ChoiceGroup.choices" href="#h2o_q.types.ChoiceGroup.choices">choices</a></code></li>
<li><code><a title="h2o_q.types.ChoiceGroup.dump" href="#h2o_q.types.ChoiceGroup.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.ChoiceGroup.label" href="#h2o_q.types.ChoiceGroup.label">label</a></code></li>
<li><code><a title="h2o_q.types.ChoiceGroup.load" href="#h2o_q.types.ChoiceGroup.load">load</a></code></li>
<li><code><a title="h2o_q.types.ChoiceGroup.name" href="#h2o_q.types.ChoiceGroup.name">name</a></code></li>
<li><code><a title="h2o_q.types.ChoiceGroup.required" href="#h2o_q.types.ChoiceGroup.required">required</a></code></li>
<li><code><a title="h2o_q.types.ChoiceGroup.tooltip" href="#h2o_q.types.ChoiceGroup.tooltip">tooltip</a></code></li>
<li><code><a title="h2o_q.types.ChoiceGroup.trigger" href="#h2o_q.types.ChoiceGroup.trigger">trigger</a></code></li>
<li><code><a title="h2o_q.types.ChoiceGroup.value" href="#h2o_q.types.ChoiceGroup.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.ColorPicker" href="#h2o_q.types.ColorPicker">ColorPicker</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.ColorPicker.choices" href="#h2o_q.types.ColorPicker.choices">choices</a></code></li>
<li><code><a title="h2o_q.types.ColorPicker.dump" href="#h2o_q.types.ColorPicker.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.ColorPicker.label" href="#h2o_q.types.ColorPicker.label">label</a></code></li>
<li><code><a title="h2o_q.types.ColorPicker.load" href="#h2o_q.types.ColorPicker.load">load</a></code></li>
<li><code><a title="h2o_q.types.ColorPicker.name" href="#h2o_q.types.ColorPicker.name">name</a></code></li>
<li><code><a title="h2o_q.types.ColorPicker.tooltip" href="#h2o_q.types.ColorPicker.tooltip">tooltip</a></code></li>
<li><code><a title="h2o_q.types.ColorPicker.value" href="#h2o_q.types.ColorPicker.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Combobox" href="#h2o_q.types.Combobox">Combobox</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.Combobox.choices" href="#h2o_q.types.Combobox.choices">choices</a></code></li>
<li><code><a title="h2o_q.types.Combobox.disabled" href="#h2o_q.types.Combobox.disabled">disabled</a></code></li>
<li><code><a title="h2o_q.types.Combobox.dump" href="#h2o_q.types.Combobox.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Combobox.error" href="#h2o_q.types.Combobox.error">error</a></code></li>
<li><code><a title="h2o_q.types.Combobox.label" href="#h2o_q.types.Combobox.label">label</a></code></li>
<li><code><a title="h2o_q.types.Combobox.load" href="#h2o_q.types.Combobox.load">load</a></code></li>
<li><code><a title="h2o_q.types.Combobox.name" href="#h2o_q.types.Combobox.name">name</a></code></li>
<li><code><a title="h2o_q.types.Combobox.placeholder" href="#h2o_q.types.Combobox.placeholder">placeholder</a></code></li>
<li><code><a title="h2o_q.types.Combobox.tooltip" href="#h2o_q.types.Combobox.tooltip">tooltip</a></code></li>
<li><code><a title="h2o_q.types.Combobox.value" href="#h2o_q.types.Combobox.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Command" href="#h2o_q.types.Command">Command</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.Command.caption" href="#h2o_q.types.Command.caption">caption</a></code></li>
<li><code><a title="h2o_q.types.Command.data" href="#h2o_q.types.Command.data">data</a></code></li>
<li><code><a title="h2o_q.types.Command.dump" href="#h2o_q.types.Command.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Command.icon" href="#h2o_q.types.Command.icon">icon</a></code></li>
<li><code><a title="h2o_q.types.Command.items" href="#h2o_q.types.Command.items">items</a></code></li>
<li><code><a title="h2o_q.types.Command.label" href="#h2o_q.types.Command.label">label</a></code></li>
<li><code><a title="h2o_q.types.Command.load" href="#h2o_q.types.Command.load">load</a></code></li>
<li><code><a title="h2o_q.types.Command.name" href="#h2o_q.types.Command.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Component" href="#h2o_q.types.Component">Component</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.Component.button" href="#h2o_q.types.Component.button">button</a></code></li>
<li><code><a title="h2o_q.types.Component.buttons" href="#h2o_q.types.Component.buttons">buttons</a></code></li>
<li><code><a title="h2o_q.types.Component.checkbox" href="#h2o_q.types.Component.checkbox">checkbox</a></code></li>
<li><code><a title="h2o_q.types.Component.checklist" href="#h2o_q.types.Component.checklist">checklist</a></code></li>
<li><code><a title="h2o_q.types.Component.choice_group" href="#h2o_q.types.Component.choice_group">choice_group</a></code></li>
<li><code><a title="h2o_q.types.Component.color_picker" href="#h2o_q.types.Component.color_picker">color_picker</a></code></li>
<li><code><a title="h2o_q.types.Component.combobox" href="#h2o_q.types.Component.combobox">combobox</a></code></li>
<li><code><a title="h2o_q.types.Component.date_picker" href="#h2o_q.types.Component.date_picker">date_picker</a></code></li>
<li><code><a title="h2o_q.types.Component.dropdown" href="#h2o_q.types.Component.dropdown">dropdown</a></code></li>
<li><code><a title="h2o_q.types.Component.dump" href="#h2o_q.types.Component.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Component.expander" href="#h2o_q.types.Component.expander">expander</a></code></li>
<li><code><a title="h2o_q.types.Component.file_upload" href="#h2o_q.types.Component.file_upload">file_upload</a></code></li>
<li><code><a title="h2o_q.types.Component.frame" href="#h2o_q.types.Component.frame">frame</a></code></li>
<li><code><a title="h2o_q.types.Component.label" href="#h2o_q.types.Component.label">label</a></code></li>
<li><code><a title="h2o_q.types.Component.link" href="#h2o_q.types.Component.link">link</a></code></li>
<li><code><a title="h2o_q.types.Component.load" href="#h2o_q.types.Component.load">load</a></code></li>
<li><code><a title="h2o_q.types.Component.markup" href="#h2o_q.types.Component.markup">markup</a></code></li>
<li><code><a title="h2o_q.types.Component.message_bar" href="#h2o_q.types.Component.message_bar">message_bar</a></code></li>
<li><code><a title="h2o_q.types.Component.picker" href="#h2o_q.types.Component.picker">picker</a></code></li>
<li><code><a title="h2o_q.types.Component.progress" href="#h2o_q.types.Component.progress">progress</a></code></li>
<li><code><a title="h2o_q.types.Component.range_slider" href="#h2o_q.types.Component.range_slider">range_slider</a></code></li>
<li><code><a title="h2o_q.types.Component.separator" href="#h2o_q.types.Component.separator">separator</a></code></li>
<li><code><a title="h2o_q.types.Component.slider" href="#h2o_q.types.Component.slider">slider</a></code></li>
<li><code><a title="h2o_q.types.Component.spinbox" href="#h2o_q.types.Component.spinbox">spinbox</a></code></li>
<li><code><a title="h2o_q.types.Component.stepper" href="#h2o_q.types.Component.stepper">stepper</a></code></li>
<li><code><a title="h2o_q.types.Component.table" href="#h2o_q.types.Component.table">table</a></code></li>
<li><code><a title="h2o_q.types.Component.tabs" href="#h2o_q.types.Component.tabs">tabs</a></code></li>
<li><code><a title="h2o_q.types.Component.template" href="#h2o_q.types.Component.template">template</a></code></li>
<li><code><a title="h2o_q.types.Component.text" href="#h2o_q.types.Component.text">text</a></code></li>
<li><code><a title="h2o_q.types.Component.text_l" href="#h2o_q.types.Component.text_l">text_l</a></code></li>
<li><code><a title="h2o_q.types.Component.text_m" href="#h2o_q.types.Component.text_m">text_m</a></code></li>
<li><code><a title="h2o_q.types.Component.text_s" href="#h2o_q.types.Component.text_s">text_s</a></code></li>
<li><code><a title="h2o_q.types.Component.text_xl" href="#h2o_q.types.Component.text_xl">text_xl</a></code></li>
<li><code><a title="h2o_q.types.Component.text_xs" href="#h2o_q.types.Component.text_xs">text_xs</a></code></li>
<li><code><a title="h2o_q.types.Component.textbox" href="#h2o_q.types.Component.textbox">textbox</a></code></li>
<li><code><a title="h2o_q.types.Component.toggle" href="#h2o_q.types.Component.toggle">toggle</a></code></li>
<li><code><a title="h2o_q.types.Component.vega_visualization" href="#h2o_q.types.Component.vega_visualization">vega_visualization</a></code></li>
<li><code><a title="h2o_q.types.Component.visualization" href="#h2o_q.types.Component.visualization">visualization</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.DatePicker" href="#h2o_q.types.DatePicker">DatePicker</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.DatePicker.disabled" href="#h2o_q.types.DatePicker.disabled">disabled</a></code></li>
<li><code><a title="h2o_q.types.DatePicker.dump" href="#h2o_q.types.DatePicker.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.DatePicker.label" href="#h2o_q.types.DatePicker.label">label</a></code></li>
<li><code><a title="h2o_q.types.DatePicker.load" href="#h2o_q.types.DatePicker.load">load</a></code></li>
<li><code><a title="h2o_q.types.DatePicker.name" href="#h2o_q.types.DatePicker.name">name</a></code></li>
<li><code><a title="h2o_q.types.DatePicker.placeholder" href="#h2o_q.types.DatePicker.placeholder">placeholder</a></code></li>
<li><code><a title="h2o_q.types.DatePicker.tooltip" href="#h2o_q.types.DatePicker.tooltip">tooltip</a></code></li>
<li><code><a title="h2o_q.types.DatePicker.value" href="#h2o_q.types.DatePicker.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Dropdown" href="#h2o_q.types.Dropdown">Dropdown</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.Dropdown.choices" href="#h2o_q.types.Dropdown.choices">choices</a></code></li>
<li><code><a title="h2o_q.types.Dropdown.disabled" href="#h2o_q.types.Dropdown.disabled">disabled</a></code></li>
<li><code><a title="h2o_q.types.Dropdown.dump" href="#h2o_q.types.Dropdown.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Dropdown.label" href="#h2o_q.types.Dropdown.label">label</a></code></li>
<li><code><a title="h2o_q.types.Dropdown.load" href="#h2o_q.types.Dropdown.load">load</a></code></li>
<li><code><a title="h2o_q.types.Dropdown.name" href="#h2o_q.types.Dropdown.name">name</a></code></li>
<li><code><a title="h2o_q.types.Dropdown.placeholder" href="#h2o_q.types.Dropdown.placeholder">placeholder</a></code></li>
<li><code><a title="h2o_q.types.Dropdown.required" href="#h2o_q.types.Dropdown.required">required</a></code></li>
<li><code><a title="h2o_q.types.Dropdown.tooltip" href="#h2o_q.types.Dropdown.tooltip">tooltip</a></code></li>
<li><code><a title="h2o_q.types.Dropdown.trigger" href="#h2o_q.types.Dropdown.trigger">trigger</a></code></li>
<li><code><a title="h2o_q.types.Dropdown.value" href="#h2o_q.types.Dropdown.value">value</a></code></li>
<li><code><a title="h2o_q.types.Dropdown.values" href="#h2o_q.types.Dropdown.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Expander" href="#h2o_q.types.Expander">Expander</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.Expander.dump" href="#h2o_q.types.Expander.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Expander.expanded" href="#h2o_q.types.Expander.expanded">expanded</a></code></li>
<li><code><a title="h2o_q.types.Expander.items" href="#h2o_q.types.Expander.items">items</a></code></li>
<li><code><a title="h2o_q.types.Expander.label" href="#h2o_q.types.Expander.label">label</a></code></li>
<li><code><a title="h2o_q.types.Expander.load" href="#h2o_q.types.Expander.load">load</a></code></li>
<li><code><a title="h2o_q.types.Expander.name" href="#h2o_q.types.Expander.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.FileUpload" href="#h2o_q.types.FileUpload">FileUpload</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.FileUpload.dump" href="#h2o_q.types.FileUpload.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.FileUpload.file_extensions" href="#h2o_q.types.FileUpload.file_extensions">file_extensions</a></code></li>
<li><code><a title="h2o_q.types.FileUpload.label" href="#h2o_q.types.FileUpload.label">label</a></code></li>
<li><code><a title="h2o_q.types.FileUpload.load" href="#h2o_q.types.FileUpload.load">load</a></code></li>
<li><code><a title="h2o_q.types.FileUpload.max_file_size" href="#h2o_q.types.FileUpload.max_file_size">max_file_size</a></code></li>
<li><code><a title="h2o_q.types.FileUpload.max_size" href="#h2o_q.types.FileUpload.max_size">max_size</a></code></li>
<li><code><a title="h2o_q.types.FileUpload.multiple" href="#h2o_q.types.FileUpload.multiple">multiple</a></code></li>
<li><code><a title="h2o_q.types.FileUpload.name" href="#h2o_q.types.FileUpload.name">name</a></code></li>
<li><code><a title="h2o_q.types.FileUpload.tooltip" href="#h2o_q.types.FileUpload.tooltip">tooltip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.FlexCard" href="#h2o_q.types.FlexCard">FlexCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.FlexCard.align" href="#h2o_q.types.FlexCard.align">align</a></code></li>
<li><code><a title="h2o_q.types.FlexCard.box" href="#h2o_q.types.FlexCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.FlexCard.commands" href="#h2o_q.types.FlexCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.FlexCard.data" href="#h2o_q.types.FlexCard.data">data</a></code></li>
<li><code><a title="h2o_q.types.FlexCard.direction" href="#h2o_q.types.FlexCard.direction">direction</a></code></li>
<li><code><a title="h2o_q.types.FlexCard.dump" href="#h2o_q.types.FlexCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.FlexCard.item_props" href="#h2o_q.types.FlexCard.item_props">item_props</a></code></li>
<li><code><a title="h2o_q.types.FlexCard.item_view" href="#h2o_q.types.FlexCard.item_view">item_view</a></code></li>
<li><code><a title="h2o_q.types.FlexCard.justify" href="#h2o_q.types.FlexCard.justify">justify</a></code></li>
<li><code><a title="h2o_q.types.FlexCard.load" href="#h2o_q.types.FlexCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.FlexCard.wrap" href="#h2o_q.types.FlexCard.wrap">wrap</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.FormCard" href="#h2o_q.types.FormCard">FormCard</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.FormCard.box" href="#h2o_q.types.FormCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.FormCard.commands" href="#h2o_q.types.FormCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.FormCard.dump" href="#h2o_q.types.FormCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.FormCard.items" href="#h2o_q.types.FormCard.items">items</a></code></li>
<li><code><a title="h2o_q.types.FormCard.load" href="#h2o_q.types.FormCard.load">load</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Frame" href="#h2o_q.types.Frame">Frame</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.Frame.content" href="#h2o_q.types.Frame.content">content</a></code></li>
<li><code><a title="h2o_q.types.Frame.dump" href="#h2o_q.types.Frame.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Frame.height" href="#h2o_q.types.Frame.height">height</a></code></li>
<li><code><a title="h2o_q.types.Frame.load" href="#h2o_q.types.Frame.load">load</a></code></li>
<li><code><a title="h2o_q.types.Frame.path" href="#h2o_q.types.Frame.path">path</a></code></li>
<li><code><a title="h2o_q.types.Frame.width" href="#h2o_q.types.Frame.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.FrameCard" href="#h2o_q.types.FrameCard">FrameCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.FrameCard.box" href="#h2o_q.types.FrameCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.FrameCard.commands" href="#h2o_q.types.FrameCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.FrameCard.content" href="#h2o_q.types.FrameCard.content">content</a></code></li>
<li><code><a title="h2o_q.types.FrameCard.dump" href="#h2o_q.types.FrameCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.FrameCard.load" href="#h2o_q.types.FrameCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.FrameCard.path" href="#h2o_q.types.FrameCard.path">path</a></code></li>
<li><code><a title="h2o_q.types.FrameCard.title" href="#h2o_q.types.FrameCard.title">title</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.GraphicsCard" href="#h2o_q.types.GraphicsCard">GraphicsCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.GraphicsCard.box" href="#h2o_q.types.GraphicsCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.GraphicsCard.commands" href="#h2o_q.types.GraphicsCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.GraphicsCard.dump" href="#h2o_q.types.GraphicsCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.GraphicsCard.height" href="#h2o_q.types.GraphicsCard.height">height</a></code></li>
<li><code><a title="h2o_q.types.GraphicsCard.load" href="#h2o_q.types.GraphicsCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.GraphicsCard.scene" href="#h2o_q.types.GraphicsCard.scene">scene</a></code></li>
<li><code><a title="h2o_q.types.GraphicsCard.stage" href="#h2o_q.types.GraphicsCard.stage">stage</a></code></li>
<li><code><a title="h2o_q.types.GraphicsCard.view_box" href="#h2o_q.types.GraphicsCard.view_box">view_box</a></code></li>
<li><code><a title="h2o_q.types.GraphicsCard.width" href="#h2o_q.types.GraphicsCard.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.GridCard" href="#h2o_q.types.GridCard">GridCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.GridCard.box" href="#h2o_q.types.GridCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.GridCard.cells" href="#h2o_q.types.GridCard.cells">cells</a></code></li>
<li><code><a title="h2o_q.types.GridCard.commands" href="#h2o_q.types.GridCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.GridCard.data" href="#h2o_q.types.GridCard.data">data</a></code></li>
<li><code><a title="h2o_q.types.GridCard.dump" href="#h2o_q.types.GridCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.GridCard.load" href="#h2o_q.types.GridCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.GridCard.title" href="#h2o_q.types.GridCard.title">title</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.HeaderCard" href="#h2o_q.types.HeaderCard">HeaderCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.HeaderCard.box" href="#h2o_q.types.HeaderCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.HeaderCard.commands" href="#h2o_q.types.HeaderCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.HeaderCard.dump" href="#h2o_q.types.HeaderCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.HeaderCard.icon" href="#h2o_q.types.HeaderCard.icon">icon</a></code></li>
<li><code><a title="h2o_q.types.HeaderCard.icon_color" href="#h2o_q.types.HeaderCard.icon_color">icon_color</a></code></li>
<li><code><a title="h2o_q.types.HeaderCard.load" href="#h2o_q.types.HeaderCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.HeaderCard.subtitle" href="#h2o_q.types.HeaderCard.subtitle">subtitle</a></code></li>
<li><code><a title="h2o_q.types.HeaderCard.title" href="#h2o_q.types.HeaderCard.title">title</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.IconTableCellType" href="#h2o_q.types.IconTableCellType">IconTableCellType</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.IconTableCellType.color" href="#h2o_q.types.IconTableCellType.color">color</a></code></li>
<li><code><a title="h2o_q.types.IconTableCellType.dump" href="#h2o_q.types.IconTableCellType.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.IconTableCellType.load" href="#h2o_q.types.IconTableCellType.load">load</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.ImageCard" href="#h2o_q.types.ImageCard">ImageCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.ImageCard.box" href="#h2o_q.types.ImageCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.ImageCard.commands" href="#h2o_q.types.ImageCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.ImageCard.data" href="#h2o_q.types.ImageCard.data">data</a></code></li>
<li><code><a title="h2o_q.types.ImageCard.dump" href="#h2o_q.types.ImageCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.ImageCard.image" href="#h2o_q.types.ImageCard.image">image</a></code></li>
<li><code><a title="h2o_q.types.ImageCard.load" href="#h2o_q.types.ImageCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.ImageCard.title" href="#h2o_q.types.ImageCard.title">title</a></code></li>
<li><code><a title="h2o_q.types.ImageCard.type" href="#h2o_q.types.ImageCard.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Label" href="#h2o_q.types.Label">Label</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.Label.disabled" href="#h2o_q.types.Label.disabled">disabled</a></code></li>
<li><code><a title="h2o_q.types.Label.dump" href="#h2o_q.types.Label.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Label.label" href="#h2o_q.types.Label.label">label</a></code></li>
<li><code><a title="h2o_q.types.Label.load" href="#h2o_q.types.Label.load">load</a></code></li>
<li><code><a title="h2o_q.types.Label.required" href="#h2o_q.types.Label.required">required</a></code></li>
<li><code><a title="h2o_q.types.Label.tooltip" href="#h2o_q.types.Label.tooltip">tooltip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.LargeBarStatCard" href="#h2o_q.types.LargeBarStatCard">LargeBarStatCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.LargeBarStatCard.aux_value" href="#h2o_q.types.LargeBarStatCard.aux_value">aux_value</a></code></li>
<li><code><a title="h2o_q.types.LargeBarStatCard.aux_value_caption" href="#h2o_q.types.LargeBarStatCard.aux_value_caption">aux_value_caption</a></code></li>
<li><code><a title="h2o_q.types.LargeBarStatCard.box" href="#h2o_q.types.LargeBarStatCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.LargeBarStatCard.caption" href="#h2o_q.types.LargeBarStatCard.caption">caption</a></code></li>
<li><code><a title="h2o_q.types.LargeBarStatCard.commands" href="#h2o_q.types.LargeBarStatCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.LargeBarStatCard.data" href="#h2o_q.types.LargeBarStatCard.data">data</a></code></li>
<li><code><a title="h2o_q.types.LargeBarStatCard.dump" href="#h2o_q.types.LargeBarStatCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.LargeBarStatCard.load" href="#h2o_q.types.LargeBarStatCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.LargeBarStatCard.plot_color" href="#h2o_q.types.LargeBarStatCard.plot_color">plot_color</a></code></li>
<li><code><a title="h2o_q.types.LargeBarStatCard.progress" href="#h2o_q.types.LargeBarStatCard.progress">progress</a></code></li>
<li><code><a title="h2o_q.types.LargeBarStatCard.title" href="#h2o_q.types.LargeBarStatCard.title">title</a></code></li>
<li><code><a title="h2o_q.types.LargeBarStatCard.value" href="#h2o_q.types.LargeBarStatCard.value">value</a></code></li>
<li><code><a title="h2o_q.types.LargeBarStatCard.value_caption" href="#h2o_q.types.LargeBarStatCard.value_caption">value_caption</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.LargeStatCard" href="#h2o_q.types.LargeStatCard">LargeStatCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.LargeStatCard.aux_value" href="#h2o_q.types.LargeStatCard.aux_value">aux_value</a></code></li>
<li><code><a title="h2o_q.types.LargeStatCard.box" href="#h2o_q.types.LargeStatCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.LargeStatCard.caption" href="#h2o_q.types.LargeStatCard.caption">caption</a></code></li>
<li><code><a title="h2o_q.types.LargeStatCard.commands" href="#h2o_q.types.LargeStatCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.LargeStatCard.data" href="#h2o_q.types.LargeStatCard.data">data</a></code></li>
<li><code><a title="h2o_q.types.LargeStatCard.dump" href="#h2o_q.types.LargeStatCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.LargeStatCard.load" href="#h2o_q.types.LargeStatCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.LargeStatCard.title" href="#h2o_q.types.LargeStatCard.title">title</a></code></li>
<li><code><a title="h2o_q.types.LargeStatCard.value" href="#h2o_q.types.LargeStatCard.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Link" href="#h2o_q.types.Link">Link</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.Link.button" href="#h2o_q.types.Link.button">button</a></code></li>
<li><code><a title="h2o_q.types.Link.disabled" href="#h2o_q.types.Link.disabled">disabled</a></code></li>
<li><code><a title="h2o_q.types.Link.download" href="#h2o_q.types.Link.download">download</a></code></li>
<li><code><a title="h2o_q.types.Link.dump" href="#h2o_q.types.Link.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Link.label" href="#h2o_q.types.Link.label">label</a></code></li>
<li><code><a title="h2o_q.types.Link.load" href="#h2o_q.types.Link.load">load</a></code></li>
<li><code><a title="h2o_q.types.Link.path" href="#h2o_q.types.Link.path">path</a></code></li>
<li><code><a title="h2o_q.types.Link.tooltip" href="#h2o_q.types.Link.tooltip">tooltip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.ListCard" href="#h2o_q.types.ListCard">ListCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.ListCard.box" href="#h2o_q.types.ListCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.ListCard.commands" href="#h2o_q.types.ListCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.ListCard.data" href="#h2o_q.types.ListCard.data">data</a></code></li>
<li><code><a title="h2o_q.types.ListCard.dump" href="#h2o_q.types.ListCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.ListCard.item_props" href="#h2o_q.types.ListCard.item_props">item_props</a></code></li>
<li><code><a title="h2o_q.types.ListCard.item_view" href="#h2o_q.types.ListCard.item_view">item_view</a></code></li>
<li><code><a title="h2o_q.types.ListCard.load" href="#h2o_q.types.ListCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.ListCard.title" href="#h2o_q.types.ListCard.title">title</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.ListItem1Card" href="#h2o_q.types.ListItem1Card">ListItem1Card</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.ListItem1Card.aux_value" href="#h2o_q.types.ListItem1Card.aux_value">aux_value</a></code></li>
<li><code><a title="h2o_q.types.ListItem1Card.box" href="#h2o_q.types.ListItem1Card.box">box</a></code></li>
<li><code><a title="h2o_q.types.ListItem1Card.caption" href="#h2o_q.types.ListItem1Card.caption">caption</a></code></li>
<li><code><a title="h2o_q.types.ListItem1Card.commands" href="#h2o_q.types.ListItem1Card.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.ListItem1Card.data" href="#h2o_q.types.ListItem1Card.data">data</a></code></li>
<li><code><a title="h2o_q.types.ListItem1Card.dump" href="#h2o_q.types.ListItem1Card.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.ListItem1Card.load" href="#h2o_q.types.ListItem1Card.load">load</a></code></li>
<li><code><a title="h2o_q.types.ListItem1Card.title" href="#h2o_q.types.ListItem1Card.title">title</a></code></li>
<li><code><a title="h2o_q.types.ListItem1Card.value" href="#h2o_q.types.ListItem1Card.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Mark" href="#h2o_q.types.Mark">Mark</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.Mark.color" href="#h2o_q.types.Mark.color">color</a></code></li>
<li><code><a title="h2o_q.types.Mark.color_domain" href="#h2o_q.types.Mark.color_domain">color_domain</a></code></li>
<li><code><a title="h2o_q.types.Mark.color_range" href="#h2o_q.types.Mark.color_range">color_range</a></code></li>
<li><code><a title="h2o_q.types.Mark.coord" href="#h2o_q.types.Mark.coord">coord</a></code></li>
<li><code><a title="h2o_q.types.Mark.curve" href="#h2o_q.types.Mark.curve">curve</a></code></li>
<li><code><a title="h2o_q.types.Mark.dodge" href="#h2o_q.types.Mark.dodge">dodge</a></code></li>
<li><code><a title="h2o_q.types.Mark.dump" href="#h2o_q.types.Mark.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Mark.fill_color" href="#h2o_q.types.Mark.fill_color">fill_color</a></code></li>
<li><code><a title="h2o_q.types.Mark.fill_opacity" href="#h2o_q.types.Mark.fill_opacity">fill_opacity</a></code></li>
<li><code><a title="h2o_q.types.Mark.label" href="#h2o_q.types.Mark.label">label</a></code></li>
<li><code><a title="h2o_q.types.Mark.label_align" href="#h2o_q.types.Mark.label_align">label_align</a></code></li>
<li><code><a title="h2o_q.types.Mark.label_fill_color" href="#h2o_q.types.Mark.label_fill_color">label_fill_color</a></code></li>
<li><code><a title="h2o_q.types.Mark.label_fill_opacity" href="#h2o_q.types.Mark.label_fill_opacity">label_fill_opacity</a></code></li>
<li><code><a title="h2o_q.types.Mark.label_font_size" href="#h2o_q.types.Mark.label_font_size">label_font_size</a></code></li>
<li><code><a title="h2o_q.types.Mark.label_font_weight" href="#h2o_q.types.Mark.label_font_weight">label_font_weight</a></code></li>
<li><code><a title="h2o_q.types.Mark.label_line_height" href="#h2o_q.types.Mark.label_line_height">label_line_height</a></code></li>
<li><code><a title="h2o_q.types.Mark.label_offset" href="#h2o_q.types.Mark.label_offset">label_offset</a></code></li>
<li><code><a title="h2o_q.types.Mark.label_offset_x" href="#h2o_q.types.Mark.label_offset_x">label_offset_x</a></code></li>
<li><code><a title="h2o_q.types.Mark.label_offset_y" href="#h2o_q.types.Mark.label_offset_y">label_offset_y</a></code></li>
<li><code><a title="h2o_q.types.Mark.label_overlap" href="#h2o_q.types.Mark.label_overlap">label_overlap</a></code></li>
<li><code><a title="h2o_q.types.Mark.label_position" href="#h2o_q.types.Mark.label_position">label_position</a></code></li>
<li><code><a title="h2o_q.types.Mark.label_rotation" href="#h2o_q.types.Mark.label_rotation">label_rotation</a></code></li>
<li><code><a title="h2o_q.types.Mark.label_stroke_color" href="#h2o_q.types.Mark.label_stroke_color">label_stroke_color</a></code></li>
<li><code><a title="h2o_q.types.Mark.label_stroke_opacity" href="#h2o_q.types.Mark.label_stroke_opacity">label_stroke_opacity</a></code></li>
<li><code><a title="h2o_q.types.Mark.label_stroke_size" href="#h2o_q.types.Mark.label_stroke_size">label_stroke_size</a></code></li>
<li><code><a title="h2o_q.types.Mark.load" href="#h2o_q.types.Mark.load">load</a></code></li>
<li><code><a title="h2o_q.types.Mark.ref_stroke_color" href="#h2o_q.types.Mark.ref_stroke_color">ref_stroke_color</a></code></li>
<li><code><a title="h2o_q.types.Mark.ref_stroke_dash" href="#h2o_q.types.Mark.ref_stroke_dash">ref_stroke_dash</a></code></li>
<li><code><a title="h2o_q.types.Mark.ref_stroke_opacity" href="#h2o_q.types.Mark.ref_stroke_opacity">ref_stroke_opacity</a></code></li>
<li><code><a title="h2o_q.types.Mark.ref_stroke_size" href="#h2o_q.types.Mark.ref_stroke_size">ref_stroke_size</a></code></li>
<li><code><a title="h2o_q.types.Mark.shape" href="#h2o_q.types.Mark.shape">shape</a></code></li>
<li><code><a title="h2o_q.types.Mark.shape_range" href="#h2o_q.types.Mark.shape_range">shape_range</a></code></li>
<li><code><a title="h2o_q.types.Mark.size" href="#h2o_q.types.Mark.size">size</a></code></li>
<li><code><a title="h2o_q.types.Mark.size_range" href="#h2o_q.types.Mark.size_range">size_range</a></code></li>
<li><code><a title="h2o_q.types.Mark.stack" href="#h2o_q.types.Mark.stack">stack</a></code></li>
<li><code><a title="h2o_q.types.Mark.stroke_color" href="#h2o_q.types.Mark.stroke_color">stroke_color</a></code></li>
<li><code><a title="h2o_q.types.Mark.stroke_dash" href="#h2o_q.types.Mark.stroke_dash">stroke_dash</a></code></li>
<li><code><a title="h2o_q.types.Mark.stroke_opacity" href="#h2o_q.types.Mark.stroke_opacity">stroke_opacity</a></code></li>
<li><code><a title="h2o_q.types.Mark.stroke_size" href="#h2o_q.types.Mark.stroke_size">stroke_size</a></code></li>
<li><code><a title="h2o_q.types.Mark.type" href="#h2o_q.types.Mark.type">type</a></code></li>
<li><code><a title="h2o_q.types.Mark.x" href="#h2o_q.types.Mark.x">x</a></code></li>
<li><code><a title="h2o_q.types.Mark.x0" href="#h2o_q.types.Mark.x0">x0</a></code></li>
<li><code><a title="h2o_q.types.Mark.x1" href="#h2o_q.types.Mark.x1">x1</a></code></li>
<li><code><a title="h2o_q.types.Mark.x2" href="#h2o_q.types.Mark.x2">x2</a></code></li>
<li><code><a title="h2o_q.types.Mark.x_max" href="#h2o_q.types.Mark.x_max">x_max</a></code></li>
<li><code><a title="h2o_q.types.Mark.x_min" href="#h2o_q.types.Mark.x_min">x_min</a></code></li>
<li><code><a title="h2o_q.types.Mark.x_nice" href="#h2o_q.types.Mark.x_nice">x_nice</a></code></li>
<li><code><a title="h2o_q.types.Mark.x_scale" href="#h2o_q.types.Mark.x_scale">x_scale</a></code></li>
<li><code><a title="h2o_q.types.Mark.x_title" href="#h2o_q.types.Mark.x_title">x_title</a></code></li>
<li><code><a title="h2o_q.types.Mark.y" href="#h2o_q.types.Mark.y">y</a></code></li>
<li><code><a title="h2o_q.types.Mark.y0" href="#h2o_q.types.Mark.y0">y0</a></code></li>
<li><code><a title="h2o_q.types.Mark.y1" href="#h2o_q.types.Mark.y1">y1</a></code></li>
<li><code><a title="h2o_q.types.Mark.y2" href="#h2o_q.types.Mark.y2">y2</a></code></li>
<li><code><a title="h2o_q.types.Mark.y_max" href="#h2o_q.types.Mark.y_max">y_max</a></code></li>
<li><code><a title="h2o_q.types.Mark.y_min" href="#h2o_q.types.Mark.y_min">y_min</a></code></li>
<li><code><a title="h2o_q.types.Mark.y_nice" href="#h2o_q.types.Mark.y_nice">y_nice</a></code></li>
<li><code><a title="h2o_q.types.Mark.y_scale" href="#h2o_q.types.Mark.y_scale">y_scale</a></code></li>
<li><code><a title="h2o_q.types.Mark.y_title" href="#h2o_q.types.Mark.y_title">y_title</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.MarkdownCard" href="#h2o_q.types.MarkdownCard">MarkdownCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.MarkdownCard.box" href="#h2o_q.types.MarkdownCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.MarkdownCard.commands" href="#h2o_q.types.MarkdownCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.MarkdownCard.content" href="#h2o_q.types.MarkdownCard.content">content</a></code></li>
<li><code><a title="h2o_q.types.MarkdownCard.data" href="#h2o_q.types.MarkdownCard.data">data</a></code></li>
<li><code><a title="h2o_q.types.MarkdownCard.dump" href="#h2o_q.types.MarkdownCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.MarkdownCard.load" href="#h2o_q.types.MarkdownCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.MarkdownCard.title" href="#h2o_q.types.MarkdownCard.title">title</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Markup" href="#h2o_q.types.Markup">Markup</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.Markup.content" href="#h2o_q.types.Markup.content">content</a></code></li>
<li><code><a title="h2o_q.types.Markup.dump" href="#h2o_q.types.Markup.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Markup.load" href="#h2o_q.types.Markup.load">load</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.MarkupCard" href="#h2o_q.types.MarkupCard">MarkupCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.MarkupCard.box" href="#h2o_q.types.MarkupCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.MarkupCard.commands" href="#h2o_q.types.MarkupCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.MarkupCard.content" href="#h2o_q.types.MarkupCard.content">content</a></code></li>
<li><code><a title="h2o_q.types.MarkupCard.dump" href="#h2o_q.types.MarkupCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.MarkupCard.load" href="#h2o_q.types.MarkupCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.MarkupCard.title" href="#h2o_q.types.MarkupCard.title">title</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.MessageBar" href="#h2o_q.types.MessageBar">MessageBar</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.MessageBar.dump" href="#h2o_q.types.MessageBar.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.MessageBar.load" href="#h2o_q.types.MessageBar.load">load</a></code></li>
<li><code><a title="h2o_q.types.MessageBar.text" href="#h2o_q.types.MessageBar.text">text</a></code></li>
<li><code><a title="h2o_q.types.MessageBar.type" href="#h2o_q.types.MessageBar.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.MetaCard" href="#h2o_q.types.MetaCard">MetaCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.MetaCard.box" href="#h2o_q.types.MetaCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.MetaCard.commands" href="#h2o_q.types.MetaCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.MetaCard.dump" href="#h2o_q.types.MetaCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.MetaCard.load" href="#h2o_q.types.MetaCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.MetaCard.notification" href="#h2o_q.types.MetaCard.notification">notification</a></code></li>
<li><code><a title="h2o_q.types.MetaCard.redirect" href="#h2o_q.types.MetaCard.redirect">redirect</a></code></li>
<li><code><a title="h2o_q.types.MetaCard.refresh" href="#h2o_q.types.MetaCard.refresh">refresh</a></code></li>
<li><code><a title="h2o_q.types.MetaCard.title" href="#h2o_q.types.MetaCard.title">title</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.NavCard" href="#h2o_q.types.NavCard">NavCard</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.NavCard.box" href="#h2o_q.types.NavCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.NavCard.commands" href="#h2o_q.types.NavCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.NavCard.dump" href="#h2o_q.types.NavCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.NavCard.items" href="#h2o_q.types.NavCard.items">items</a></code></li>
<li><code><a title="h2o_q.types.NavCard.load" href="#h2o_q.types.NavCard.load">load</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.NavGroup" href="#h2o_q.types.NavGroup">NavGroup</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.NavGroup.dump" href="#h2o_q.types.NavGroup.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.NavGroup.items" href="#h2o_q.types.NavGroup.items">items</a></code></li>
<li><code><a title="h2o_q.types.NavGroup.label" href="#h2o_q.types.NavGroup.label">label</a></code></li>
<li><code><a title="h2o_q.types.NavGroup.load" href="#h2o_q.types.NavGroup.load">load</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.NavItem" href="#h2o_q.types.NavItem">NavItem</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.NavItem.dump" href="#h2o_q.types.NavItem.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.NavItem.label" href="#h2o_q.types.NavItem.label">label</a></code></li>
<li><code><a title="h2o_q.types.NavItem.load" href="#h2o_q.types.NavItem.load">load</a></code></li>
<li><code><a title="h2o_q.types.NavItem.name" href="#h2o_q.types.NavItem.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Picker" href="#h2o_q.types.Picker">Picker</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.Picker.choices" href="#h2o_q.types.Picker.choices">choices</a></code></li>
<li><code><a title="h2o_q.types.Picker.disabled" href="#h2o_q.types.Picker.disabled">disabled</a></code></li>
<li><code><a title="h2o_q.types.Picker.dump" href="#h2o_q.types.Picker.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Picker.label" href="#h2o_q.types.Picker.label">label</a></code></li>
<li><code><a title="h2o_q.types.Picker.load" href="#h2o_q.types.Picker.load">load</a></code></li>
<li><code><a title="h2o_q.types.Picker.max_choices" href="#h2o_q.types.Picker.max_choices">max_choices</a></code></li>
<li><code><a title="h2o_q.types.Picker.name" href="#h2o_q.types.Picker.name">name</a></code></li>
<li><code><a title="h2o_q.types.Picker.tooltip" href="#h2o_q.types.Picker.tooltip">tooltip</a></code></li>
<li><code><a title="h2o_q.types.Picker.values" href="#h2o_q.types.Picker.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.PixelArtCard" href="#h2o_q.types.PixelArtCard">PixelArtCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.PixelArtCard.box" href="#h2o_q.types.PixelArtCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.PixelArtCard.commands" href="#h2o_q.types.PixelArtCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.PixelArtCard.data" href="#h2o_q.types.PixelArtCard.data">data</a></code></li>
<li><code><a title="h2o_q.types.PixelArtCard.dump" href="#h2o_q.types.PixelArtCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.PixelArtCard.load" href="#h2o_q.types.PixelArtCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.PixelArtCard.title" href="#h2o_q.types.PixelArtCard.title">title</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Plot" href="#h2o_q.types.Plot">Plot</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.Plot.dump" href="#h2o_q.types.Plot.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Plot.load" href="#h2o_q.types.Plot.load">load</a></code></li>
<li><code><a title="h2o_q.types.Plot.marks" href="#h2o_q.types.Plot.marks">marks</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.PlotCard" href="#h2o_q.types.PlotCard">PlotCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.PlotCard.box" href="#h2o_q.types.PlotCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.PlotCard.commands" href="#h2o_q.types.PlotCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.PlotCard.data" href="#h2o_q.types.PlotCard.data">data</a></code></li>
<li><code><a title="h2o_q.types.PlotCard.dump" href="#h2o_q.types.PlotCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.PlotCard.load" href="#h2o_q.types.PlotCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.PlotCard.plot" href="#h2o_q.types.PlotCard.plot">plot</a></code></li>
<li><code><a title="h2o_q.types.PlotCard.title" href="#h2o_q.types.PlotCard.title">title</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Progress" href="#h2o_q.types.Progress">Progress</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.Progress.caption" href="#h2o_q.types.Progress.caption">caption</a></code></li>
<li><code><a title="h2o_q.types.Progress.dump" href="#h2o_q.types.Progress.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Progress.label" href="#h2o_q.types.Progress.label">label</a></code></li>
<li><code><a title="h2o_q.types.Progress.load" href="#h2o_q.types.Progress.load">load</a></code></li>
<li><code><a title="h2o_q.types.Progress.tooltip" href="#h2o_q.types.Progress.tooltip">tooltip</a></code></li>
<li><code><a title="h2o_q.types.Progress.value" href="#h2o_q.types.Progress.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.ProgressTableCellType" href="#h2o_q.types.ProgressTableCellType">ProgressTableCellType</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.ProgressTableCellType.color" href="#h2o_q.types.ProgressTableCellType.color">color</a></code></li>
<li><code><a title="h2o_q.types.ProgressTableCellType.dump" href="#h2o_q.types.ProgressTableCellType.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.ProgressTableCellType.load" href="#h2o_q.types.ProgressTableCellType.load">load</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.RangeSlider" href="#h2o_q.types.RangeSlider">RangeSlider</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.RangeSlider.disabled" href="#h2o_q.types.RangeSlider.disabled">disabled</a></code></li>
<li><code><a title="h2o_q.types.RangeSlider.dump" href="#h2o_q.types.RangeSlider.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.RangeSlider.label" href="#h2o_q.types.RangeSlider.label">label</a></code></li>
<li><code><a title="h2o_q.types.RangeSlider.load" href="#h2o_q.types.RangeSlider.load">load</a></code></li>
<li><code><a title="h2o_q.types.RangeSlider.max" href="#h2o_q.types.RangeSlider.max">max</a></code></li>
<li><code><a title="h2o_q.types.RangeSlider.max_value" href="#h2o_q.types.RangeSlider.max_value">max_value</a></code></li>
<li><code><a title="h2o_q.types.RangeSlider.min" href="#h2o_q.types.RangeSlider.min">min</a></code></li>
<li><code><a title="h2o_q.types.RangeSlider.min_value" href="#h2o_q.types.RangeSlider.min_value">min_value</a></code></li>
<li><code><a title="h2o_q.types.RangeSlider.name" href="#h2o_q.types.RangeSlider.name">name</a></code></li>
<li><code><a title="h2o_q.types.RangeSlider.step" href="#h2o_q.types.RangeSlider.step">step</a></code></li>
<li><code><a title="h2o_q.types.RangeSlider.tooltip" href="#h2o_q.types.RangeSlider.tooltip">tooltip</a></code></li>
<li><code><a title="h2o_q.types.RangeSlider.trigger" href="#h2o_q.types.RangeSlider.trigger">trigger</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.RepeatCard" href="#h2o_q.types.RepeatCard">RepeatCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.RepeatCard.box" href="#h2o_q.types.RepeatCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.RepeatCard.commands" href="#h2o_q.types.RepeatCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.RepeatCard.data" href="#h2o_q.types.RepeatCard.data">data</a></code></li>
<li><code><a title="h2o_q.types.RepeatCard.dump" href="#h2o_q.types.RepeatCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.RepeatCard.item_props" href="#h2o_q.types.RepeatCard.item_props">item_props</a></code></li>
<li><code><a title="h2o_q.types.RepeatCard.item_view" href="#h2o_q.types.RepeatCard.item_view">item_view</a></code></li>
<li><code><a title="h2o_q.types.RepeatCard.load" href="#h2o_q.types.RepeatCard.load">load</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Separator" href="#h2o_q.types.Separator">Separator</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.Separator.dump" href="#h2o_q.types.Separator.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Separator.label" href="#h2o_q.types.Separator.label">label</a></code></li>
<li><code><a title="h2o_q.types.Separator.load" href="#h2o_q.types.Separator.load">load</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Slider" href="#h2o_q.types.Slider">Slider</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.Slider.disabled" href="#h2o_q.types.Slider.disabled">disabled</a></code></li>
<li><code><a title="h2o_q.types.Slider.dump" href="#h2o_q.types.Slider.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Slider.label" href="#h2o_q.types.Slider.label">label</a></code></li>
<li><code><a title="h2o_q.types.Slider.load" href="#h2o_q.types.Slider.load">load</a></code></li>
<li><code><a title="h2o_q.types.Slider.max" href="#h2o_q.types.Slider.max">max</a></code></li>
<li><code><a title="h2o_q.types.Slider.min" href="#h2o_q.types.Slider.min">min</a></code></li>
<li><code><a title="h2o_q.types.Slider.name" href="#h2o_q.types.Slider.name">name</a></code></li>
<li><code><a title="h2o_q.types.Slider.step" href="#h2o_q.types.Slider.step">step</a></code></li>
<li><code><a title="h2o_q.types.Slider.tooltip" href="#h2o_q.types.Slider.tooltip">tooltip</a></code></li>
<li><code><a title="h2o_q.types.Slider.trigger" href="#h2o_q.types.Slider.trigger">trigger</a></code></li>
<li><code><a title="h2o_q.types.Slider.value" href="#h2o_q.types.Slider.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.SmallSeriesStatCard" href="#h2o_q.types.SmallSeriesStatCard">SmallSeriesStatCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.SmallSeriesStatCard.box" href="#h2o_q.types.SmallSeriesStatCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.SmallSeriesStatCard.commands" href="#h2o_q.types.SmallSeriesStatCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.SmallSeriesStatCard.data" href="#h2o_q.types.SmallSeriesStatCard.data">data</a></code></li>
<li><code><a title="h2o_q.types.SmallSeriesStatCard.dump" href="#h2o_q.types.SmallSeriesStatCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.SmallSeriesStatCard.load" href="#h2o_q.types.SmallSeriesStatCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.SmallSeriesStatCard.plot_category" href="#h2o_q.types.SmallSeriesStatCard.plot_category">plot_category</a></code></li>
<li><code><a title="h2o_q.types.SmallSeriesStatCard.plot_color" href="#h2o_q.types.SmallSeriesStatCard.plot_color">plot_color</a></code></li>
<li><code><a title="h2o_q.types.SmallSeriesStatCard.plot_curve" href="#h2o_q.types.SmallSeriesStatCard.plot_curve">plot_curve</a></code></li>
<li><code><a title="h2o_q.types.SmallSeriesStatCard.plot_data" href="#h2o_q.types.SmallSeriesStatCard.plot_data">plot_data</a></code></li>
<li><code><a title="h2o_q.types.SmallSeriesStatCard.plot_type" href="#h2o_q.types.SmallSeriesStatCard.plot_type">plot_type</a></code></li>
<li><code><a title="h2o_q.types.SmallSeriesStatCard.plot_value" href="#h2o_q.types.SmallSeriesStatCard.plot_value">plot_value</a></code></li>
<li><code><a title="h2o_q.types.SmallSeriesStatCard.plot_zero_value" href="#h2o_q.types.SmallSeriesStatCard.plot_zero_value">plot_zero_value</a></code></li>
<li><code><a title="h2o_q.types.SmallSeriesStatCard.title" href="#h2o_q.types.SmallSeriesStatCard.title">title</a></code></li>
<li><code><a title="h2o_q.types.SmallSeriesStatCard.value" href="#h2o_q.types.SmallSeriesStatCard.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.SmallStatCard" href="#h2o_q.types.SmallStatCard">SmallStatCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.SmallStatCard.box" href="#h2o_q.types.SmallStatCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.SmallStatCard.commands" href="#h2o_q.types.SmallStatCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.SmallStatCard.data" href="#h2o_q.types.SmallStatCard.data">data</a></code></li>
<li><code><a title="h2o_q.types.SmallStatCard.dump" href="#h2o_q.types.SmallStatCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.SmallStatCard.load" href="#h2o_q.types.SmallStatCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.SmallStatCard.title" href="#h2o_q.types.SmallStatCard.title">title</a></code></li>
<li><code><a title="h2o_q.types.SmallStatCard.value" href="#h2o_q.types.SmallStatCard.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Spinbox" href="#h2o_q.types.Spinbox">Spinbox</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.Spinbox.disabled" href="#h2o_q.types.Spinbox.disabled">disabled</a></code></li>
<li><code><a title="h2o_q.types.Spinbox.dump" href="#h2o_q.types.Spinbox.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Spinbox.label" href="#h2o_q.types.Spinbox.label">label</a></code></li>
<li><code><a title="h2o_q.types.Spinbox.load" href="#h2o_q.types.Spinbox.load">load</a></code></li>
<li><code><a title="h2o_q.types.Spinbox.max" href="#h2o_q.types.Spinbox.max">max</a></code></li>
<li><code><a title="h2o_q.types.Spinbox.min" href="#h2o_q.types.Spinbox.min">min</a></code></li>
<li><code><a title="h2o_q.types.Spinbox.name" href="#h2o_q.types.Spinbox.name">name</a></code></li>
<li><code><a title="h2o_q.types.Spinbox.step" href="#h2o_q.types.Spinbox.step">step</a></code></li>
<li><code><a title="h2o_q.types.Spinbox.tooltip" href="#h2o_q.types.Spinbox.tooltip">tooltip</a></code></li>
<li><code><a title="h2o_q.types.Spinbox.value" href="#h2o_q.types.Spinbox.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Step" href="#h2o_q.types.Step">Step</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.Step.done" href="#h2o_q.types.Step.done">done</a></code></li>
<li><code><a title="h2o_q.types.Step.dump" href="#h2o_q.types.Step.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Step.icon" href="#h2o_q.types.Step.icon">icon</a></code></li>
<li><code><a title="h2o_q.types.Step.label" href="#h2o_q.types.Step.label">label</a></code></li>
<li><code><a title="h2o_q.types.Step.load" href="#h2o_q.types.Step.load">load</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Stepper" href="#h2o_q.types.Stepper">Stepper</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.Stepper.dump" href="#h2o_q.types.Stepper.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Stepper.items" href="#h2o_q.types.Stepper.items">items</a></code></li>
<li><code><a title="h2o_q.types.Stepper.load" href="#h2o_q.types.Stepper.load">load</a></code></li>
<li><code><a title="h2o_q.types.Stepper.name" href="#h2o_q.types.Stepper.name">name</a></code></li>
<li><code><a title="h2o_q.types.Stepper.tooltip" href="#h2o_q.types.Stepper.tooltip">tooltip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Tab" href="#h2o_q.types.Tab">Tab</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.Tab.dump" href="#h2o_q.types.Tab.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Tab.icon" href="#h2o_q.types.Tab.icon">icon</a></code></li>
<li><code><a title="h2o_q.types.Tab.label" href="#h2o_q.types.Tab.label">label</a></code></li>
<li><code><a title="h2o_q.types.Tab.load" href="#h2o_q.types.Tab.load">load</a></code></li>
<li><code><a title="h2o_q.types.Tab.name" href="#h2o_q.types.Tab.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.TabCard" href="#h2o_q.types.TabCard">TabCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.TabCard.box" href="#h2o_q.types.TabCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.TabCard.commands" href="#h2o_q.types.TabCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.TabCard.dump" href="#h2o_q.types.TabCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.TabCard.items" href="#h2o_q.types.TabCard.items">items</a></code></li>
<li><code><a title="h2o_q.types.TabCard.link" href="#h2o_q.types.TabCard.link">link</a></code></li>
<li><code><a title="h2o_q.types.TabCard.load" href="#h2o_q.types.TabCard.load">load</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Table" href="#h2o_q.types.Table">Table</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.Table.columns" href="#h2o_q.types.Table.columns">columns</a></code></li>
<li><code><a title="h2o_q.types.Table.downloadable" href="#h2o_q.types.Table.downloadable">downloadable</a></code></li>
<li><code><a title="h2o_q.types.Table.dump" href="#h2o_q.types.Table.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Table.groupable" href="#h2o_q.types.Table.groupable">groupable</a></code></li>
<li><code><a title="h2o_q.types.Table.height" href="#h2o_q.types.Table.height">height</a></code></li>
<li><code><a title="h2o_q.types.Table.load" href="#h2o_q.types.Table.load">load</a></code></li>
<li><code><a title="h2o_q.types.Table.multiple" href="#h2o_q.types.Table.multiple">multiple</a></code></li>
<li><code><a title="h2o_q.types.Table.name" href="#h2o_q.types.Table.name">name</a></code></li>
<li><code><a title="h2o_q.types.Table.resettable" href="#h2o_q.types.Table.resettable">resettable</a></code></li>
<li><code><a title="h2o_q.types.Table.rows" href="#h2o_q.types.Table.rows">rows</a></code></li>
<li><code><a title="h2o_q.types.Table.tooltip" href="#h2o_q.types.Table.tooltip">tooltip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.TableCellType" href="#h2o_q.types.TableCellType">TableCellType</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.TableCellType.dump" href="#h2o_q.types.TableCellType.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.TableCellType.icon" href="#h2o_q.types.TableCellType.icon">icon</a></code></li>
<li><code><a title="h2o_q.types.TableCellType.load" href="#h2o_q.types.TableCellType.load">load</a></code></li>
<li><code><a title="h2o_q.types.TableCellType.progress" href="#h2o_q.types.TableCellType.progress">progress</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.TableColumn" href="#h2o_q.types.TableColumn">TableColumn</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.TableColumn.cell_type" href="#h2o_q.types.TableColumn.cell_type">cell_type</a></code></li>
<li><code><a title="h2o_q.types.TableColumn.dump" href="#h2o_q.types.TableColumn.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.TableColumn.filterable" href="#h2o_q.types.TableColumn.filterable">filterable</a></code></li>
<li><code><a title="h2o_q.types.TableColumn.label" href="#h2o_q.types.TableColumn.label">label</a></code></li>
<li><code><a title="h2o_q.types.TableColumn.link" href="#h2o_q.types.TableColumn.link">link</a></code></li>
<li><code><a title="h2o_q.types.TableColumn.load" href="#h2o_q.types.TableColumn.load">load</a></code></li>
<li><code><a title="h2o_q.types.TableColumn.max_width" href="#h2o_q.types.TableColumn.max_width">max_width</a></code></li>
<li><code><a title="h2o_q.types.TableColumn.min_width" href="#h2o_q.types.TableColumn.min_width">min_width</a></code></li>
<li><code><a title="h2o_q.types.TableColumn.name" href="#h2o_q.types.TableColumn.name">name</a></code></li>
<li><code><a title="h2o_q.types.TableColumn.searchable" href="#h2o_q.types.TableColumn.searchable">searchable</a></code></li>
<li><code><a title="h2o_q.types.TableColumn.sortable" href="#h2o_q.types.TableColumn.sortable">sortable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.TableRow" href="#h2o_q.types.TableRow">TableRow</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.TableRow.cells" href="#h2o_q.types.TableRow.cells">cells</a></code></li>
<li><code><a title="h2o_q.types.TableRow.dump" href="#h2o_q.types.TableRow.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.TableRow.load" href="#h2o_q.types.TableRow.load">load</a></code></li>
<li><code><a title="h2o_q.types.TableRow.name" href="#h2o_q.types.TableRow.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Tabs" href="#h2o_q.types.Tabs">Tabs</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.Tabs.dump" href="#h2o_q.types.Tabs.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Tabs.items" href="#h2o_q.types.Tabs.items">items</a></code></li>
<li><code><a title="h2o_q.types.Tabs.load" href="#h2o_q.types.Tabs.load">load</a></code></li>
<li><code><a title="h2o_q.types.Tabs.name" href="#h2o_q.types.Tabs.name">name</a></code></li>
<li><code><a title="h2o_q.types.Tabs.value" href="#h2o_q.types.Tabs.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.TallGaugeStatCard" href="#h2o_q.types.TallGaugeStatCard">TallGaugeStatCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.TallGaugeStatCard.aux_value" href="#h2o_q.types.TallGaugeStatCard.aux_value">aux_value</a></code></li>
<li><code><a title="h2o_q.types.TallGaugeStatCard.box" href="#h2o_q.types.TallGaugeStatCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.TallGaugeStatCard.commands" href="#h2o_q.types.TallGaugeStatCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.TallGaugeStatCard.data" href="#h2o_q.types.TallGaugeStatCard.data">data</a></code></li>
<li><code><a title="h2o_q.types.TallGaugeStatCard.dump" href="#h2o_q.types.TallGaugeStatCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.TallGaugeStatCard.load" href="#h2o_q.types.TallGaugeStatCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.TallGaugeStatCard.plot_color" href="#h2o_q.types.TallGaugeStatCard.plot_color">plot_color</a></code></li>
<li><code><a title="h2o_q.types.TallGaugeStatCard.progress" href="#h2o_q.types.TallGaugeStatCard.progress">progress</a></code></li>
<li><code><a title="h2o_q.types.TallGaugeStatCard.title" href="#h2o_q.types.TallGaugeStatCard.title">title</a></code></li>
<li><code><a title="h2o_q.types.TallGaugeStatCard.value" href="#h2o_q.types.TallGaugeStatCard.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.TallSeriesStatCard" href="#h2o_q.types.TallSeriesStatCard">TallSeriesStatCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.TallSeriesStatCard.aux_value" href="#h2o_q.types.TallSeriesStatCard.aux_value">aux_value</a></code></li>
<li><code><a title="h2o_q.types.TallSeriesStatCard.box" href="#h2o_q.types.TallSeriesStatCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.TallSeriesStatCard.commands" href="#h2o_q.types.TallSeriesStatCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.TallSeriesStatCard.data" href="#h2o_q.types.TallSeriesStatCard.data">data</a></code></li>
<li><code><a title="h2o_q.types.TallSeriesStatCard.dump" href="#h2o_q.types.TallSeriesStatCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.TallSeriesStatCard.load" href="#h2o_q.types.TallSeriesStatCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.TallSeriesStatCard.plot_category" href="#h2o_q.types.TallSeriesStatCard.plot_category">plot_category</a></code></li>
<li><code><a title="h2o_q.types.TallSeriesStatCard.plot_color" href="#h2o_q.types.TallSeriesStatCard.plot_color">plot_color</a></code></li>
<li><code><a title="h2o_q.types.TallSeriesStatCard.plot_curve" href="#h2o_q.types.TallSeriesStatCard.plot_curve">plot_curve</a></code></li>
<li><code><a title="h2o_q.types.TallSeriesStatCard.plot_data" href="#h2o_q.types.TallSeriesStatCard.plot_data">plot_data</a></code></li>
<li><code><a title="h2o_q.types.TallSeriesStatCard.plot_type" href="#h2o_q.types.TallSeriesStatCard.plot_type">plot_type</a></code></li>
<li><code><a title="h2o_q.types.TallSeriesStatCard.plot_value" href="#h2o_q.types.TallSeriesStatCard.plot_value">plot_value</a></code></li>
<li><code><a title="h2o_q.types.TallSeriesStatCard.plot_zero_value" href="#h2o_q.types.TallSeriesStatCard.plot_zero_value">plot_zero_value</a></code></li>
<li><code><a title="h2o_q.types.TallSeriesStatCard.title" href="#h2o_q.types.TallSeriesStatCard.title">title</a></code></li>
<li><code><a title="h2o_q.types.TallSeriesStatCard.value" href="#h2o_q.types.TallSeriesStatCard.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Template" href="#h2o_q.types.Template">Template</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.Template.content" href="#h2o_q.types.Template.content">content</a></code></li>
<li><code><a title="h2o_q.types.Template.data" href="#h2o_q.types.Template.data">data</a></code></li>
<li><code><a title="h2o_q.types.Template.dump" href="#h2o_q.types.Template.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Template.load" href="#h2o_q.types.Template.load">load</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.TemplateCard" href="#h2o_q.types.TemplateCard">TemplateCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.TemplateCard.box" href="#h2o_q.types.TemplateCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.TemplateCard.commands" href="#h2o_q.types.TemplateCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.TemplateCard.content" href="#h2o_q.types.TemplateCard.content">content</a></code></li>
<li><code><a title="h2o_q.types.TemplateCard.data" href="#h2o_q.types.TemplateCard.data">data</a></code></li>
<li><code><a title="h2o_q.types.TemplateCard.dump" href="#h2o_q.types.TemplateCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.TemplateCard.load" href="#h2o_q.types.TemplateCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.TemplateCard.title" href="#h2o_q.types.TemplateCard.title">title</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Text" href="#h2o_q.types.Text">Text</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.Text.content" href="#h2o_q.types.Text.content">content</a></code></li>
<li><code><a title="h2o_q.types.Text.dump" href="#h2o_q.types.Text.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Text.load" href="#h2o_q.types.Text.load">load</a></code></li>
<li><code><a title="h2o_q.types.Text.size" href="#h2o_q.types.Text.size">size</a></code></li>
<li><code><a title="h2o_q.types.Text.tooltip" href="#h2o_q.types.Text.tooltip">tooltip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.TextL" href="#h2o_q.types.TextL">TextL</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.TextL.commands" href="#h2o_q.types.TextL.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.TextL.content" href="#h2o_q.types.TextL.content">content</a></code></li>
<li><code><a title="h2o_q.types.TextL.dump" href="#h2o_q.types.TextL.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.TextL.load" href="#h2o_q.types.TextL.load">load</a></code></li>
<li><code><a title="h2o_q.types.TextL.tooltip" href="#h2o_q.types.TextL.tooltip">tooltip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.TextM" href="#h2o_q.types.TextM">TextM</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.TextM.content" href="#h2o_q.types.TextM.content">content</a></code></li>
<li><code><a title="h2o_q.types.TextM.dump" href="#h2o_q.types.TextM.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.TextM.load" href="#h2o_q.types.TextM.load">load</a></code></li>
<li><code><a title="h2o_q.types.TextM.tooltip" href="#h2o_q.types.TextM.tooltip">tooltip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.TextS" href="#h2o_q.types.TextS">TextS</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.TextS.content" href="#h2o_q.types.TextS.content">content</a></code></li>
<li><code><a title="h2o_q.types.TextS.dump" href="#h2o_q.types.TextS.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.TextS.load" href="#h2o_q.types.TextS.load">load</a></code></li>
<li><code><a title="h2o_q.types.TextS.tooltip" href="#h2o_q.types.TextS.tooltip">tooltip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.TextXl" href="#h2o_q.types.TextXl">TextXl</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.TextXl.commands" href="#h2o_q.types.TextXl.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.TextXl.content" href="#h2o_q.types.TextXl.content">content</a></code></li>
<li><code><a title="h2o_q.types.TextXl.dump" href="#h2o_q.types.TextXl.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.TextXl.load" href="#h2o_q.types.TextXl.load">load</a></code></li>
<li><code><a title="h2o_q.types.TextXl.tooltip" href="#h2o_q.types.TextXl.tooltip">tooltip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.TextXs" href="#h2o_q.types.TextXs">TextXs</a></code></h4>
<ul class="">
<li><code><a title="h2o_q.types.TextXs.content" href="#h2o_q.types.TextXs.content">content</a></code></li>
<li><code><a title="h2o_q.types.TextXs.dump" href="#h2o_q.types.TextXs.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.TextXs.load" href="#h2o_q.types.TextXs.load">load</a></code></li>
<li><code><a title="h2o_q.types.TextXs.tooltip" href="#h2o_q.types.TextXs.tooltip">tooltip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Textbox" href="#h2o_q.types.Textbox">Textbox</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.Textbox.disabled" href="#h2o_q.types.Textbox.disabled">disabled</a></code></li>
<li><code><a title="h2o_q.types.Textbox.dump" href="#h2o_q.types.Textbox.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Textbox.error" href="#h2o_q.types.Textbox.error">error</a></code></li>
<li><code><a title="h2o_q.types.Textbox.icon" href="#h2o_q.types.Textbox.icon">icon</a></code></li>
<li><code><a title="h2o_q.types.Textbox.label" href="#h2o_q.types.Textbox.label">label</a></code></li>
<li><code><a title="h2o_q.types.Textbox.load" href="#h2o_q.types.Textbox.load">load</a></code></li>
<li><code><a title="h2o_q.types.Textbox.mask" href="#h2o_q.types.Textbox.mask">mask</a></code></li>
<li><code><a title="h2o_q.types.Textbox.multiline" href="#h2o_q.types.Textbox.multiline">multiline</a></code></li>
<li><code><a title="h2o_q.types.Textbox.name" href="#h2o_q.types.Textbox.name">name</a></code></li>
<li><code><a title="h2o_q.types.Textbox.password" href="#h2o_q.types.Textbox.password">password</a></code></li>
<li><code><a title="h2o_q.types.Textbox.placeholder" href="#h2o_q.types.Textbox.placeholder">placeholder</a></code></li>
<li><code><a title="h2o_q.types.Textbox.prefix" href="#h2o_q.types.Textbox.prefix">prefix</a></code></li>
<li><code><a title="h2o_q.types.Textbox.readonly" href="#h2o_q.types.Textbox.readonly">readonly</a></code></li>
<li><code><a title="h2o_q.types.Textbox.required" href="#h2o_q.types.Textbox.required">required</a></code></li>
<li><code><a title="h2o_q.types.Textbox.suffix" href="#h2o_q.types.Textbox.suffix">suffix</a></code></li>
<li><code><a title="h2o_q.types.Textbox.tooltip" href="#h2o_q.types.Textbox.tooltip">tooltip</a></code></li>
<li><code><a title="h2o_q.types.Textbox.trigger" href="#h2o_q.types.Textbox.trigger">trigger</a></code></li>
<li><code><a title="h2o_q.types.Textbox.value" href="#h2o_q.types.Textbox.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Toggle" href="#h2o_q.types.Toggle">Toggle</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.Toggle.disabled" href="#h2o_q.types.Toggle.disabled">disabled</a></code></li>
<li><code><a title="h2o_q.types.Toggle.dump" href="#h2o_q.types.Toggle.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Toggle.label" href="#h2o_q.types.Toggle.label">label</a></code></li>
<li><code><a title="h2o_q.types.Toggle.load" href="#h2o_q.types.Toggle.load">load</a></code></li>
<li><code><a title="h2o_q.types.Toggle.name" href="#h2o_q.types.Toggle.name">name</a></code></li>
<li><code><a title="h2o_q.types.Toggle.tooltip" href="#h2o_q.types.Toggle.tooltip">tooltip</a></code></li>
<li><code><a title="h2o_q.types.Toggle.trigger" href="#h2o_q.types.Toggle.trigger">trigger</a></code></li>
<li><code><a title="h2o_q.types.Toggle.value" href="#h2o_q.types.Toggle.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.ToolbarCard" href="#h2o_q.types.ToolbarCard">ToolbarCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.ToolbarCard.box" href="#h2o_q.types.ToolbarCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.ToolbarCard.commands" href="#h2o_q.types.ToolbarCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.ToolbarCard.dump" href="#h2o_q.types.ToolbarCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.ToolbarCard.items" href="#h2o_q.types.ToolbarCard.items">items</a></code></li>
<li><code><a title="h2o_q.types.ToolbarCard.load" href="#h2o_q.types.ToolbarCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.ToolbarCard.overflow_items" href="#h2o_q.types.ToolbarCard.overflow_items">overflow_items</a></code></li>
<li><code><a title="h2o_q.types.ToolbarCard.secondary_items" href="#h2o_q.types.ToolbarCard.secondary_items">secondary_items</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.VegaCard" href="#h2o_q.types.VegaCard">VegaCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.VegaCard.box" href="#h2o_q.types.VegaCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.VegaCard.commands" href="#h2o_q.types.VegaCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.VegaCard.data" href="#h2o_q.types.VegaCard.data">data</a></code></li>
<li><code><a title="h2o_q.types.VegaCard.dump" href="#h2o_q.types.VegaCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.VegaCard.load" href="#h2o_q.types.VegaCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.VegaCard.specification" href="#h2o_q.types.VegaCard.specification">specification</a></code></li>
<li><code><a title="h2o_q.types.VegaCard.title" href="#h2o_q.types.VegaCard.title">title</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.VegaVisualization" href="#h2o_q.types.VegaVisualization">VegaVisualization</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.VegaVisualization.data" href="#h2o_q.types.VegaVisualization.data">data</a></code></li>
<li><code><a title="h2o_q.types.VegaVisualization.dump" href="#h2o_q.types.VegaVisualization.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.VegaVisualization.height" href="#h2o_q.types.VegaVisualization.height">height</a></code></li>
<li><code><a title="h2o_q.types.VegaVisualization.load" href="#h2o_q.types.VegaVisualization.load">load</a></code></li>
<li><code><a title="h2o_q.types.VegaVisualization.specification" href="#h2o_q.types.VegaVisualization.specification">specification</a></code></li>
<li><code><a title="h2o_q.types.VegaVisualization.width" href="#h2o_q.types.VegaVisualization.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.Visualization" href="#h2o_q.types.Visualization">Visualization</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.Visualization.data" href="#h2o_q.types.Visualization.data">data</a></code></li>
<li><code><a title="h2o_q.types.Visualization.dump" href="#h2o_q.types.Visualization.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.Visualization.height" href="#h2o_q.types.Visualization.height">height</a></code></li>
<li><code><a title="h2o_q.types.Visualization.load" href="#h2o_q.types.Visualization.load">load</a></code></li>
<li><code><a title="h2o_q.types.Visualization.plot" href="#h2o_q.types.Visualization.plot">plot</a></code></li>
<li><code><a title="h2o_q.types.Visualization.width" href="#h2o_q.types.Visualization.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.WideBarStatCard" href="#h2o_q.types.WideBarStatCard">WideBarStatCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.WideBarStatCard.aux_value" href="#h2o_q.types.WideBarStatCard.aux_value">aux_value</a></code></li>
<li><code><a title="h2o_q.types.WideBarStatCard.box" href="#h2o_q.types.WideBarStatCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.WideBarStatCard.commands" href="#h2o_q.types.WideBarStatCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.WideBarStatCard.data" href="#h2o_q.types.WideBarStatCard.data">data</a></code></li>
<li><code><a title="h2o_q.types.WideBarStatCard.dump" href="#h2o_q.types.WideBarStatCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.WideBarStatCard.load" href="#h2o_q.types.WideBarStatCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.WideBarStatCard.plot_color" href="#h2o_q.types.WideBarStatCard.plot_color">plot_color</a></code></li>
<li><code><a title="h2o_q.types.WideBarStatCard.progress" href="#h2o_q.types.WideBarStatCard.progress">progress</a></code></li>
<li><code><a title="h2o_q.types.WideBarStatCard.title" href="#h2o_q.types.WideBarStatCard.title">title</a></code></li>
<li><code><a title="h2o_q.types.WideBarStatCard.value" href="#h2o_q.types.WideBarStatCard.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.WideGaugeStatCard" href="#h2o_q.types.WideGaugeStatCard">WideGaugeStatCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.WideGaugeStatCard.aux_value" href="#h2o_q.types.WideGaugeStatCard.aux_value">aux_value</a></code></li>
<li><code><a title="h2o_q.types.WideGaugeStatCard.box" href="#h2o_q.types.WideGaugeStatCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.WideGaugeStatCard.commands" href="#h2o_q.types.WideGaugeStatCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.WideGaugeStatCard.data" href="#h2o_q.types.WideGaugeStatCard.data">data</a></code></li>
<li><code><a title="h2o_q.types.WideGaugeStatCard.dump" href="#h2o_q.types.WideGaugeStatCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.WideGaugeStatCard.load" href="#h2o_q.types.WideGaugeStatCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.WideGaugeStatCard.plot_color" href="#h2o_q.types.WideGaugeStatCard.plot_color">plot_color</a></code></li>
<li><code><a title="h2o_q.types.WideGaugeStatCard.progress" href="#h2o_q.types.WideGaugeStatCard.progress">progress</a></code></li>
<li><code><a title="h2o_q.types.WideGaugeStatCard.title" href="#h2o_q.types.WideGaugeStatCard.title">title</a></code></li>
<li><code><a title="h2o_q.types.WideGaugeStatCard.value" href="#h2o_q.types.WideGaugeStatCard.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="h2o_q.types.WideSeriesStatCard" href="#h2o_q.types.WideSeriesStatCard">WideSeriesStatCard</a></code></h4>
<ul class="two-column">
<li><code><a title="h2o_q.types.WideSeriesStatCard.aux_value" href="#h2o_q.types.WideSeriesStatCard.aux_value">aux_value</a></code></li>
<li><code><a title="h2o_q.types.WideSeriesStatCard.box" href="#h2o_q.types.WideSeriesStatCard.box">box</a></code></li>
<li><code><a title="h2o_q.types.WideSeriesStatCard.commands" href="#h2o_q.types.WideSeriesStatCard.commands">commands</a></code></li>
<li><code><a title="h2o_q.types.WideSeriesStatCard.data" href="#h2o_q.types.WideSeriesStatCard.data">data</a></code></li>
<li><code><a title="h2o_q.types.WideSeriesStatCard.dump" href="#h2o_q.types.WideSeriesStatCard.dump">dump</a></code></li>
<li><code><a title="h2o_q.types.WideSeriesStatCard.load" href="#h2o_q.types.WideSeriesStatCard.load">load</a></code></li>
<li><code><a title="h2o_q.types.WideSeriesStatCard.plot_category" href="#h2o_q.types.WideSeriesStatCard.plot_category">plot_category</a></code></li>
<li><code><a title="h2o_q.types.WideSeriesStatCard.plot_color" href="#h2o_q.types.WideSeriesStatCard.plot_color">plot_color</a></code></li>
<li><code><a title="h2o_q.types.WideSeriesStatCard.plot_curve" href="#h2o_q.types.WideSeriesStatCard.plot_curve">plot_curve</a></code></li>
<li><code><a title="h2o_q.types.WideSeriesStatCard.plot_data" href="#h2o_q.types.WideSeriesStatCard.plot_data">plot_data</a></code></li>
<li><code><a title="h2o_q.types.WideSeriesStatCard.plot_type" href="#h2o_q.types.WideSeriesStatCard.plot_type">plot_type</a></code></li>
<li><code><a title="h2o_q.types.WideSeriesStatCard.plot_value" href="#h2o_q.types.WideSeriesStatCard.plot_value">plot_value</a></code></li>
<li><code><a title="h2o_q.types.WideSeriesStatCard.plot_zero_value" href="#h2o_q.types.WideSeriesStatCard.plot_zero_value">plot_zero_value</a></code></li>
<li><code><a title="h2o_q.types.WideSeriesStatCard.title" href="#h2o_q.types.WideSeriesStatCard.title">title</a></code></li>
<li><code><a title="h2o_q.types.WideSeriesStatCard.value" href="#h2o_q.types.WideSeriesStatCard.value">value</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>